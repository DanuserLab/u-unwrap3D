<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>unwrap3D.Tracking.tracking &mdash; u-Unwrap3D 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> u-Unwrap3D
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">u-Unwrap3D</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>unwrap3D.Tracking.tracking</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for unwrap3D.Tracking.tracking</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Fri Jul 15 16:50:05 2022</span>

<span class="sd">@author: felix</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">..Utility_Functions</span> <span class="kn">import</span> <span class="n">file_io</span> <span class="k">as</span> <span class="n">fio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 


<span class="c1"># is there a quick way to compute the occupied bbox density. </span>
<div class="viewcode-block" id="remove_very_large_bbox"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.remove_very_large_bbox">[docs]</a><span class="k">def</span> <span class="nf">remove_very_large_bbox</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aspect_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">max_density</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">return_ind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;density&#39;</span><span class="p">:</span>
        
        <span class="n">boxes_</span> <span class="o">=</span> <span class="n">boxes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">keep_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">aspect_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">])</span>
            
            <span class="n">aspect_w_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">wh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">.1</span><span class="p">)</span>
            <span class="n">boxes_</span> <span class="o">=</span> <span class="n">boxes_</span><span class="p">[</span><span class="n">aspect_w_h</span><span class="o">&lt;=</span><span class="n">aspect_ratio</span><span class="p">]</span>
            <span class="n">keep_ind</span> <span class="o">=</span> <span class="n">keep_ind</span><span class="p">[</span><span class="n">aspect_w_h</span><span class="o">&lt;=</span><span class="n">aspect_ratio</span><span class="p">]</span>
        
        <span class="n">box_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">bbox_coverage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_</span><span class="p">))</span>
        <span class="n">box_centroids_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">boxes_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes_</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">box_centroids_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">((</span><span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">boxes_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes_</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
            <span class="n">box_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">box_centroids_x</span><span class="p">,</span> <span class="n">box_centroids_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">box_centroids_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">boxes_</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">boxes_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">boxes_</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">boxes_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span><span class="mf">.1</span><span class="p">)</span>
        
            <span class="n">box_centroids_distance</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">box_centroids</span><span class="p">)</span>
            <span class="n">bbox_coverage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">box_centroids_distance</span><span class="o">&lt;=</span><span class="n">box_centroids_r</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># box_density[box_centroids_y, box_centroids_x] += 1</span>
            <span class="k">for</span> <span class="n">cent_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">box_centroids_x</span><span class="p">)):</span>
                <span class="n">cent_x</span> <span class="o">=</span> <span class="n">box_centroids_x</span><span class="p">[</span><span class="n">cent_ii</span><span class="p">]</span>
                <span class="n">cent_y</span> <span class="o">=</span> <span class="n">box_centroids_y</span><span class="p">[</span><span class="n">cent_ii</span><span class="p">]</span>
                <span class="n">box_density</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cent_y</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">cent_x</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">for</span> <span class="n">box_ii</span><span class="p">,</span> <span class="n">box</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">boxes_</span><span class="p">):</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">box</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">y2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">bbox_coverage</span><span class="p">[</span><span class="n">box_ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">box_density</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">y1</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">y2</span><span class="p">),</span> 
                                                              <span class="nb">int</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">x2</span><span class="p">)])</span>        
        <span class="c1"># print(bbox_coverage)</span>
        <span class="k">if</span> <span class="n">return_ind</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">boxes_</span><span class="p">[</span><span class="n">bbox_coverage</span><span class="o">&lt;=</span><span class="n">max_density</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">boxes_</span><span class="p">[</span><span class="n">bbox_coverage</span><span class="o">&lt;=</span><span class="n">max_density</span><span class="p">],</span> <span class="n">keep_ind</span><span class="p">[</span><span class="n">bbox_coverage</span><span class="o">&lt;=</span><span class="n">max_density</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
        <span class="n">areas_box</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">area_shape</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        
    <span class="c1">#    print(area_shape)</span>
        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="n">boxes</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">box</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
            
            <span class="n">area_box</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span>
            <span class="n">areas_box</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area_box</span><span class="p">)</span>
            
        <span class="n">areas_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">areas_box</span><span class="p">)</span>
        <span class="n">areas_box_frac</span> <span class="o">=</span> <span class="n">areas_box</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">area_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">boxes</span><span class="p">[</span><span class="n">areas_box_frac</span><span class="o">&lt;=</span><span class="n">thresh</span><span class="p">]</span></div>



<div class="viewcode-block" id="Eval_dense_optic_flow"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.Eval_dense_optic_flow">[docs]</a><span class="k">def</span> <span class="nf">Eval_dense_optic_flow</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">present</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Computes the optical flow using Farnebacks Method</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prev : numpy array</span>
<span class="sd">        previous frame, m x n image</span>
<span class="sd">    present :  numpy array</span>
<span class="sd">        current frame, m x n image</span>
<span class="sd">    params : Python dict</span>
<span class="sd">        a dict object to pass all algorithm parameters. Fields are the same as that in the opencv documentation, https://docs.opencv.org/2.4/modules/video/doc/motion_analysis_and_object_tracking.html. Our recommended starting values:</span>
<span class="sd">                </span>
<span class="sd">            * params[&#39;pyr_scale&#39;] = 0.5</span>
<span class="sd">            * params[&#39;levels&#39;] = 3</span>
<span class="sd">            * params[&#39;winsize&#39;] = 15</span>
<span class="sd">            * params[&#39;iterations&#39;] = 3</span>
<span class="sd">            * params[&#39;poly_n&#39;] = 5</span>
<span class="sd">            * params[&#39;poly_sigma&#39;] = 1.2</span>
<span class="sd">            * params[&#39;flags&#39;] = 0</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flow : finds the displacement field between frames, prev and present such that :math:`\mathrm{prev}(y,x) = \mathrm{next}(y+\mathrm{flow}(y,x)[1], x+\mathrm{flow}(y,x)[0])` where (x,y) is the cartesian coordinates of the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="kn">import</span> <span class="nn">cv2</span>

    <span class="c1"># Check version of opencv installed, if not 3.0.0 then issue alert.</span>
<span class="c1">#    if &#39;3.0.0&#39; in cv2.__version__ or &#39;3.1.0&#39; in cv2.__version__:</span>
        <span class="c1"># Make the image pixels into floats.</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">present</span> <span class="o">=</span> <span class="n">present</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;3&#39;</span> <span class="ow">or</span> <span class="n">cv2</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcOpticalFlowFarneback</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">present</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;pyr_scale&#39;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;winsize&#39;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;iterations&#39;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;poly_n&#39;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;poly_sigma&#39;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;flags&#39;</span><span class="p">])</span> 
    <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcOpticalFlowFarneback</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">present</span><span class="p">,</span> <span class="n">pyr_scale</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;pyr_scale&#39;</span><span class="p">],</span> <span class="n">levels</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">],</span> <span class="n">winsize</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;winsize&#39;</span><span class="p">],</span> <span class="n">iterations</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;iterations&#39;</span><span class="p">],</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;poly_n&#39;</span><span class="p">],</span> <span class="n">poly_sigma</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;poly_sigma&#39;</span><span class="p">],</span> <span class="n">flags</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;flags&#39;</span><span class="p">])</span> 
<span class="c1">#    print(flow.shape)</span>
    <span class="k">return</span> <span class="n">flow</span></div>


<div class="viewcode-block" id="rescale_intensity_percent"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.rescale_intensity_percent">[docs]</a><span class="k">def</span> <span class="nf">rescale_intensity_percent</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">intensity_range</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">98</span><span class="p">]):</span>

    <span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">rescale_intensity</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">p2</span><span class="p">,</span> <span class="n">p98</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">intensity_range</span><span class="p">)</span>
    <span class="n">img_</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">p98</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">img_</span></div>


<span class="c1"># add in optical flow. </span>
<div class="viewcode-block" id="extract_optflow"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.extract_optflow">[docs]</a><span class="k">def</span> <span class="nf">extract_optflow</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">optical_flow_params</span><span class="p">,</span> <span class="n">rescale_intensity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">intensity_range</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">98</span><span class="p">]):</span> 
    <span class="c1"># uses CV2 built in farneback ver. which is very fast and good for very noisy and small motion</span>
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">rescale_intensity</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 

    <span class="n">vid_flow</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">frame0</span> <span class="o">=</span> <span class="n">rescale_intensity_percent</span><span class="p">(</span><span class="n">vid</span><span class="p">[</span><span class="n">frame</span><span class="p">],</span> <span class="n">intensity_range</span><span class="o">=</span><span class="n">intensity_range</span><span class="p">)</span>
        <span class="n">frame1</span> <span class="o">=</span> <span class="n">rescale_intensity_percent</span><span class="p">(</span><span class="n">vid</span><span class="p">[</span><span class="n">frame</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">intensity_range</span><span class="o">=</span><span class="n">intensity_range</span><span class="p">)</span>
        <span class="n">flow01</span> <span class="o">=</span> <span class="n">Eval_dense_optic_flow</span><span class="p">(</span><span class="n">frame0</span><span class="p">,</span> <span class="n">frame1</span><span class="p">,</span> 
                                       <span class="n">params</span><span class="o">=</span><span class="n">optical_flow_params</span><span class="p">)</span>
        <span class="n">vid_flow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flow01</span><span class="p">)</span>
    <span class="n">vid_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vid_flow</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># to save some space. </span>

    <span class="k">return</span> <span class="n">vid_flow</span></div>



<div class="viewcode-block" id="predict_new_boxes_flow_tf"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.predict_new_boxes_flow_tf">[docs]</a><span class="k">def</span> <span class="nf">predict_new_boxes_flow_tf</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">flow</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">estimate_transform</span><span class="p">,</span> <span class="n">matrix_transform</span><span class="p">,</span> <span class="n">SimilarityTransform</span>
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">ransac</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">flow_x</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">flow_y</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
      
    <span class="n">new_boxes_tf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tfs</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="n">boxes</span><span class="p">:</span>
        <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span> <span class="o">=</span> <span class="n">box</span>
        
        <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span> <span class="n">y1</span> <span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">y1</span><span class="p">);</span> <span class="n">x2</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span> <span class="n">y2</span> <span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">y2</span><span class="p">);</span>  <span class="c1"># added, weirdly ...</span>
        
        <span class="c1"># how to take into account the change in size (scale + translation ? very difficult. )</span>
        <span class="n">flow_x_patch</span> <span class="o">=</span> <span class="n">flow_x</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">flow_y_patch</span> <span class="o">=</span> <span class="n">flow_y</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">nrows_</span><span class="p">,</span> <span class="n">ncols_</span> <span class="o">=</span> <span class="n">flow_x_patch</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="c1"># threshold_the mag</span>
        <span class="n">mag_patch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">flow_x_patch</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">flow_y_patch</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">mag_patch</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="c1">#        select = np.ones(mag_patch.shape) &gt; 0</span>
        <span class="n">pix_X</span><span class="p">,</span> <span class="n">pix_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ncols_</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows_</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if we cannot record movement in the box just append the original ?</span>
            <span class="n">tfs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">new_boxes_tf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_x</span> <span class="o">=</span> <span class="n">pix_X</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">();</span> <span class="n">dst_x</span> <span class="o">=</span> <span class="n">src_x</span> <span class="o">+</span> <span class="n">flow_x_patch</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
            <span class="n">src_y</span> <span class="o">=</span> <span class="n">pix_Y</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">();</span> <span class="n">dst_y</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="n">flow_y_patch</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">src_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">src_y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]])</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">dst_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">dst_y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]])</span>
            
            <span class="c1"># estimate the transformation. </span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">estimate_transform</span><span class="p">(</span><span class="s1">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dst</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">tf_scale</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">scale</span><span class="p">;</span> <span class="n">tf_offset</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">translation</span>
            
<span class="c1">#            print tf_scale, tf_offset</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tf_scale</span><span class="p">):</span>
                <span class="n">tfs</span><span class="o">.</span><span class="n">append</span><span class="p">(([]))</span>
                <span class="n">new_boxes_tf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">x2</span><span class="p">);</span> <span class="n">w</span> <span class="o">=</span> <span class="n">x2</span><span class="o">-</span><span class="n">x1</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">y2</span><span class="p">);</span> <span class="n">h</span> <span class="o">=</span> <span class="n">y2</span><span class="o">-</span><span class="n">y1</span>
                
                <span class="n">x1_tf_new</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">tf_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">w</span><span class="o">*</span><span class="n">tf_scale</span><span class="o">/</span><span class="mf">2.</span>
                <span class="n">y1_tf_new</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">tf_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="o">*</span><span class="n">tf_scale</span><span class="o">/</span><span class="mf">2.</span>
                <span class="n">x2_tf_new</span> <span class="o">=</span> <span class="n">x1_tf_new</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">tf_scale</span>
                <span class="n">y2_tf_new</span> <span class="o">=</span> <span class="n">y1_tf_new</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">tf_scale</span>
                
        <span class="c1">#        print x1_tf_new</span>
                <span class="n">tfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
                <span class="n">new_boxes_tf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1_tf_new</span><span class="p">,</span> <span class="n">y1_tf_new</span><span class="p">,</span> <span class="n">x2_tf_new</span><span class="p">,</span> <span class="n">y2_tf_new</span><span class="p">])</span>
        
    <span class="n">new_boxes_tf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_boxes_tf</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tfs</span><span class="p">,</span> <span class="n">new_boxes_tf</span></div>

<span class="c1"># this version is just over the boxes. given voc format. </span>
<div class="viewcode-block" id="bbox_iou_corner_xy"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.bbox_iou_corner_xy">[docs]</a><span class="k">def</span> <span class="nf">bbox_iou_corner_xy</span><span class="p">(</span><span class="n">bboxes1</span><span class="p">,</span> <span class="n">bboxes2</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes the distance matrix between two sets of bounding boxes.</span>
<span class="sd">    Args:</span>
<span class="sd">        bboxes1: shape (total_bboxes1, 4)</span>
<span class="sd">            with x1, y1, x2, y2 point order.</span>
<span class="sd">        bboxes2: shape (total_bboxes2, 4)</span>
<span class="sd">            with x1, y1, x2, y2 point order.</span>

<span class="sd">        p1 *-----</span>
<span class="sd">           |     |</span>
<span class="sd">           |_____* p2</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor with shape (total_bboxes1, total_bboxes2)</span>
<span class="sd">        with the IoU (intersection over union) of bboxes1[i] and bboxes2[j]</span>
<span class="sd">        in [i, j].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x11</span><span class="p">,</span> <span class="n">y11</span><span class="p">,</span> <span class="n">x12</span><span class="p">,</span> <span class="n">y12</span> <span class="o">=</span> <span class="n">bboxes1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">bboxes1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bboxes1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">bboxes1</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">x21</span><span class="p">,</span> <span class="n">y21</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">y22</span> <span class="o">=</span> <span class="n">bboxes2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">bboxes2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bboxes2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">bboxes2</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>


    <span class="n">x11</span> <span class="o">=</span> <span class="n">x11</span><span class="p">[:,</span><span class="kc">None</span><span class="p">];</span> <span class="n">y11</span> <span class="o">=</span> <span class="n">y11</span><span class="p">[:,</span><span class="kc">None</span><span class="p">];</span> <span class="n">x12</span><span class="o">=</span><span class="n">x12</span><span class="p">[:,</span><span class="kc">None</span><span class="p">];</span> <span class="n">y12</span><span class="o">=</span><span class="n">y12</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">x21</span> <span class="o">=</span> <span class="n">x21</span><span class="p">[:,</span><span class="kc">None</span><span class="p">];</span> <span class="n">y21</span> <span class="o">=</span> <span class="n">y21</span><span class="p">[:,</span><span class="kc">None</span><span class="p">];</span> <span class="n">x22</span><span class="o">=</span><span class="n">x22</span><span class="p">[:,</span><span class="kc">None</span><span class="p">];</span> <span class="n">y22</span><span class="o">=</span><span class="n">y22</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>

    <span class="n">xI1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x11</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x21</span><span class="p">))</span>
    <span class="n">xI2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x12</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x22</span><span class="p">))</span>

    <span class="n">yI1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y11</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">y21</span><span class="p">))</span>
    <span class="n">yI2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y12</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">y22</span><span class="p">))</span>

    <span class="n">inter_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="n">xI2</span> <span class="o">-</span> <span class="n">xI1</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="n">yI2</span> <span class="o">-</span> <span class="n">yI1</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span>

    <span class="n">bboxes1_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">x12</span> <span class="o">-</span> <span class="n">x11</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y12</span> <span class="o">-</span> <span class="n">y11</span><span class="p">)</span>
    <span class="n">bboxes2_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">x22</span> <span class="o">-</span> <span class="n">x21</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y22</span> <span class="o">-</span> <span class="n">y21</span><span class="p">)</span>

    <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">bboxes1_area</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">bboxes2_area</span><span class="p">))</span> <span class="o">-</span> <span class="n">inter_area</span>

    <span class="c1"># some invalid boxes should have iou of 0 instead of NaN</span>
    <span class="c1"># If inter_area is 0, then this result will be 0; if inter_area is</span>
    <span class="c1"># not 0, then union is not too, therefore adding a epsilon is OK.</span>
    <span class="k">return</span> <span class="n">inter_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">union</span><span class="o">+</span><span class="mf">0.0001</span><span class="p">)</span></div>


<div class="viewcode-block" id="bbox_tracks_2_array"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.bbox_tracks_2_array">[docs]</a><span class="k">def</span> <span class="nf">bbox_tracks_2_array</span><span class="p">(</span><span class="n">vid_bbox_tracks</span><span class="p">,</span> <span class="n">nframes</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">N_tracks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vid_bbox_tracks</span><span class="p">)</span>

    <span class="n">vid_bbox_tracks_all_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_tracks</span><span class="p">,</span> <span class="n">nframes</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="n">vid_bbox_tracks_all_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">vid_bbox_tracks_prob_all_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_tracks</span><span class="p">,</span> <span class="n">nframes</span><span class="p">))</span>
    <span class="n">vid_bbox_tracks_prob_all_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_tracks</span><span class="p">):</span>
        <span class="n">tra_ii</span> <span class="o">=</span> <span class="n">vid_bbox_tracks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">tra_ii_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tra_iii</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tra_iii</span> <span class="ow">in</span> <span class="n">tra_ii</span><span class="p">])</span>
        <span class="n">tra_ii_boxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tra_iii</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tra_iii</span> <span class="ow">in</span> <span class="n">tra_ii</span><span class="p">])</span> <span class="c1"># boxes is the last array. </span>
        <span class="n">tra_ii_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tra_iii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tra_iii</span> <span class="ow">in</span> <span class="n">tra_ii</span><span class="p">])</span>

        <span class="n">vid_bbox_tracks_all_array</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">tra_ii_times</span><span class="p">]</span> <span class="o">=</span> <span class="n">tra_ii_boxes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vid_bbox_tracks_prob_all_array</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">tra_ii_times</span><span class="p">]</span> <span class="o">=</span> <span class="n">tra_ii_prob</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">vid_bbox_tracks_prob_all_array</span><span class="p">,</span> <span class="n">vid_bbox_tracks_all_array</span></div>


<div class="viewcode-block" id="bbox_scalar_2_array"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.bbox_scalar_2_array">[docs]</a><span class="k">def</span> <span class="nf">bbox_scalar_2_array</span><span class="p">(</span><span class="n">vid_scalar_tracks</span><span class="p">,</span> <span class="n">nframes</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">N_tracks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vid_scalar_tracks</span><span class="p">)</span>

    <span class="n">vid_scalar_tracks_all_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_tracks</span><span class="p">,</span> <span class="n">nframes</span><span class="p">))</span>
    <span class="n">vid_scalar_tracks_all_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_tracks</span><span class="p">):</span>
        <span class="n">tra_ii</span> <span class="o">=</span> <span class="n">vid_scalar_tracks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">tra_ii_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tra_iii</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tra_iii</span> <span class="ow">in</span> <span class="n">tra_ii</span><span class="p">])</span>
        <span class="n">tra_ii_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tra_iii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tra_iii</span> <span class="ow">in</span> <span class="n">tra_ii</span><span class="p">])</span>

        <span class="n">vid_scalar_tracks_all_array</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">tra_ii_times</span><span class="p">]</span> <span class="o">=</span> <span class="n">tra_ii_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">vid_scalar_tracks_all_array</span></div>



<div class="viewcode-block" id="unpad_bbox_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.unpad_bbox_tracks">[docs]</a><span class="k">def</span> <span class="nf">unpad_bbox_tracks</span><span class="p">(</span><span class="n">all_uniq_tracks</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nframes</span><span class="p">,</span> <span class="n">aspect_ratio</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span> 
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="c1"># define the bounds. </span>
    <span class="n">bounds_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">bounds_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
    
    <span class="n">all_uniq_bbox_tracks_new</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">tra_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_uniq_tracks</span><span class="p">)):</span>

        <span class="n">all_uniq_tracks_ii</span> <span class="o">=</span> <span class="n">all_uniq_tracks</span><span class="p">[</span><span class="n">tra_ii</span><span class="p">]</span>
        <span class="c1"># all_track_labels_ii = track_labels[tra_ii]</span>
        <span class="n">all_uniq_bbox_track_ii</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_uniq_tracks_ii</span><span class="p">)):</span>
            
            <span class="n">tra</span> <span class="o">=</span> <span class="n">all_uniq_tracks_ii</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="c1"># tra_label = all_track_labels_ii[jj][-1]</span>
            <span class="n">tp</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">tra</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">bbox</span>
            
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span>
    
            <span class="n">x1_</span><span class="o">=</span> <span class="n">x1</span><span class="o">-</span><span class="n">pad</span> 
            <span class="n">y1_</span><span class="o">=</span> <span class="n">y1</span><span class="o">-</span><span class="n">pad</span> 
            <span class="n">x2_</span> <span class="o">=</span> <span class="n">x2</span><span class="o">-</span><span class="n">pad</span>
            <span class="n">y2_</span> <span class="o">=</span> <span class="n">y2</span><span class="o">-</span><span class="n">pad</span>
            <span class="c1"># print(x1_, x2_, y1_, y2_)</span>
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This is more complex ... </span>
<span class="sd">                if y &lt; 0 or  y &gt; shape[0], then we have to flip x coordinate and flip y-coordinate.  </span>
<span class="sd">                # test this inversion ! ######## ---&gt; for a fixed timepoint, just to double ceck we are getting the correct alogrithm. !. </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># left top </span>
            <span class="k">if</span> <span class="n">y1_</span> <span class="o">&lt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&lt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y1_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y1_</span>  <span class="c1"># flip y </span>
                <span class="c1"># x1_ = (bounds_x[1]+1*pad + x1_) - bounds_x[1] # flip x axis. </span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_</span> 
    
            <span class="k">if</span> <span class="n">y2_</span> <span class="o">&lt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&lt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y2_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y2_</span> 
                <span class="c1"># x2_ = (bounds_x[1]+1*pad + x2_) - bounds_x[1] # flip x axis. </span>
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_</span> 
            <span class="c1"># middle top # this is ok </span>
            <span class="k">if</span> <span class="n">y1_</span> <span class="o">&lt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&gt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x1_</span> <span class="o">&lt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y1_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y1_</span> 
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_</span> <span class="c1"># flip x axis. </span>
    
            <span class="k">if</span> <span class="n">y2_</span> <span class="o">&lt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&gt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x2_</span> <span class="o">&lt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y2_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y2_</span> 
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_</span> <span class="c1"># flip x axis. </span>
                
            <span class="c1"># right top </span>
            <span class="k">if</span> <span class="n">y1_</span> <span class="o">&lt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&gt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y1_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y1_</span>  <span class="c1"># flip y </span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">-</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
            <span class="k">if</span> <span class="n">y2_</span> <span class="o">&lt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&gt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y2_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y2_</span> 
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">-</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
            <span class="c1"># middle left </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y1_</span> <span class="o">&gt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y1_</span> <span class="o">&lt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&lt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># simply shift the x1_ back </span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">x1_</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y2_</span> <span class="o">&gt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y2_</span> <span class="o">&lt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&lt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> 
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">x2_</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    
            <span class="c1"># middle right</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y1_</span> <span class="o">&gt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y1_</span> <span class="o">&lt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&gt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># simply shift the x1_ back </span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">x1_</span> <span class="o">-</span> <span class="p">(</span><span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y2_</span> <span class="o">&gt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">y2_</span> <span class="o">&lt;=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&gt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># simply shift the x1_ back </span>
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">x2_</span> <span class="o">-</span> <span class="p">(</span><span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    
            <span class="c1"># left bottom </span>
            <span class="k">if</span> <span class="n">y1_</span> <span class="o">&gt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&lt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y1_</span> <span class="o">=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1_</span><span class="p">)</span> <span class="c1"># flipping at the other end.  </span>
                <span class="c1"># x1_ = (bounds_x[1]+1*p-d + x1_) - bounds_x[1]  # flip x axis.</span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_</span> 
            <span class="k">if</span> <span class="n">y2_</span> <span class="o">&gt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&lt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y2_</span> <span class="o">=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2_</span><span class="p">)</span> <span class="c1"># flipping at the other end. </span>
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_</span> 
                <span class="c1"># x2_ = (bounds_x[1]+1*pad + x2_) - bounds_x[1]</span>
                <span class="c1"># x2_ = x2_ - (bounds_x[1]+1)</span>
                
            <span class="c1"># middle bottom </span>
            <span class="k">if</span> <span class="n">y1_</span> <span class="o">&gt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&gt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x1_</span> <span class="o">&lt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y1_</span> <span class="o">=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1_</span><span class="p">)</span> <span class="c1"># flipping at the other end.  </span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_</span> <span class="c1"># flip x axis. </span>
    
            <span class="k">if</span> <span class="n">y2_</span> <span class="o">&gt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&gt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x2_</span> <span class="o">&lt;=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y2_</span> <span class="o">=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2_</span><span class="p">)</span> <span class="c1"># flipping at the other end. </span>
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_</span> <span class="c1"># flip x axis. </span>
    
            <span class="c1"># right bottom  </span>
            <span class="k">if</span> <span class="n">y1_</span> <span class="o">&gt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">&gt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y1_</span> <span class="o">=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1_</span><span class="p">)</span> <span class="c1"># flipping at the other end.  </span>
                <span class="c1"># x1_ = x1_ - (bounds_x[1]+1*pad) + bounds_x[1] # flip x axis. </span>
                <span class="n">x1_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x1_</span> <span class="o">-</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">y2_</span> <span class="o">&gt;</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">&gt;</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># then we flip the x axis and flip the y coordinate into the shape. (=180 rotation) </span>
                <span class="n">y2_</span> <span class="o">=</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2_</span><span class="p">)</span> <span class="c1"># flipping at the other end. </span>
                <span class="c1"># x2_ = x2_ - (bounds_x[1]+1*pad) + bounds_x[1] # flip x axis. </span>
                <span class="n">x2_</span> <span class="o">=</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">-</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            need a accuracy test for the designated label if the label is not the background label!. </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># we check the sign change here! to know if we need to modify.  </span>
            <span class="n">w1_</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2_</span> <span class="o">-</span> <span class="n">x1_</span><span class="p">)</span> <span class="c1"># x2 must be higher? if negative that means x1 needs to be shifted back. </span>
            <span class="n">h1_</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2_</span> <span class="o">-</span> <span class="n">y1_</span><span class="p">)</span> <span class="c1"># if negative means y1 needs to be shifted </span>
            <span class="c1"># print(w1_, h1_, (x1_,y1_,x2_,y2_))</span>
            <span class="k">if</span> <span class="n">w1_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># we have to shift but dunno which way. </span>
                <span class="n">x1_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x1_</span> <span class="o">-</span> <span class="p">(</span><span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">x2_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x2_</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds_x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
                <span class="n">area_x1_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2_</span> <span class="o">-</span> <span class="n">x1_test</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y2_</span><span class="o">-</span><span class="n">y1_</span><span class="p">)</span>
                <span class="n">area_x2_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2_test</span> <span class="o">-</span> <span class="n">x1_</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y2_</span><span class="o">-</span><span class="n">y1_</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">area_x1_test</span> <span class="o">&gt;</span> <span class="n">area_x2_test</span><span class="p">:</span>
                    <span class="n">x1_</span> <span class="o">=</span> <span class="n">x1_test</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x2_</span> <span class="o">=</span> <span class="n">x2_test</span>
    
            <span class="k">if</span> <span class="n">h1_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># y1_ = np.clip(y1_ - (bounds_y[1]+1), 0, bounds_y[1])</span>
                <span class="c1"># y2_ = np.clip(y2_ + (bounds_y[1]+1), 0, bounds_y[1])</span>
                <span class="c1"># we have to shift but dunno which way. </span>
                <span class="n">y1_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">y1_</span> <span class="o">-</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># make y1 smaller or </span>
                <span class="n">y2_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">y2_</span> <span class="o">+</span> <span class="p">(</span><span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds_y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># make y2 bigger</span>
    
                <span class="n">area_y1_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y2_</span> <span class="o">-</span> <span class="n">y1_test</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2_</span> <span class="o">-</span> <span class="n">x1_</span><span class="p">)</span>
                <span class="n">area_y2_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y2_test</span> <span class="o">-</span> <span class="n">y1_</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2_</span> <span class="o">-</span> <span class="n">x1_</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">area_y1_test</span> <span class="o">&gt;</span> <span class="n">area_y2_test</span><span class="p">:</span>
                    <span class="n">y1_</span> <span class="o">=</span> <span class="n">y1_test</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y2_</span> <span class="o">=</span> <span class="n">y2_test</span>
            
            <span class="n">bbox_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1_</span><span class="p">,</span> <span class="n">y1_</span><span class="p">,</span> <span class="n">x2_</span><span class="p">,</span> <span class="n">y2_</span><span class="p">])</span>
            <span class="n">all_uniq_bbox_track_ii</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tp</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">bbox_new</span><span class="p">])</span>
        <span class="n">all_uniq_bbox_tracks_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_uniq_bbox_track_ii</span><span class="p">)</span>

        <span class="c1"># convert this !. </span>
        <span class="c1"># compile into a numpy array and send this out too </span>
        <span class="n">_</span><span class="p">,</span> <span class="n">all_uniq_bbox_tracks_array_new</span> <span class="o">=</span> <span class="n">bbox_tracks_2_array</span><span class="p">(</span><span class="n">all_uniq_bbox_tracks_new</span><span class="p">,</span> <span class="n">nframes</span><span class="o">=</span><span class="n">nframes</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">all_uniq_bbox_tracks_centroids_xy_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">all_uniq_bbox_tracks_array_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">all_uniq_bbox_tracks_array_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> 
                                                          <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">all_uniq_bbox_tracks_array_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">all_uniq_bbox_tracks_array_new</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">])])</span>
        
    <span class="k">return</span> <span class="n">all_uniq_bbox_tracks_new</span><span class="p">,</span> <span class="n">all_uniq_bbox_tracks_array_new</span><span class="p">,</span> <span class="n">all_uniq_bbox_tracks_centroids_xy_new</span></div>


<div class="viewcode-block" id="assign_label_detection_to_track_frame_by_frame"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.assign_label_detection_to_track_frame_by_frame">[docs]</a><span class="k">def</span> <span class="nf">assign_label_detection_to_track_frame_by_frame</span><span class="p">(</span><span class="n">bbox_array_time</span><span class="p">,</span> <span class="n">bbox_detections_time</span><span class="p">,</span> <span class="n">min_iou</span><span class="o">=</span><span class="mf">.25</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    bbox_array_time: N_tracks x N_frames x 4</span>
<span class="sd">    bbox_detections_time: N_frames list </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>

    <span class="n">n_tracks</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bbox_array_time</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">bbox_array_time_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_tracks</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1"># initialise to background!. </span>
    <span class="n">bbox_array_time_labels</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># initialise to empty </span>

    <span class="c1"># iterate over time </span>
    <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)[:]:</span>
        <span class="c1"># reference</span>
        <span class="n">bbox_frame_tt</span> <span class="o">=</span> <span class="n">bbox_detections_time</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bbox_labels_tt</span> <span class="o">=</span> <span class="n">bbox_frame_tt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bbox_labels_bbox</span> <span class="o">=</span> <span class="n">bbox_frame_tt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">tracks_bboxes</span> <span class="o">=</span> <span class="n">bbox_array_time</span><span class="p">[:,</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">non_nan_select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tracks_bboxes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># just test the one coordinate. # only these need to be given a label!. </span>

        <span class="n">tracks_bboxes_bbox</span> <span class="o">=</span> <span class="n">tracks_bboxes</span><span class="p">[</span><span class="n">non_nan_select</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">labels_non_nan_select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tracks_bboxes_bbox</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="c1"># preinitialise </span>

        <span class="c1"># build the iou cost matrix. between rows: tracks and cols: the frame boxes. </span>
        <span class="n">iou_matrix</span> <span class="o">=</span> <span class="n">bbox_iou_corner_xy</span><span class="p">(</span><span class="n">tracks_bboxes_bbox</span><span class="p">,</span> 
                                        <span class="n">bbox_labels_bbox</span><span class="p">)</span> 
        <span class="n">iou_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">iou_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># to make it a dissimilarity matrix. </span>
        <span class="c1"># solve the pairing problem.</span>
        <span class="n">ind_ii</span><span class="p">,</span> <span class="n">ind_jj</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">iou_matrix</span><span class="p">)</span>
        
        <span class="c1"># threshold as the matching is maximal. </span>
        <span class="n">iou_ii_jj</span> <span class="o">=</span> <span class="n">iou_matrix</span><span class="p">[</span><span class="n">ind_ii</span><span class="p">,</span> <span class="n">ind_jj</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">iou_ii_jj</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">min_iou</span><span class="p">)</span> <span class="c1"># keep those with a minimal distance. </span>

        <span class="c1"># keep = iou_ii_jj &lt;= dist_thresh</span>
        <span class="n">ind_ii</span> <span class="o">=</span> <span class="n">ind_ii</span><span class="p">[</span><span class="n">keep</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">];</span> 
        <span class="n">ind_jj</span> <span class="o">=</span> <span class="n">ind_jj</span><span class="p">[</span><span class="n">keep</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">labels_non_nan_select</span><span class="p">[</span><span class="n">ind_ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox_labels_tt</span><span class="p">[</span><span class="n">ind_jj</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># copy back into the labels. </span>
        <span class="n">bbox_array_time_labels</span><span class="p">[</span><span class="n">non_nan_select</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels_non_nan_select</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># copy these assignments in now. </span>

    <span class="k">return</span> <span class="n">bbox_array_time_labels</span></div>


<div class="viewcode-block" id="compute_labeled_to_unlabeled_track"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.compute_labeled_to_unlabeled_track">[docs]</a><span class="k">def</span> <span class="nf">compute_labeled_to_unlabeled_track</span><span class="p">(</span><span class="n">track_label_array</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">n_tracks</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">=</span> <span class="n">track_label_array</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">track_counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tra_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_tracks</span><span class="p">):</span>
        <span class="n">tra_label</span> <span class="o">=</span> <span class="n">track_label_array</span><span class="p">[</span><span class="n">tra_ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_label</span><span class="p">))</span>

        <span class="n">num_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span>
        <span class="n">valid_labels</span> <span class="o">=</span> <span class="n">tra_label</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">num_nonzeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_labels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> 
        <span class="n">track_counts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">num_valid</span><span class="p">,</span> <span class="n">num_nonzeros</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_nonzeros</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_valid</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">])</span>
    <span class="n">track_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">track_counts</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">track_counts</span></div>


<div class="viewcode-block" id="moving_average_bbox_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.moving_average_bbox_tracks">[docs]</a><span class="k">def</span> <span class="nf">moving_average_bbox_tracks</span><span class="p">(</span><span class="n">list_tracks</span><span class="p">,</span> <span class="n">avg_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_winsize_prop</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">list_tracks_smooth</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">tra_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_tracks</span><span class="p">)):</span>

        <span class="n">track_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_tracks</span><span class="p">[</span><span class="n">tra_ii</span><span class="p">])</span> <span class="c1"># numpy array </span>
        <span class="n">winsize_track</span> <span class="o">=</span> <span class="n">winsize</span>
        <span class="k">if</span> <span class="n">winsize</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">track_ii</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_winsize_prop</span><span class="p">:</span> 
            <span class="c1"># then reduce the winsize smoothing!.   </span>
            <span class="n">winsize_track</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">track_ii</span><span class="p">)</span><span class="o">*</span><span class="n">min_winsize_prop</span><span class="p">))</span>
        <span class="n">track_ii_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">track_ii</span><span class="p">,</span> <span class="p">[[</span><span class="n">winsize_track</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">winsize_track</span><span class="o">//</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">track_ii_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">avg_func</span><span class="p">(</span><span class="n">track_ii_pad</span><span class="p">[</span><span class="n">tt</span><span class="p">:</span><span class="n">tt</span><span class="o">+</span><span class="n">winsize_track</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">track_ii</span><span class="p">))])</span>
        <span class="n">list_tracks_smooth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">track_ii_smooth</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">list_tracks_smooth</span></div>


<span class="c1"># using optical flow to implement a predictive tracker for blebs. </span>
<div class="viewcode-block" id="track_bleb_bbox"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.track_bleb_bbox">[docs]</a><span class="k">def</span> <span class="nf">track_bleb_bbox</span><span class="p">(</span><span class="n">vid_flow</span><span class="p">,</span> <span class="c1"># flow is already computed. </span>
                    <span class="n">vid_bboxes</span><span class="p">,</span> <span class="c1"># bbox files for each frame only !.   </span>
                    <span class="n">vid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># only for visualisation purposes. </span>
                    <span class="n">iou_match</span><span class="o">=</span><span class="mf">.25</span><span class="p">,</span>
                    <span class="n">ds_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">wait_time</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">min_aspect_ratio</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">max_dense_bbox_cover</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                    <span class="n">min_tra_len_filter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">min_tra_lifetime_ratio</span> <span class="o">=</span> <span class="mf">.1</span><span class="p">,</span> 
                    <span class="n">to_viz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">remove_eccentric_bbox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">saveanalysisfolder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    uses optical flow and registration as a predictor to improve tracking over occlusion.</span>
<span class="sd">    # we should preserve the bbox coordinates + the given probability from yolo.....  that way we can always do further processing? </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="kn">import</span> <span class="nn">os</span> 
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    initial setting up. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_shape</span> <span class="o">=</span> <span class="n">vid_flow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vid_flow</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># the number of frames in the video.</span>

    <span class="k">if</span> <span class="n">saveanalysisfolder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;saving graphics in folder: &#39;</span><span class="p">,</span> <span class="n">saveanalysisfolder</span><span class="p">)</span>
        <span class="c1"># saveanalysisfolder_movie = os.path.join(saveanalysisfolder, &#39;track_boundaries&#39;); mkdir(saveanalysisfolder_movie); </span>
        <span class="n">saveanalysisfolder_movie_bbox</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">saveanalysisfolder</span><span class="p">,</span> <span class="s1">&#39;track_bbox&#39;</span><span class="p">);</span> 
        <span class="n">mkdir</span><span class="p">(</span><span class="n">saveanalysisfolder_movie_bbox</span><span class="p">);</span>     

    <span class="c1"># =============================================================================</span>
    <span class="c1">#     BBox Tracks</span>
    <span class="c1"># =============================================================================</span>

    <span class="c1"># terminated_vid_cell_tracks = [] </span>
    <span class="n">terminated_vid_bbox_tracks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">terminated_check_match_bbox_tracks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">vid_bbox_tracks</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># this is to keep track of the actual bbox we use, including inferred. </span>
    <span class="n">vid_bbox_tracks_last_time</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># record when the last time a proper match was made. </span>
    <span class="n">vid_match_check_bbox_tracks</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># =============================================================================</span>
<span class="c1">#     build up the tracks dynamically now, frame by frame dynamically , with a track waiting time before termination. </span>
<span class="c1"># ============================================================================</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nframes</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if working set is empty or otherwise, then add to working set. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add these to the working tracks. </span>
        <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">vid_bbox_tracks</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> 
            <span class="c1"># bboxfile_ii = vid_bboxes[ii]</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            swap this element out. </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># prob_ii, boxes_ii = load_bbox_frame_voc( vid[0], bboxfile_ii) # modify this here!. </span>
            <span class="n">boxes_ii</span> <span class="o">=</span> <span class="n">vid_bboxes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># set prob dependent on the size of the boxes. (if 5D then take the first as a measure of objectness else assume 1.)</span>
            <span class="k">if</span> <span class="n">boxes_ii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> 
                <span class="n">prob_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">))</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prob_ii</span> <span class="o">=</span> <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">boxes_ii</span> <span class="o">=</span> <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">boxes_ii</span> <span class="o">=</span> <span class="n">boxes_ii</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ds_factor</span><span class="p">)</span>
            
            <span class="c1"># clip</span>
            <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
            <span class="c1"># remove all boxes that are have an area 1 pixels or less.               </span>
            <span class="n">boxes_ii_w</span> <span class="o">=</span> <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">boxes_ii_h</span> <span class="o">=</span> <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes_ii</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">boxes_ii</span> <span class="o">=</span> <span class="n">boxes_ii</span><span class="p">[</span><span class="n">boxes_ii_w</span><span class="o">*</span><span class="n">boxes_ii_h</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># suppress implausible. </span>
            <span class="k">if</span> <span class="n">remove_eccentric_bbox</span><span class="p">:</span>
              <span class="n">boxes_ii</span><span class="p">,</span> <span class="n">keep_ind_ii</span> <span class="o">=</span> <span class="n">remove_very_large_bbox</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">,</span> 
                                                            <span class="n">im_shape</span><span class="p">,</span> 
                                                            <span class="n">thresh</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                                                            <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1"># we don&#39;t expect it to be very long. </span>
                                                            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> 
                                                            <span class="n">max_density</span><span class="o">=</span><span class="n">max_dense_bbox_cover</span><span class="p">,</span> 
                                                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> 
                                                            <span class="n">return_ind</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">keep_ind_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span>

            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_ind_ii</span><span class="p">))</span> <span class="c1"># keep a check here.       </span>
            <span class="n">prob_ii</span> <span class="o">=</span> <span class="n">prob_ii</span><span class="p">[</span><span class="n">keep_ind_ii</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_ii</span><span class="p">)):</span>
                <span class="n">vid_bbox_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">ii</span><span class="p">,</span> <span class="n">prob_ii</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="n">boxes_ii</span><span class="p">[</span><span class="n">jj</span><span class="p">]]])</span> <span class="c1"># add the prob in as another entry here. </span>
                <span class="n">vid_bbox_tracks_last_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="c1"># update with current time. </span>
                <span class="n">vid_match_check_bbox_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="c1"># update with the current time., this is just to select whether this box was propagated or found in the original detections. </span>
                
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        load the current working set of tracks. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) check for track termination </span>
        <span class="c1"># get the last timepoint. </span>
        <span class="n">boxes_ii_track_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">vid_bbox_tracks_last_time</span><span class="p">)</span>
        
        <span class="c1"># check if any of the box tracks need to be terminated. </span>
        <span class="n">track_terminate</span> <span class="o">=</span>  <span class="n">boxes_ii_track_time</span> <span class="o">&lt;</span> <span class="n">ii</span> <span class="o">-</span> <span class="n">wait_time</span>
        <span class="n">track_terminate_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">track_terminate</span><span class="p">))[</span><span class="n">track_terminate</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">track_terminate_id</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># update the relevant info.</span>
            <span class="k">for</span> <span class="n">idd</span> <span class="ow">in</span> <span class="n">track_terminate_id</span><span class="p">:</span>
                <span class="c1">#update</span>
                <span class="n">terminated_vid_bbox_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid_bbox_tracks</span><span class="p">[</span><span class="n">idd</span><span class="p">][:</span><span class="o">-</span><span class="n">wait_time</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">terminated_check_match_bbox_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vid_match_check_bbox_tracks</span><span class="p">[</span><span class="n">idd</span><span class="p">][:</span><span class="o">-</span><span class="n">wait_time</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># terminated_vid_cell_tracks_properties.append(vid_cell_tracks_properties[idd][:-wait_time-1])</span>

            <span class="c1"># # reform the working set. </span>
            <span class="c1"># vid_cell_tracks = [vid_cell_tracks[jjj] for jjj in np.arange(len(vid_cell_tracks)) if jjj not in track_terminate_id] # i guess this is to keep track of actual cell ids that we segmented.</span>
            <span class="n">vid_bbox_tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">vid_bbox_tracks</span><span class="p">[</span><span class="n">jjj</span><span class="p">]</span> <span class="k">for</span> <span class="n">jjj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vid_bbox_tracks</span><span class="p">))</span> <span class="k">if</span> <span class="n">jjj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">track_terminate_id</span><span class="p">]</span> <span class="c1"># this is to keep track of the actual bbox we use, including inferred. </span>
            <span class="c1"># vid_cell_tracks_properties = [vid_cell_tracks_properties[jjj] for jjj in np.arange(len(vid_cell_tracks_properties)) if jjj not in track_terminate_id]</span>
            <span class="n">vid_bbox_tracks_last_time</span> <span class="o">=</span> <span class="p">[</span><span class="n">vid_bbox_tracks_last_time</span><span class="p">[</span><span class="n">jjj</span><span class="p">]</span> <span class="k">for</span> <span class="n">jjj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vid_bbox_tracks_last_time</span><span class="p">))</span> <span class="k">if</span> <span class="n">jjj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">track_terminate_id</span><span class="p">]</span>
            <span class="n">vid_match_check_bbox_tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">vid_match_check_bbox_tracks</span><span class="p">[</span><span class="n">jjj</span><span class="p">]</span> <span class="k">for</span> <span class="n">jjj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vid_match_check_bbox_tracks</span><span class="p">))</span> <span class="k">if</span> <span class="n">jjj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">track_terminate_id</span><span class="p">]</span>

        <span class="c1"># load the current version of the boxes. </span>
        <span class="n">boxes_ii_track</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">vid_bbox_tracks</span><span class="p">])</span> <span class="c1"># the bboxes to consider.</span>
        <span class="n">boxes_ii_track_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">vid_bbox_tracks</span><span class="p">])</span> 
        <span class="n">boxes_ii_track_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">vid_bbox_tracks</span><span class="p">])</span> <span class="c1"># the time of the last track. </span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer the next frame boxes from current boxes using optical flow.    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boxes_ii_track_pred</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">jjj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_ii_track</span><span class="p">)):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Predict using the flow the likely position of boxes. </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">new_tfs</span><span class="p">,</span> <span class="n">boxes_ii_pred</span> <span class="o">=</span> <span class="n">predict_new_boxes_flow_tf</span><span class="p">(</span><span class="n">boxes_ii_track</span><span class="p">[</span><span class="n">jjj</span><span class="p">][</span><span class="kc">None</span><span class="p">,:],</span> 
                                                               <span class="n">vid_flow</span><span class="p">[</span><span class="n">boxes_ii_track_time</span><span class="p">[</span><span class="n">jjj</span><span class="p">]])</span>
            <span class="c1"># clip  </span>
            <span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_ii_pred</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">boxes_ii_track_pred</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boxes_ii_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  
        <span class="n">boxes_ii_track_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boxes_ii_track_pred</span><span class="p">)</span>
            
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        load the next frame boxes. which are the candidates.  </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># bboxfile_jj = vid_bboxes[ii+1]</span>
        <span class="c1"># prob_jj, boxes_jj = load_bbox_frame_voc( vid[ii+1], </span>
                                                 <span class="c1"># bboxfile_jj)</span>
        <span class="n">boxes_jj</span> <span class="o">=</span> <span class="n">vid_bboxes</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
        <span class="c1"># set prob dependent on the size of the boxes. (if 5D then take the first as a measure of objectness else assume 1.)</span>
        <span class="k">if</span> <span class="n">boxes_jj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> 
            <span class="n">prob_jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prob_jj</span> <span class="o">=</span> <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">boxes_jj</span> <span class="o">=</span> <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">boxes_jj</span> <span class="o">=</span> <span class="n">boxes_jj</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">ds_factor</span><span class="p">)</span>

        <span class="c1"># clip</span>
        <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
        <span class="c1"># remove all boxes that are have an area 1 pixels or less.               </span>
        <span class="n">boxes_jj_w</span> <span class="o">=</span> <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">boxes_jj_h</span> <span class="o">=</span> <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes_jj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">boxes_jj</span> <span class="o">=</span> <span class="n">boxes_jj</span><span class="p">[</span><span class="n">boxes_jj_w</span><span class="o">*</span><span class="n">boxes_jj_h</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># suppress implausible. </span>
        <span class="k">if</span> <span class="n">remove_eccentric_bbox</span><span class="p">:</span>
          <span class="n">boxes_jj</span><span class="p">,</span> <span class="n">keep_ind_jj</span> <span class="o">=</span> <span class="n">remove_very_large_bbox</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">,</span> 
                                                      <span class="n">im_shape</span><span class="p">,</span> 
                                                      <span class="n">thresh</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                                                      <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1"># we don&#39;t expect it to be very long. </span>
                                                      <span class="n">method</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> 
                                                      <span class="n">max_density</span><span class="o">=</span><span class="n">max_dense_bbox_cover</span><span class="p">,</span> 
                                                      <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">return_ind</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">keep_ind_jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span>
              
        <span class="n">prob_jj</span> <span class="o">=</span> <span class="n">prob_jj</span><span class="p">[</span><span class="n">keep_ind_jj</span><span class="p">]</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        build the association matrix and match boxes based on iou. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iou_matrix</span> <span class="o">=</span> <span class="n">bbox_iou_corner_xy</span><span class="p">(</span><span class="n">boxes_ii_track_pred</span><span class="p">,</span> 
                                        <span class="n">boxes_jj</span><span class="p">);</span> 
        <span class="n">iou_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">iou_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># to make it a dissimilarity matrix. </span>
        
        <span class="c1"># solve the pairing problem.</span>
        <span class="n">ind_ii</span><span class="p">,</span> <span class="n">ind_jj</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">iou_matrix</span><span class="p">)</span>
        
        <span class="c1"># threshold as the matching is maximal. </span>
        <span class="n">iou_ii_jj</span> <span class="o">=</span> <span class="n">iou_matrix</span><span class="p">[</span><span class="n">ind_ii</span><span class="p">,</span> <span class="n">ind_jj</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">iou_ii_jj</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">iou_match</span><span class="p">)</span>
        <span class="c1"># keep = iou_ii_jj &lt;= dist_thresh</span>
        <span class="n">ind_ii</span> <span class="o">=</span> <span class="n">ind_ii</span><span class="p">[</span><span class="n">keep</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">];</span> 
        <span class="n">ind_jj</span> <span class="o">=</span> <span class="n">ind_jj</span><span class="p">[</span><span class="n">keep</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the trajectories. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># update first the matched.</span>
        <span class="k">for</span> <span class="n">match_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_ii</span><span class="p">)):</span>
            <span class="c1"># vid_cell_tracks[ind_ii[match_ii]].append([ii+1, ind_jj[match_ii]]) # i guess this is to keep track of actual cell ids that we segmented.</span>
            <span class="n">vid_bbox_tracks</span><span class="p">[</span><span class="n">ind_ii</span><span class="p">[</span><span class="n">match_ii</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">prob_jj</span><span class="p">[</span><span class="n">ind_jj</span><span class="p">[</span><span class="n">match_ii</span><span class="p">]],</span> <span class="n">boxes_jj</span><span class="p">[</span><span class="n">ind_jj</span><span class="p">[</span><span class="n">match_ii</span><span class="p">]]])</span> <span class="c1"># this is to keep track of the actual bbox we use, including inferred. </span>
            <span class="c1"># vid_cell_tracks_properties[ind_ii[match_ii]].append([ii+1, masks_jj_properties[ind_jj[match_ii]]]) # append the properties of the next time point. </span>
            <span class="n">vid_bbox_tracks_last_time</span><span class="p">[</span><span class="n">ind_ii</span><span class="p">[</span><span class="n">match_ii</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># let this be a record of the last time a &#39;real&#39; segmentation was matched, not one inferred from optical flow. </span>
            <span class="c1"># vid_mask_tracks_last[ind_ii[match_ii]] = masks_jj[...,ind_jj[match_ii]] # retain just the last masks thats relevant for us. </span>
            <span class="c1"># vid_mask_tracks_last[ind_ii[match_ii]] = boxes_jj[ind_jj[match_ii]]</span>
            <span class="n">vid_match_check_bbox_tracks</span><span class="p">[</span><span class="n">ind_ii</span><span class="p">[</span><span class="n">match_ii</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1"># success, append 0 </span>
            
        <span class="n">no_match_ind_ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_ii_track_pred</span><span class="p">)),</span> <span class="n">ind_ii</span><span class="p">)</span>
        <span class="n">no_match_ind_jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boxes_jj</span><span class="p">)),</span> <span class="n">ind_jj</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">idd</span> <span class="ow">in</span> <span class="n">no_match_ind_ii</span><span class="p">:</span>
            <span class="c1"># these tracks already exist so we just add to the existant tracks.         </span>
            <span class="c1"># vid_cell_tracks[idd].append([ii+1, -1]) # i guess this is to keep track of actual cell ids that we segmented.</span>
            <span class="n">vid_bbox_tracks</span><span class="p">[</span><span class="n">idd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">boxes_ii_track_prob</span><span class="p">[</span><span class="n">idd</span><span class="p">],</span> <span class="n">boxes_ii_track_pred</span><span class="p">[</span><span class="n">idd</span><span class="p">]])</span> <span class="c1"># this is to keep track of the actual bbox we use, including inferred. </span>
            <span class="c1"># vid_cell_tracks_properties[idd].append([ii+1, properties_ii_track_pred[idd]])</span>
            <span class="c1"># vid_bbox_tracks_last_time[idd] = ii+1 # let this be a record of the last time a &#39;real&#39; segmentation was matched, not one inferred from optical flow. </span>
            <span class="c1"># vid_mask_tracks_last[idd] = boxes_ii_track_pred[idd] # retain just the last masks thats relevant for us.</span>
            <span class="n">vid_match_check_bbox_tracks</span><span class="p">[</span><span class="n">idd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="c1"># no success, append 0  </span>
    
        <span class="k">for</span> <span class="n">idd</span> <span class="ow">in</span> <span class="n">no_match_ind_jj</span><span class="p">:</span>
            <span class="c1"># these tracks don&#39;t exsit yet so we need to create new tracks. </span>
            <span class="c1"># vid_cell_tracks.append([[ii+1, idd]]) # i guess this is to keep track of actual cell ids that we segmented.</span>
            <span class="n">vid_bbox_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">prob_jj</span><span class="p">[</span><span class="n">idd</span><span class="p">],</span> <span class="n">boxes_jj</span><span class="p">[</span><span class="n">idd</span><span class="p">]]])</span> <span class="c1"># this is to keep track of the actual bbox we use, including inferred. </span>
            <span class="c1"># vid_cell_tracks_properties.append([[ii+1, masks_jj_properties[idd]]])</span>
            <span class="n">vid_bbox_tracks_last_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># let this be a record of the last time a &#39;real&#39; segmentation was matched, not one inferred from optical flow. </span>
            <span class="c1"># vid_mask_tracks_last.append(masks_jj[...,idd]) # retain just the last masks thats relevant for us. </span>
            <span class="c1"># vid_mask_tracks_last.append(boxes_jj[idd])</span>
            <span class="n">vid_match_check_bbox_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
                
<span class="c1"># =============================================================================</span>
<span class="c1">#     Combine the tracks togther</span>
<span class="c1"># =============================================================================</span>
    <span class="n">vid_bbox_tracks_all</span> <span class="o">=</span> <span class="n">terminated_vid_bbox_tracks</span> <span class="o">+</span> <span class="n">vid_bbox_tracks</span> <span class="c1"># combine</span>
    <span class="n">vid_match_checks_all</span> <span class="o">=</span> <span class="n">terminated_check_match_bbox_tracks</span> <span class="o">+</span> <span class="n">vid_match_check_bbox_tracks</span>


<span class="c1"># =============================================================================</span>
<span class="c1">#     Compute some basic track properties for later filtering. </span>
<span class="c1"># =============================================================================    </span>
    <span class="n">vid_bbox_tracks_all_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">tra</span><span class="p">)</span> <span class="k">for</span> <span class="n">tra</span> <span class="ow">in</span> <span class="n">vid_bbox_tracks_all</span><span class="p">])</span>
    <span class="n">vid_bbox_tracks_all_start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">tra</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tra</span> <span class="ow">in</span> <span class="n">vid_bbox_tracks_all</span><span class="p">])</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="n">vid_bbox_tracks_all_lens</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">vid_bbox_tracks_all_start_time</span><span class="p">)</span>
    
    <span class="n">vid_bbox_tracks_lifetime_ratios</span> <span class="o">=</span> <span class="n">vid_bbox_tracks_all_lens</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vid_flow</span><span class="p">)</span> <span class="o">-</span> <span class="n">vid_bbox_tracks_all_start_time</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    
<span class="c1"># =============================================================================</span>
<span class="c1">#     Turn into a proper array of n_tracks x n_time x 4 or 5.... </span>
<span class="c1"># =============================================================================</span>
    <span class="n">vid_bbox_tracks_prob_all_array</span><span class="p">,</span> <span class="n">vid_bbox_tracks_all_array</span> <span class="o">=</span> <span class="n">bbox_tracks_2_array</span><span class="p">(</span><span class="n">vid_bbox_tracks_all</span><span class="p">,</span> <span class="n">nframes</span><span class="o">=</span><span class="n">nframes</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">boxes_ii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">vid_match_checks_all_array</span> <span class="o">=</span> <span class="n">bbox_scalar_2_array</span><span class="p">(</span><span class="n">vid_match_checks_all</span><span class="p">,</span> <span class="n">nframes</span><span class="o">=</span><span class="n">nframes</span><span class="p">)</span>

<span class="c1"># =============================================================================</span>
<span class="c1">#   Apply the given filtering parameters for visualization else it will be messy.        </span>
<span class="c1"># =============================================================================</span>

    <span class="k">if</span> <span class="n">to_viz</span><span class="p">:</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">vid_bbox_tracks_all_start_time</span><span class="p">,</span> 
                   <span class="n">vid_bbox_tracks_all_lens</span><span class="p">,</span> 
                   <span class="n">c</span><span class="o">=</span><span class="n">vid_bbox_tracks_lifetime_ratios</span><span class="p">,</span> 
                   <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                   <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


        <span class="c1"># keep filter</span>
        <span class="n">keep_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">vid_bbox_tracks_all_lens</span><span class="o">&gt;=</span><span class="n">min_tra_len_filter</span><span class="p">,</span> 
                                     <span class="n">vid_bbox_tracks_lifetime_ratios</span><span class="o">&gt;=</span><span class="n">min_tra_lifetime_ratio</span><span class="p">)</span>
        <span class="n">keep_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vid_bbox_tracks_all_lens</span><span class="p">))[</span><span class="n">keep_filter</span><span class="p">]</span>

        <span class="n">plot_vid_bbox_tracks_all</span> <span class="o">=</span> <span class="n">vid_bbox_tracks_all_array</span><span class="p">[</span><span class="n">keep_ids</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">plot_colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;hls&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_vid_bbox_tracks_all</span><span class="p">))</span>

        <span class="c1"># print(len(plot_vid_bbox_tracks_all), len(vid_bbox_tracks_all_array))</span>
        <span class="c1"># iterate over time. </span>
        <span class="k">for</span> <span class="n">frame_no</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nframes</span><span class="p">):</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Frame: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">frame_no</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">vid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vid_overlay</span> <span class="o">=</span> <span class="n">vid</span><span class="p">[</span><span class="n">frame_no</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vid_overlay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">im_shape</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">vid_overlay</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plot_vid_bbox_tracks_all</span><span class="p">))[:]:</span>
                <span class="n">bbox_tra_ii</span> <span class="o">=</span> <span class="n">plot_vid_bbox_tracks_all</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">frame_no</span><span class="p">]</span> <span class="c1"># fetch it at this point in time. </span>

                <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">bbox_tra_ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># then there is a valid bounding box. </span>
                    <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span> <span class="o">=</span> <span class="n">bbox_tra_ii</span> 
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x1</span><span class="p">],</span> 
                             <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">plot_colors</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">im_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">saveanalysisfolder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">saveanalysisfolder_movie_bbox</span><span class="p">,</span> <span class="s1">&#39;Frame-</span><span class="si">%s</span><span class="s1">.png&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">frame_no</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">))),</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        
    <span class="c1"># spio.savemat(savematfile, </span>
    <span class="c1">#                 {&#39;boundaries&#39;:organoid_boundaries, </span>
    <span class="c1">#                 &#39;initial_seg&#39;: seg0_grab,</span>
    <span class="c1">#                 &#39;motion_source_map&#39;: spixels_B_motion_sources,</span>
    <span class="c1">#                 &#39;seg_pts&#39;: organoid_segs_pts})</span>

    <span class="c1"># return organoid_boundaries, organoid_segs_pts</span>
    <span class="k">return</span> <span class="n">vid_bbox_tracks_prob_all_array</span><span class="p">,</span> <span class="n">vid_bbox_tracks_all</span><span class="p">,</span> <span class="n">vid_bbox_tracks_all_array</span><span class="p">,</span> <span class="n">vid_match_checks_all_array</span><span class="p">,</span> <span class="p">(</span><span class="n">vid_bbox_tracks_all_lens</span><span class="p">,</span> <span class="n">vid_bbox_tracks_all_start_time</span><span class="p">,</span> <span class="n">vid_bbox_tracks_lifetime_ratios</span><span class="p">)</span></div>


<div class="viewcode-block" id="tracks2Darray_to_3Darray"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.tracks2Darray_to_3Darray">[docs]</a><span class="k">def</span> <span class="nf">tracks2Darray_to_3Darray</span><span class="p">(</span><span class="n">tracks2D_time</span><span class="p">,</span> <span class="n">uv_params_time</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">..Unzipping</span> <span class="kn">import</span> <span class="n">unzip_new</span> <span class="k">as</span> <span class="n">uzip</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">uv_params_time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_tracks</span><span class="p">,</span> <span class="n">n_time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tracks2D_time</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tracks3D_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_tracks</span><span class="p">,</span> <span class="n">n_time</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">tracks3D_time</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 

    <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
        <span class="c1"># iterate over frame</span>
        <span class="n">uv_params</span> <span class="o">=</span> <span class="n">uv_params_time</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tracks2D_tt</span> <span class="o">=</span> <span class="n">tracks2D_time</span><span class="p">[:,</span><span class="n">tt</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># only interpolate for non nan vals. </span>
        <span class="n">val_track</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tracks2D_tt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">pts2D</span> <span class="o">=</span> <span class="n">tracks2D_tt</span><span class="p">[</span><span class="n">val_track</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pts2D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pts2D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this assumes x,y... </span>
        <span class="n">pts2D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pts2D</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># is this interpolation bad? </span>
        <span class="n">pts3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uzip</span><span class="o">.</span><span class="n">map_intensity_interp2</span><span class="p">(</span><span class="n">pts2D</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                                     <span class="n">grid_shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> 
                                                     <span class="n">I_ref</span><span class="o">=</span><span class="n">uv_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> 
                                                     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                                                     <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">uv_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tracks3D_time</span><span class="p">[</span><span class="n">val_track</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pts3D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">tracks3D_time</span></div>



<span class="c1"># =============================================================================</span>
<span class="c1">#   Add some track postprocessing support namely removal of all nan tracks and non-max suppression amongst tracks. (operating purely on bboxes!)</span>
<span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="calculate_iou_matrix_time"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.calculate_iou_matrix_time">[docs]</a><span class="k">def</span> <span class="nf">calculate_iou_matrix_time</span><span class="p">(</span><span class="n">box_arr1</span><span class="p">,</span> <span class="n">box_arr2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
        
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">x11</span> <span class="o">=</span> <span class="n">box_arr1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">y11</span> <span class="o">=</span> <span class="n">box_arr1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span> <span class="n">x12</span> <span class="o">=</span> <span class="n">box_arr1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span> <span class="n">y12</span> <span class="o">=</span> <span class="n">box_arr1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">x21</span> <span class="o">=</span> <span class="n">box_arr2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> <span class="n">y21</span> <span class="o">=</span> <span class="n">box_arr2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span> <span class="n">x22</span> <span class="o">=</span> <span class="n">box_arr2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span> <span class="n">y22</span> <span class="o">=</span> <span class="n">box_arr2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">x11</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># # n_tracks x n_time. </span>
    <span class="c1"># flip this.</span>
    <span class="n">x11</span> <span class="o">=</span> <span class="n">x11</span><span class="o">.</span><span class="n">T</span><span class="p">;</span> <span class="n">y11</span> <span class="o">=</span> <span class="n">y11</span><span class="o">.</span><span class="n">T</span><span class="p">;</span> <span class="n">x12</span> <span class="o">=</span> <span class="n">x12</span><span class="o">.</span><span class="n">T</span><span class="p">;</span> <span class="n">y12</span> <span class="o">=</span> <span class="n">y12</span><span class="o">.</span><span class="n">T</span>
    <span class="n">x21</span> <span class="o">=</span> <span class="n">x21</span><span class="o">.</span><span class="n">T</span><span class="p">;</span> <span class="n">y21</span> <span class="o">=</span> <span class="n">y21</span><span class="o">.</span><span class="n">T</span><span class="p">;</span> <span class="n">x22</span> <span class="o">=</span> <span class="n">x22</span><span class="o">.</span><span class="n">T</span><span class="p">;</span> <span class="n">y22</span> <span class="o">=</span> <span class="n">y22</span><span class="o">.</span><span class="n">T</span> 

    <span class="n">xA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x11</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x21</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span>
    <span class="n">yA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y11</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">y21</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span>
    <span class="n">xB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x12</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">x22</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span>
    <span class="n">yB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y12</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">y22</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span>
    
    <span class="n">interArea</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="n">xB</span> <span class="o">-</span> <span class="n">xA</span> <span class="o">+</span> <span class="n">eps</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="n">yB</span> <span class="o">-</span> <span class="n">yA</span> <span class="o">+</span> <span class="n">eps</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">boxAArea</span> <span class="o">=</span> <span class="p">(</span><span class="n">x12</span> <span class="o">-</span> <span class="n">x11</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y12</span> <span class="o">-</span> <span class="n">y11</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">boxBArea</span> <span class="o">=</span> <span class="p">(</span><span class="n">x22</span> <span class="o">-</span> <span class="n">x21</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y22</span> <span class="o">-</span> <span class="n">y21</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>

    <span class="c1"># iou = interArea / (boxAArea + np.transpose(boxBArea) - interArea)</span>
    <span class="n">iou</span> <span class="o">=</span> <span class="n">interArea</span> <span class="o">/</span> <span class="p">(</span><span class="n">boxAArea</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxBArea</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">interArea</span><span class="p">)</span>
    <span class="c1"># # iou = iou.reshape((m,n))</span>
    <span class="k">return</span> <span class="n">iou</span></div>

<span class="c1"># replace with iou bbox_tracks</span>
<div class="viewcode-block" id="iou_boundary_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.iou_boundary_tracks">[docs]</a><span class="k">def</span> <span class="nf">iou_boundary_tracks</span><span class="p">(</span><span class="n">tra_1</span><span class="p">,</span> <span class="n">tra_2</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">n_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tra_1</span><span class="p">)</span> 
    <span class="n">iou_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pts</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pts</span><span class="p">):</span>
        <span class="n">tra_1_ii</span> <span class="o">=</span> <span class="n">tra_1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">tra_2_ii</span> <span class="o">=</span> <span class="n">tra_2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_1_ii</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_2_ii</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">iou_time</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tra_1_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tra_1_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tra_1_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tra_1_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="n">x1_</span><span class="p">,</span> <span class="n">x2_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tra_2_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tra_2_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y1_</span><span class="p">,</span> <span class="n">y2_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tra_2_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tra_2_ii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="n">bbox1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span>
            <span class="n">bbox2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1_</span><span class="p">,</span><span class="n">y1_</span><span class="p">,</span><span class="n">x2_</span><span class="p">,</span><span class="n">y2_</span><span class="p">])</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">)</span>
            <span class="n">iou_12</span> <span class="o">=</span> <span class="n">get_iou</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">)</span>
            <span class="n">iou_time</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">iou_12</span>

    <span class="k">return</span> <span class="n">iou_time</span></div>

<div class="viewcode-block" id="get_iou"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.get_iou">[docs]</a><span class="k">def</span> <span class="nf">get_iou</span><span class="p">(</span><span class="n">bb1</span><span class="p">,</span> <span class="n">bb2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the Intersection over Union (IoU) of two bounding boxes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bb1 : dict</span>
<span class="sd">        Keys: {&#39;x1&#39;, &#39;x2&#39;, &#39;y1&#39;, &#39;y2&#39;}</span>
<span class="sd">        The (x1, y1) position is at the top left corner,</span>
<span class="sd">        the (x2, y2) position is at the bottom right corner</span>
<span class="sd">    bb2 : dict</span>
<span class="sd">        Keys: {&#39;x1&#39;, &#39;x2&#39;, &#39;y1&#39;, &#39;y2&#39;}</span>
<span class="sd">        The (x, y) position is at the top left corner,</span>
<span class="sd">        the (x2, y2) position is at the bottom right corner</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        in [0, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bb1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bb2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">iou</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bb1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x1&#39;</span><span class="p">:</span> <span class="n">bb1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
               <span class="s1">&#39;y1&#39;</span><span class="p">:</span> <span class="n">bb1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
               <span class="s1">&#39;x2&#39;</span><span class="p">:</span> <span class="n">bb1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
               <span class="s1">&#39;y2&#39;</span><span class="p">:</span> <span class="n">bb1</span><span class="p">[</span><span class="mi">3</span><span class="p">]}</span>
        <span class="n">bb2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x1&#39;</span><span class="p">:</span> <span class="n">bb2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
               <span class="s1">&#39;y1&#39;</span><span class="p">:</span> <span class="n">bb2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
               <span class="s1">&#39;x2&#39;</span><span class="p">:</span> <span class="n">bb2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
               <span class="s1">&#39;y2&#39;</span><span class="p">:</span> <span class="n">bb2</span><span class="p">[</span><span class="mi">3</span><span class="p">]}</span>
        
    <span class="c1">#    print(bb1)</span>
    <span class="c1">#    print(bb2)</span>
    <span class="c1">#     test for 0</span>
            
        <span class="c1"># allow for collapsed boxes.           </span>
        <span class="k">assert</span> <span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">]</span>
    
        <span class="c1"># determine the coordinates of the intersection rectangle</span>
        <span class="n">x_left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">],</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">])</span>
        <span class="n">y_top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">],</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">])</span>
        <span class="n">x_right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">],</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">])</span>
        <span class="n">y_bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">],</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">])</span>
    
        <span class="k">if</span> <span class="n">x_right</span> <span class="o">&lt;</span> <span class="n">x_left</span> <span class="ow">or</span> <span class="n">y_bottom</span> <span class="o">&lt;</span> <span class="n">y_top</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
    
        <span class="c1"># The intersection of two axis-aligned bounding boxes is always an</span>
        <span class="c1"># axis-aligned bounding box</span>
        <span class="n">intersection_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_right</span> <span class="o">-</span> <span class="n">x_left</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_bottom</span> <span class="o">-</span> <span class="n">y_top</span><span class="p">)</span>
    
        <span class="c1"># compute the area of both AABBs</span>
        <span class="n">bb1_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb1</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">])</span>
        <span class="n">bb2_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;x2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;y2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">bb2</span><span class="p">[</span><span class="s1">&#39;y1&#39;</span><span class="p">])</span>
    
        <span class="c1"># compute the intersection over union by taking the intersection</span>
        <span class="c1"># area and dividing it by the sum of prediction + ground-truth</span>
        <span class="c1"># areas - the interesection area</span>
        <span class="n">iou</span> <span class="o">=</span> <span class="n">intersection_area</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">bb1_area</span> <span class="o">+</span> <span class="n">bb2_area</span> <span class="o">-</span> <span class="n">intersection_area</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">iou</span> <span class="o">&gt;=</span> <span class="mf">0.0</span>
        <span class="k">assert</span> <span class="n">iou</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">iou</span></div>

<div class="viewcode-block" id="iou_bbox_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.iou_bbox_tracks">[docs]</a><span class="k">def</span> <span class="nf">iou_bbox_tracks</span><span class="p">(</span><span class="n">tra_1</span><span class="p">,</span> <span class="n">tra_2</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">n_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tra_1</span><span class="p">)</span> 
    <span class="n">iou_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pts</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pts</span><span class="p">):</span>
        <span class="n">tra_1_ii</span> <span class="o">=</span> <span class="n">tra_1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="c1"># get the track at a particular timepoint should be 4</span>
        <span class="n">tra_2_ii</span> <span class="o">=</span> <span class="n">tra_2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_1_ii</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_2_ii</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">iou_time</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># prop the nan onwards. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">tra_1_ii</span>
            <span class="n">x1_</span><span class="p">,</span> <span class="n">y1_</span><span class="p">,</span> <span class="n">x2_</span><span class="p">,</span> <span class="n">y2_</span> <span class="o">=</span> <span class="n">tra_2_ii</span>
            <span class="c1"># x1, x2 = np.min(tra_1_ii[...,1]), np.max(tra_1_ii[...,1])</span>
            <span class="c1"># y1, y2 = np.min(tra_1_ii[...,0]), np.max(tra_1_ii[...,0])</span>
            
            <span class="c1"># x1_, x2_ = np.min(tra_2_ii[...,1]), np.max(tra_2_ii[...,1])</span>
            <span class="c1"># y1_, y2_ = np.min(tra_2_ii[...,0]), np.max(tra_2_ii[...,0])</span>
            <span class="n">bbox1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span>
            <span class="n">bbox2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1_</span><span class="p">,</span><span class="n">y1_</span><span class="p">,</span><span class="n">x2_</span><span class="p">,</span><span class="n">y2_</span><span class="p">])</span>
            
            <span class="c1"># print(bbox1, bbox2)</span>
            <span class="n">iou_12</span> <span class="o">=</span> <span class="n">get_iou</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">)</span>
            <span class="n">iou_time</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">iou_12</span>

    <span class="k">return</span> <span class="n">iou_time</span></div>


<div class="viewcode-block" id="pairwise_iou_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.pairwise_iou_tracks">[docs]</a><span class="k">def</span> <span class="nf">pairwise_iou_tracks</span><span class="p">(</span><span class="n">boundaries_list</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">itertools</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">boundaries_list</span><span class="p">])</span> <span class="c1"># this is for dissecting IDs.</span>
    
    <span class="n">ind_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="nb">str</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="p">[</span><span class="n">ii</span><span class="p">])]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ns</span><span class="p">))])</span>
    <span class="c1"># stack all of them together. </span>
    <span class="n">all_boundaries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">boundaries_list</span><span class="p">)</span>
    
    <span class="c1"># print(all_boundaries.shape)</span>
    <span class="n">sim_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">all_boundaries</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_boundaries</span><span class="p">)))</span>
    <span class="n">shared_time_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">all_boundaries</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_boundaries</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_boundaries</span><span class="p">)),</span><span class="mi">2</span><span class="p">):</span>
        
        <span class="n">boundary_i</span> <span class="o">=</span> <span class="n">all_boundaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">boundary_j</span> <span class="o">=</span> <span class="n">all_boundaries</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        
        <span class="c1"># iou_track = iou_boundary_tracks(boundary_i, boundary_j)</span>
        <span class="n">iou_track</span> <span class="o">=</span> <span class="n">iou_bbox_tracks</span><span class="p">(</span><span class="n">boundary_i</span><span class="p">,</span> <span class="n">boundary_j</span><span class="p">)</span>
        
        <span class="n">sim_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">iou_track</span><span class="p">)</span>
        <span class="n">sim_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">iou_track</span><span class="p">)</span>
        
        <span class="n">shared_time_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">iou_track</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">shared_time_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">iou_track</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="pairwise_iou_tracks_fast"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.pairwise_iou_tracks_fast">[docs]</a><span class="k">def</span> <span class="nf">pairwise_iou_tracks_fast</span><span class="p">(</span><span class="n">boundaries_list</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">return_bbox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">avg_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">):</span>
        
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">time</span> 
    
    <span class="n">Ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">boundaries_list</span><span class="p">])</span> <span class="c1"># this is for dissecting IDs.</span>
    
    <span class="n">ind_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="nb">str</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ns</span><span class="p">[</span><span class="n">ii</span><span class="p">])]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ns</span><span class="p">))])</span>
    <span class="c1"># stack all of them together. </span>
    <span class="n">all_boundaries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">boundaries_list</span><span class="p">)</span> <span class="c1"># flatten all. </span>
    
    <span class="c1"># # turn the boundaries into bbox. </span>
    <span class="c1"># all_boundaries_bbox_xmin = np.min(all_boundaries[...,0], axis=-1)</span>
    <span class="c1"># all_boundaries_bbox_xmax = np.max(all_boundaries[...,2], axis=-1)</span>
    <span class="c1"># all_boundaries_bbox_ymin = np.min(all_boundaries[...,1], axis=-1)</span>
    <span class="c1"># all_boundaries_bbox_ymax = np.max(all_boundaries[...,3], axis=-1)</span>
    
    <span class="c1"># all_boundaries_bbox = np.concatenate([all_boundaries_bbox_xmin[...,None], </span>
    <span class="c1">#                                       all_boundaries_bbox_ymin[...,None], </span>
    <span class="c1">#                                       all_boundaries_bbox_xmax[...,None], </span>
    <span class="c1">#                                       all_boundaries_bbox_ymax[...,None]], axis=-1)</span>
    <span class="n">all_boundaries_bbox</span> <span class="o">=</span> <span class="n">all_boundaries</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">all_sim_matrix</span> <span class="o">=</span> <span class="n">calculate_iou_matrix_time</span><span class="p">(</span><span class="n">all_boundaries_bbox</span><span class="p">,</span> 
                                                <span class="n">all_boundaries_bbox</span><span class="p">,</span> 
                                            <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
    
    <span class="n">sim_matrix</span> <span class="o">=</span> <span class="n">avg_func</span><span class="p">(</span><span class="n">all_sim_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">shared_time_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">all_sim_matrix</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
     
    <span class="k">if</span> <span class="n">return_bbox</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">),</span> <span class="p">(</span><span class="n">all_boundaries_bbox</span><span class="p">,</span> <span class="n">sim_matrix</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="unique_pts"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.unique_pts">[docs]</a><span class="k">def</span> <span class="nf">unique_pts</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="c1"># returns the unique rows of an array. </span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">list</span><span class="p">({</span><span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">a</span><span class="p">}))</span></div>

<div class="viewcode-block" id="get_id_cliques"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.get_id_cliques">[docs]</a><span class="k">def</span> <span class="nf">get_id_cliques</span><span class="p">(</span><span class="n">id_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    given a list of identities, merges the common ids into a cluster/clique</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_list</span><span class="p">)</span>
    <span class="n">cliques</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        
        <span class="n">id_list_ii</span> <span class="o">=</span> <span class="n">id_list</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        
        <span class="n">add_clique</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">cc_i</span><span class="p">,</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cliques</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">id_list_ii</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cliques</span><span class="p">[</span><span class="n">cc_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cc</span><span class="p">,</span> <span class="n">id_list_ii</span><span class="p">]))</span>
                <span class="n">add_clique</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
            
        <span class="k">if</span> <span class="n">add_clique</span><span class="p">:</span>
            <span class="n">cliques</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_list_ii</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">cliques</span></div>

<span class="c1"># of the two versions, this is more useful because it ensures more temporal continuity.</span>
<div class="viewcode-block" id="objectness_score_tracks_time"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.objectness_score_tracks_time">[docs]</a><span class="k">def</span> <span class="nf">objectness_score_tracks_time</span><span class="p">(</span><span class="n">track</span><span class="p">,</span> <span class="n">vid_score</span><span class="p">,</span> <span class="n">mean_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">):</span> 
    
    <span class="c1"># give an image and a timepoint which the image corresponds to, to get the objectness score. default uses the first timepoint of the video.  </span>
    <span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">polygon</span> 
    
    <span class="n">img_shape</span> <span class="o">=</span> <span class="n">vid_score</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nframes</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span> <span class="o">=</span> <span class="n">coords</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y2</span><span class="p">],</span>
                                <span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x1</span><span class="p">]])</span>
            <span class="n">rr</span><span class="p">,</span><span class="n">cc</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="n">img_shape</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">mean_func</span><span class="p">(</span><span class="n">vid_score</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="n">rr</span><span class="p">,</span><span class="n">cc</span><span class="p">])</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">score</span></div>


<div class="viewcode-block" id="track_iou_time"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.track_iou_time">[docs]</a><span class="k">def</span> <span class="nf">track_iou_time</span><span class="p">(</span><span class="n">track</span><span class="p">,</span> <span class="n">use_bbox</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    frame to frame iou score </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nframes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="p">)</span>
    <span class="n">first_diff_iou</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">frame_no</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nframes</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="n">tra_1</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">frame_no</span><span class="p">]</span>
        <span class="n">tra_2</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">frame_no</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">first_diff_iou</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">use_bbox</span><span class="p">:</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">tra_1</span>
                <span class="n">x1_</span><span class="p">,</span> <span class="n">y1_</span><span class="p">,</span> <span class="n">x2_</span><span class="p">,</span> <span class="n">y2_</span> <span class="o">=</span> <span class="n">tra_2</span>
                <span class="c1"># x1, x2 = np.min(tra_1[...,1]), np.max(tra_1[...,1])</span>
                <span class="c1"># y1, y2 = np.min(tra_1[...,0]), np.max(tra_1[...,0])</span>
                
                <span class="c1"># x1_, x2_ = np.min(tra_2[...,1]), np.max(tra_2[...,1])</span>
                <span class="c1"># y1_, y2_ = np.min(tra_2[...,0]), np.max(tra_2[...,0])</span>
                <span class="n">bbox1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span>
                <span class="n">bbox2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x1_</span><span class="p">,</span><span class="n">y1_</span><span class="p">,</span><span class="n">x2_</span><span class="p">,</span><span class="n">y2_</span><span class="p">])</span>
                
                <span class="c1"># print(bbox1, bbox2)</span>
                <span class="n">iou_12</span> <span class="o">=</span> <span class="n">get_iou</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">)</span>
                <span class="n">first_diff_iou</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iou_12</span><span class="p">)</span>
    
    <span class="n">first_diff_iou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">first_diff_iou</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">first_diff_iou</span></div>


<span class="c1"># the following bypasses the need for point alignment along the tracks? by using area. </span>
<div class="viewcode-block" id="smoothness_score_tracks_iou"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.smoothness_score_tracks_iou">[docs]</a><span class="k">def</span> <span class="nf">smoothness_score_tracks_iou</span><span class="p">(</span><span class="n">track</span><span class="p">,</span> <span class="n">mean_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span> <span class="n">second_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_bbox</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
    
    <span class="c1"># get the second order track differences</span>
    <span class="c1"># from skimage.draw import polygon </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
        
    <span class="n">first_diff_iou</span> <span class="o">=</span> <span class="n">track_iou_time</span><span class="p">(</span><span class="n">track</span><span class="p">,</span> <span class="n">use_bbox</span><span class="o">=</span><span class="n">use_bbox</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">second_order</span><span class="p">:</span>
        <span class="n">second_diff_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">first_diff_iou</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">second_diff_norm</span> <span class="o">=</span> <span class="n">first_diff_iou</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># second_diff_norm = np.nanmean(second_diff_norm, axis=1) # obtain the mean over the boundaries., should we use median?</span>

    <span class="k">if</span> <span class="n">second_order</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="o">-</span><span class="n">mean_func</span><span class="p">(</span><span class="n">second_diff_norm</span><span class="p">)</span> <span class="c1"># this should be maxed for iou.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">mean_func</span><span class="p">(</span><span class="n">second_diff_norm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">score</span></div>

<div class="viewcode-block" id="nan_stability_score_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.nan_stability_score_tracks">[docs]</a><span class="k">def</span> <span class="nf">nan_stability_score_tracks</span><span class="p">(</span><span class="n">track</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    simply the fraction of frames for which we were able to successfully track the object. </span>
<span class="sd">    &quot;&quot;&quot;</span>     
    <span class="n">len_track</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">track</span><span class="p">))</span>
    <span class="n">valid_track_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">track</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">score</span> <span class="o">=</span> <span class="n">valid_track_times</span> <span class="o">/</span> <span class="n">len_track</span> 
    
    <span class="k">return</span> <span class="n">score</span></div>


<div class="viewcode-block" id="non_stable_track_suppression_filter"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.non_stable_track_suppression_filter">[docs]</a><span class="k">def</span> <span class="nf">non_stable_track_suppression_filter</span><span class="p">(</span><span class="n">obj_vid</span><span class="p">,</span> 
                                        <span class="n">org_tracks_list</span><span class="p">,</span> <span class="c1"># use the bbox directly.  </span>
                                        <span class="n">track_overlap_thresh</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> 
                                        <span class="n">weight_nan</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">weight_smooth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_obj_frames</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                        <span class="n">obj_mean_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
                                        <span class="n">smoothness_mean_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
                                        <span class="n">fast_comp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">debug_viz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines the utility codes above to filter the raw organoid boundary tracks. extends to single and multiple channels.  </span>
<span class="sd">        need to absolutely change this... </span>

<span class="sd">        obj_vid: the metric to score objectness .... </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    
    <span class="c1"># 1. apply iou calculations pairwise between tracks to score overlap across channels</span>
    <span class="k">if</span> <span class="n">fast_comp</span><span class="p">:</span>
        <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">)</span> <span class="o">=</span> <span class="n">pairwise_iou_tracks_fast</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)</span>
        <span class="c1"># detrend the diagonals.(which is self connections)</span>
        <span class="n">sim_matrix</span> <span class="o">=</span> <span class="n">sim_matrix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sim_matrix</span><span class="p">))</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">)</span> <span class="o">=</span> <span class="n">pairwise_iou_tracks</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)</span> <span class="c1"># this concatenates all the tracks etc together, resolving all inter-, intra- overlaps</span>

    <span class="n">sim_matrix_</span> <span class="o">=</span> <span class="n">sim_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sim_matrix_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># replace any nan values which will not be useful. </span>

    <span class="c1"># 2. detect overlaps and cliques (clusters of tracks that correspond to one dominant organoid)</span>
    <span class="n">tracks_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_matrix_</span> <span class="o">&gt;=</span> <span class="n">track_overlap_thresh</span><span class="p">)</span>

<span class="c1">#    print(tracks_overlap)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tracks_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># 2b. if there is any evidence of overlap! we collect this all together.  </span>
        <span class="n">overlap_positive_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">tracks_overlap</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">overlap_positive_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">overlap_positive_inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#        print(overlap_positive_inds)</span>
        <span class="c1"># overlap_positive_inds = np.unique(overlap_positive_inds, axis=0) #remove duplicate rows.</span>
        <span class="n">overlap_positive_inds</span> <span class="o">=</span> <span class="n">unique_pts</span><span class="p">(</span><span class="n">overlap_positive_inds</span><span class="p">)</span>
        
        <span class="c1"># merge these indices to identify unique cliques ... -&gt; as those will likely be trying to track the same organoid. </span>
        <span class="n">cliq_ids</span> <span class="o">=</span> <span class="n">get_id_cliques</span><span class="p">(</span><span class="n">overlap_positive_inds</span><span class="p">)</span> 
  
        <span class="c1"># 3. clique resolution -&gt; determining which organoid is actually being tracked, and which track offers best tracking performance on average from all candidates in the clique. </span>
        <span class="n">assigned_cliq_track_ids</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># stores which of the tracks we should use from the overlapped channels.</span>
    
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">cliq_ids</span><span class="p">[:]:</span>

            <span class="c1"># iterate, use objectness score provided by the input vid, to figure out which organoid is being tracked. </span>
            <span class="n">ind_ids_cc</span> <span class="o">=</span> <span class="n">ind_ids</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="c1"># what are the possible ids here. </span>

            <span class="n">obj_score_cc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tra_stable_scores_cc</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># in the order of organoid id and channel. </span>
            <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

                <span class="n">ch_colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;Set1&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">))</span>

                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">obj_vid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># just visualise the first frame is enough.</span>
            
            <span class="k">for</span> <span class="n">ind_ids_ccc</span> <span class="ow">in</span> <span class="n">ind_ids_cc</span><span class="p">:</span>
                <span class="n">org_id</span><span class="p">,</span> <span class="n">org_ch</span> <span class="o">=</span> <span class="n">ind_ids_ccc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                <span class="n">org_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">org_id</span><span class="p">)</span>
                <span class="n">org_ch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">org_ch</span><span class="p">)</span>
                
                <span class="n">boundary_org</span> <span class="o">=</span> <span class="n">org_tracks_list</span><span class="p">[</span><span class="n">org_ch</span><span class="p">][</span><span class="n">org_id</span><span class="p">]</span>

                <span class="c1"># this is the problem? </span>
                <span class="c1"># objectness score for deciding the dominant organoid. </span>
                <span class="n">obj_score</span> <span class="o">=</span> <span class="n">objectness_score_tracks_time</span><span class="p">(</span><span class="n">boundary_org</span><span class="p">[:</span><span class="n">max_obj_frames</span><span class="p">],</span> 
                                                          <span class="n">obj_vid</span><span class="p">[:</span><span class="n">max_obj_frames</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">org_ch</span><span class="p">],</span> 
                                                              <span class="n">mean_func</span><span class="o">=</span><span class="n">obj_mean_func</span><span class="p">)</span>
                <span class="n">obj_score_cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_score</span><span class="p">)</span>
                
                <span class="c1"># stability score which is weighted on 2 factors. to determine which track. </span>
                <span class="n">nan_score</span> <span class="o">=</span> <span class="n">nan_stability_score_tracks</span><span class="p">(</span><span class="n">boundary_org</span><span class="p">)</span>
                
                <span class="c1"># this should be a minimisation ..... ! </span>
                <span class="c1"># smooth_score = smoothness_score_tracks(boundary_org, </span>
                <span class="c1">#                                       mean_func=np.nanmean)</span>
                <span class="n">smooth_score</span> <span class="o">=</span> <span class="n">smoothness_score_tracks_iou</span><span class="p">(</span><span class="n">boundary_org</span><span class="p">,</span> 
                                                           <span class="n">mean_func</span><span class="o">=</span><span class="n">smoothness_mean_func</span><span class="p">)</span>
                
                <span class="n">tra_stable_scores_cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight_nan</span><span class="o">*</span><span class="n">nan_score</span><span class="o">+</span><span class="n">weight_smooth</span><span class="o">*</span><span class="n">smooth_score</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span> <span class="s1">&#39;org: </span><span class="si">%s</span><span class="s1">, stable: </span><span class="si">%s</span><span class="s1">&#39;</span>  <span class="o">%</span><span class="p">(</span><span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)],</span> 
                                                <span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">tra_stable_scores_cc</span><span class="p">)]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
            <span class="c1"># stack all the scores.     </span>
            <span class="n">obj_score_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)</span>
            <span class="n">tra_stable_scores_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">tra_stable_scores_cc</span><span class="p">)</span>

            <span class="c1"># decide on the organoid and track (argmax)</span>
            <span class="n">cliq_org_id_keep</span> <span class="o">=</span> <span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)]</span>
            <span class="n">cliq_track_id_keep</span> <span class="o">=</span> <span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">tra_stable_scores_cc</span><span class="p">)]</span>
            
            <span class="c1"># save this out for processing. </span>
            <span class="n">assigned_cliq_track_ids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cliq_org_id_keep</span><span class="p">,</span> <span class="n">cliq_track_id_keep</span><span class="p">])</span>

        <span class="c1"># 4. new org_tracks_list production based on the filtered information. </span>
        <span class="n">org_tracks_list_out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">list_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)):</span>

            <span class="n">org_tracks_list_ii</span> <span class="o">=</span> <span class="n">org_tracks_list</span><span class="p">[</span><span class="n">list_ii</span><span class="p">]</span>
            <span class="n">org_tracks_list_ii_out</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">org_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list_ii</span><span class="p">)):</span>
                <span class="n">tra_int_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">org_ii</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">list_ii</span><span class="p">)</span> <span class="c1"># create the string id lookup. </span>
                
                <span class="n">include_track</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">for</span> <span class="n">cliq_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cliq_ids</span><span class="p">)):</span>
                    <span class="n">ind_ids_cc</span> <span class="o">=</span> <span class="n">ind_ids</span><span class="p">[</span><span class="n">cliq_ids</span><span class="p">[</span><span class="n">cliq_ii</span><span class="p">]]</span> <span class="c1"># gets the clique members in string form -&gt; is this organoid part of a clique. </span>
                    
                    <span class="k">if</span> <span class="n">tra_int_id</span> <span class="ow">in</span> <span class="n">ind_ids_cc</span><span class="p">:</span>
                        <span class="n">include_track</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># do not automatically include.  </span>

                        <span class="c1"># test is this the dominant organoid in the clique. </span>
                        <span class="n">cliq_organoid_assign</span><span class="p">,</span> <span class="n">cliq_organoid_assign_track</span> <span class="o">=</span> <span class="n">assigned_cliq_track_ids</span><span class="p">[</span><span class="n">cliq_ii</span><span class="p">]</span> <span class="c1"># get the assignment information of the clique. </span>
                        
                        <span class="k">if</span> <span class="n">tra_int_id</span> <span class="o">==</span> <span class="n">cliq_organoid_assign</span><span class="p">:</span>
                            <span class="c1"># if this is the dominant organoid then we add the designated track. </span>
                            <span class="n">org_id_tra_assign</span><span class="p">,</span> <span class="n">org_ch_tra_assign</span> <span class="o">=</span> <span class="n">cliq_organoid_assign_track</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                            <span class="n">org_id_tra_assign</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">org_id_tra_assign</span><span class="p">);</span> <span class="n">org_ch_tra_assign</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">org_ch_tra_assign</span><span class="p">)</span>
                            
                            <span class="n">org_tracks_list_ii_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">[</span><span class="n">org_ch_tra_assign</span><span class="p">][</span><span class="n">org_id_tra_assign</span><span class="p">])</span>

                        <span class="c1"># do nothing otherwise -&gt; exclude this organoid basically. </span>
                
                <span class="k">if</span> <span class="n">include_track</span><span class="p">:</span> 
                    <span class="c1"># directly include. </span>
                    <span class="n">org_tracks_list_ii_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_tracks_list_ii</span><span class="p">[</span><span class="n">org_ii</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list_ii_out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># stack the tracks. </span>
                <span class="n">org_tracks_list_ii_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">org_tracks_list_ii_out</span><span class="p">)</span>
            
            <span class="n">org_tracks_list_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_tracks_list_ii_out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">org_tracks_list_out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)</span>

    <span class="c1"># cleaned tracks, in the same input format as a list of numpy tracks for each channel. </span>
    <span class="k">return</span> <span class="n">org_tracks_list_out</span></div>

<div class="viewcode-block" id="non_maxlen_track_suppression_filter"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.non_maxlen_track_suppression_filter">[docs]</a><span class="k">def</span> <span class="nf">non_maxlen_track_suppression_filter</span><span class="p">(</span><span class="n">obj_vid</span><span class="p">,</span> 
                                        <span class="n">org_tracks_list</span><span class="p">,</span> <span class="c1"># use the bbox directly.  </span>
                                        <span class="n">track_overlap_thresh</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> 
                                        <span class="n">max_obj_frames</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                        <span class="n">obj_mean_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
                                        <span class="n">fast_comp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">debug_viz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines the utility codes above to filter the raw organoid boundary tracks. extends to single and multiple channels.  </span>
<span class="sd">        need to absolutely change this... </span>

<span class="sd">        obj_vid: the metric to score objectness .... </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    
    <span class="c1"># 1. apply iou calculations pairwise between tracks to score overlap across channels - we only suppress. those that share a lot of overlap. </span>
    <span class="k">if</span> <span class="n">fast_comp</span><span class="p">:</span>
        <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">)</span> <span class="o">=</span> <span class="n">pairwise_iou_tracks_fast</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)</span>
        <span class="c1"># detrend the diagonals.(which is self connections)</span>
        <span class="n">sim_matrix</span> <span class="o">=</span> <span class="n">sim_matrix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sim_matrix</span><span class="p">))</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ind_ids</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_matrix</span><span class="p">,</span> <span class="n">shared_time_matrix</span><span class="p">)</span> <span class="o">=</span> <span class="n">pairwise_iou_tracks</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)</span> <span class="c1"># this concatenates all the tracks etc together, resolving all inter-, intra- overlaps</span>

    <span class="n">sim_matrix_</span> <span class="o">=</span> <span class="n">sim_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sim_matrix_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># replace any nan values which will not be useful. </span>

    <span class="c1"># 2. detect overlaps and cliques (clusters of tracks that correspond to one dominant organoid)</span>
    <span class="n">tracks_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_matrix_</span> <span class="o">&gt;=</span> <span class="n">track_overlap_thresh</span><span class="p">)</span>

<span class="c1">#    print(tracks_overlap)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tracks_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># 2b. if there is any evidence of overlap! we collect this all together.  </span>
        <span class="n">overlap_positive_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">tracks_overlap</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">overlap_positive_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">overlap_positive_inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#        print(overlap_positive_inds)</span>
        <span class="c1"># overlap_positive_inds = np.unique(overlap_positive_inds, axis=0) #remove duplicate rows.</span>
        <span class="n">overlap_positive_inds</span> <span class="o">=</span> <span class="n">unique_pts</span><span class="p">(</span><span class="n">overlap_positive_inds</span><span class="p">)</span>
        
        <span class="c1"># merge these indices to identify unique cliques ... -&gt; as those will likely be trying to track the same organoid. </span>
        <span class="n">cliq_ids</span> <span class="o">=</span> <span class="n">get_id_cliques</span><span class="p">(</span><span class="n">overlap_positive_inds</span><span class="p">)</span> 
  
        <span class="c1"># 3. clique resolution -&gt; determining which organoid is actually being tracked, and which track offers best tracking performance on average from all candidates in the clique. </span>
        <span class="n">assigned_cliq_track_ids</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># stores which of the tracks we should use from the overlapped channels.</span>
    
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">cliq_ids</span><span class="p">[:]:</span>

            <span class="c1"># iterate, use objectness score provided by the input vid, to figure out which organoid is being tracked. </span>
            <span class="n">ind_ids_cc</span> <span class="o">=</span> <span class="n">ind_ids</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="c1"># what are the possible ids here. </span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ind_ids_cc</span><span class="p">)</span>

            <span class="n">obj_score_cc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tra_stable_scores_cc</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># in the order of organoid id and channel. </span>
            <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

                <span class="n">ch_colors</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s1">&#39;Set1&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">))</span>

                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">obj_vid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># just visualise the first frame is enough.</span>
            
            <span class="k">for</span> <span class="n">ind_ids_ccc</span> <span class="ow">in</span> <span class="n">ind_ids_cc</span><span class="p">:</span>
                <span class="n">org_id</span><span class="p">,</span> <span class="n">org_ch</span> <span class="o">=</span> <span class="n">ind_ids_ccc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                <span class="n">org_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">org_id</span><span class="p">)</span>
                <span class="n">org_ch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">org_ch</span><span class="p">)</span>
                
                <span class="n">boundary_org</span> <span class="o">=</span> <span class="n">org_tracks_list</span><span class="p">[</span><span class="n">org_ch</span><span class="p">][</span><span class="n">org_id</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">boundary_org</span><span class="p">)</span>

                <span class="c1"># # this is the problem? </span>
                <span class="c1"># # objectness score for deciding the dominant organoid. </span>
                <span class="c1"># obj_score = [ np.logical_not(org_tra_frame[0]) for org_tra_frame in boundary_org]</span>
                <span class="c1"># obj_score = np.sum(obj_score)</span>
                <span class="c1"># obj_score_cc.append(obj_score)  # pick the longest track. </span>
                <span class="n">obj_score</span> <span class="o">=</span> <span class="n">objectness_score_tracks_time</span><span class="p">(</span><span class="n">boundary_org</span><span class="p">[:],</span> 
                                                          <span class="n">obj_vid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">org_ch</span><span class="p">],</span> 
                                                          <span class="n">mean_func</span><span class="o">=</span><span class="n">obj_mean_func</span><span class="p">)</span>
                <span class="n">obj_score_cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_score</span><span class="p">)</span>

                <span class="c1"># stability score which is weighted on 2 factors. to determine which track. </span>
                <span class="n">nan_score</span> <span class="o">=</span> <span class="n">nan_stability_score_tracks</span><span class="p">(</span><span class="n">boundary_org</span><span class="p">)</span>
                
                <span class="c1"># # this should be a minimisation ..... ! </span>
                <span class="c1"># # smooth_score = smoothness_score_tracks(boundary_org, </span>
                <span class="c1"># #                                       mean_func=np.nanmean)</span>
                <span class="c1"># smooth_score = smoothness_score_tracks_iou(boundary_org, </span>
                <span class="c1">#                                            mean_func=smoothness_mean_func)</span>
                
                <span class="c1"># tra_stable_scores_cc.append(weight_nan*nan_score+weight_smooth*smooth_score)</span>
                <span class="n">tra_stable_scores_cc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nan_score</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">debug_viz</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span> <span class="s1">&#39;org: </span><span class="si">%s</span><span class="s1">, stable: </span><span class="si">%s</span><span class="s1">&#39;</span>  <span class="o">%</span><span class="p">(</span><span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)],</span> 
                                                       <span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)]))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
            <span class="c1"># stack all the scores.     </span>
            <span class="n">obj_score_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)</span>
            <span class="n">tra_stable_scores_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">tra_stable_scores_cc</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">tra_stable_scores_cc</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;===&#39;</span><span class="p">)</span>

            <span class="c1"># decide on the organoid and track (argmax)</span>
            <span class="n">cliq_org_id_keep</span> <span class="o">=</span> <span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)]</span>
            <span class="n">cliq_track_id_keep</span> <span class="o">=</span> <span class="n">ind_ids_cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">obj_score_cc</span><span class="p">)]</span>
            
            <span class="c1"># save this out for processing. </span>
            <span class="n">assigned_cliq_track_ids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cliq_org_id_keep</span><span class="p">,</span> <span class="n">cliq_track_id_keep</span><span class="p">])</span>

        <span class="c1"># 4. new org_tracks_list production based on the filtered information. </span>
        <span class="n">org_tracks_list_out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">list_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)):</span>

            <span class="n">org_tracks_list_ii</span> <span class="o">=</span> <span class="n">org_tracks_list</span><span class="p">[</span><span class="n">list_ii</span><span class="p">]</span>
            <span class="n">org_tracks_list_ii_out</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">org_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list_ii</span><span class="p">)):</span>
                <span class="n">tra_int_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">org_ii</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">list_ii</span><span class="p">)</span> <span class="c1"># create the string id lookup. </span>
                
                <span class="n">include_track</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">for</span> <span class="n">cliq_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cliq_ids</span><span class="p">)):</span>
                    <span class="n">ind_ids_cc</span> <span class="o">=</span> <span class="n">ind_ids</span><span class="p">[</span><span class="n">cliq_ids</span><span class="p">[</span><span class="n">cliq_ii</span><span class="p">]]</span> <span class="c1"># gets the clique members in string form -&gt; is this organoid part of a clique. </span>
                    
                    <span class="k">if</span> <span class="n">tra_int_id</span> <span class="ow">in</span> <span class="n">ind_ids_cc</span><span class="p">:</span>
                        <span class="n">include_track</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># do not automatically include.  </span>

                        <span class="c1"># test is this the dominant organoid in the clique. </span>
                        <span class="n">cliq_organoid_assign</span><span class="p">,</span> <span class="n">cliq_organoid_assign_track</span> <span class="o">=</span> <span class="n">assigned_cliq_track_ids</span><span class="p">[</span><span class="n">cliq_ii</span><span class="p">]</span> <span class="c1"># get the assignment information of the clique. </span>
                        
                        <span class="k">if</span> <span class="n">tra_int_id</span> <span class="o">==</span> <span class="n">cliq_organoid_assign</span><span class="p">:</span>
                            <span class="c1"># if this is the dominant organoid then we add the designated track. </span>
                            <span class="n">org_id_tra_assign</span><span class="p">,</span> <span class="n">org_ch_tra_assign</span> <span class="o">=</span> <span class="n">cliq_organoid_assign_track</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                            <span class="n">org_id_tra_assign</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">org_id_tra_assign</span><span class="p">);</span> <span class="n">org_ch_tra_assign</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">org_ch_tra_assign</span><span class="p">)</span>
                            
                            <span class="n">org_tracks_list_ii_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">[</span><span class="n">org_ch_tra_assign</span><span class="p">][</span><span class="n">org_id_tra_assign</span><span class="p">])</span>

                        <span class="c1"># do nothing otherwise -&gt; exclude this organoid basically. </span>
                
                <span class="k">if</span> <span class="n">include_track</span><span class="p">:</span> 
                    <span class="c1"># directly include. </span>
                    <span class="n">org_tracks_list_ii_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_tracks_list_ii</span><span class="p">[</span><span class="n">org_ii</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">org_tracks_list_ii_out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># stack the tracks. </span>
                <span class="n">org_tracks_list_ii_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">org_tracks_list_ii_out</span><span class="p">)</span>
            
            <span class="n">org_tracks_list_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_tracks_list_ii_out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">org_tracks_list_out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">org_tracks_list</span><span class="p">)</span>

    <span class="c1"># cleaned tracks, in the same input format as a list of numpy tracks for each channel. </span>
    <span class="k">return</span> <span class="n">org_tracks_list_out</span></div>


<div class="viewcode-block" id="filter_nan_tracks"><a class="viewcode-back" href="../../../unwrap3D.Tracking.html#unwrap3D.Tracking.tracking.filter_nan_tracks">[docs]</a><span class="k">def</span> <span class="nf">filter_nan_tracks</span><span class="p">(</span> <span class="n">boundary</span> <span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function removes all tracks that for the entire duration is only nan. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">boundaries_out</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">)):</span>
        
        <span class="n">tra</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">tra_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tra</span><span class="p">)</span>
        <span class="n">n_nans</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">tra_tt</span> <span class="ow">in</span> <span class="n">tra</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tra_tt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">n_nans</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">n_nans</span> <span class="o">&lt;</span> <span class="n">tra_len</span><span class="p">:</span>
            <span class="n">boundaries_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tra</span><span class="p">)</span> <span class="c1"># append the whole track</span>
            
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundaries_out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">boundaries_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boundaries_out</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">boundaries_out</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Y. Zhou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>