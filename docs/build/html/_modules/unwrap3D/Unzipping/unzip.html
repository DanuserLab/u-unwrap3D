<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>unwrap3D.Unzipping.unzip &mdash; u-Unwrap3D 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> u-Unwrap3D
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">u-Unwrap3D</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>unwrap3D.Unzipping.unzip</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for unwrap3D.Unzipping.unzip</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
        

<div class="viewcode-block" id="voxelize_unwrap_params"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.voxelize_unwrap_params">[docs]</a><span class="k">def</span> <span class="nf">voxelize_unwrap_params</span><span class="p">(</span><span class="n">unwrap_params</span><span class="p">,</span> 
                           <span class="n">vol_shape</span><span class="p">,</span> 
                           <span class="n">preupsample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                           <span class="n">ksize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                           <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                           <span class="n">erode_ksize</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Voxelizes an unwrapped surface mesh described in (u,v) in (x,y,z) original space for propagation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_params : (UxVx3) array </span>
<span class="sd">        the unwrapped 2D lookup table implicitly associating 2D (u,v) to corresponding (x,y,z) coordinates</span>
<span class="sd">    vol_shape : (3,) array</span>
<span class="sd">        the shape of the original volume image.</span>
<span class="sd">    preupsample : scalar</span>
<span class="sd">        if not none, unwrap_params is resized to preupsample times the current image size. This effectively increases the mesh sampling and is recommended to get a closed volume voxelization. </span>
<span class="sd">    ksize : int</span>
<span class="sd">        morphological closing radius of the Ball kernel to close small holes after voxelization</span>
<span class="sd">    smooth_sigma : scalar</span>
<span class="sd">        if not None, a Gaussian smooth of the indicated sigma is applied to smooth the voxelized binary, then rebinariesd by thresholding &gt;= 0.5. This process helps to diffuse and close over larger holes than binary closing.</span>
<span class="sd">    erode_ksize : int</span>
<span class="sd">        if not None, the voxelized binary is eroded by erode_ksize. This is done when the voxelized binary is larger than the original shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    ------- </span>
<span class="sd">    surf_unwrap_vol : (MxNxL) array</span>
<span class="sd">        voxelized mesh in original Cartesian (x,y,z) space. </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">skimage.transform</span> <span class="k">as</span> <span class="nn">sktform</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span> 
    <span class="c1"># from skimage.filters import gaussian </span>
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">binary_fill_holes</span>


    <span class="n">unwrap_params_</span> <span class="o">=</span> <span class="n">unwrap_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vol_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">preupsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unwrap_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">unwrap_params_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> <span class="n">output_shape</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">preupsample</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>

    <span class="c1"># discretize. </span>
    <span class="n">unwrap_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">unwrap_params_</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="c1"># 6-connectivity</span>

    <span class="n">surf_unwrap_vol</span><span class="p">[</span><span class="n">unwrap_params_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">unwrap_params_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">unwrap_params_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">binary_closing</span><span class="p">(</span><span class="n">surf_unwrap_vol</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">ksize</span><span class="p">));</span> 
    <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">surf_unwrap_vol</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">smooth_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="c1"># surf_unwrap_vol = gaussian(surf_unwrap_vol*1., sigma=smooth_sigma, preserve_range=True)</span>
        <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">surf_unwrap_vol</span><span class="o">*</span><span class="mf">1.</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">)</span>
        <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">surf_unwrap_vol</span><span class="o">/</span><span class="n">surf_unwrap_vol</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">surf_unwrap_vol</span> <span class="o">&gt;=</span> <span class="mf">0.5</span>

    <span class="k">if</span> <span class="n">erode_ksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">surf_unwrap_vol</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">surf_unwrap_vol</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">erode_ksize</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">surf_unwrap_vol</span></div>


<div class="viewcode-block" id="prop_ref_surface"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.prop_ref_surface">[docs]</a><span class="k">def</span> <span class="nf">prop_ref_surface</span><span class="p">(</span><span class="n">unwrap_params_ref</span><span class="p">,</span> 
                         <span class="n">vol_size</span><span class="p">,</span>  
                         <span class="n">preupsample</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                         <span class="n">vol_binary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">ksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                         <span class="n">smooth_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                         <span class="n">d_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                         <span class="n">n_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                         <span class="n">surf_pts_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">pad_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
                         <span class="n">smoothgradient</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                         <span class="n">smoothrobust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">smooth_method</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> 
                         <span class="n">smooth_win</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                         <span class="n">invertorder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">squarenorm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Propagate a (u,v) indexed (x,y,z) surface such as that from unwrapping normally into or outwards at a uniform stepsize of ``d_step`` for ``n_dist`` total number of steps. This function is used to create the topography space to map a whole volume given an unwrapping of a single surface.   </span>
<span class="sd">    </span>
<span class="sd">    1. if vol_binary is not provided, a voxelization is first computed </span>
<span class="sd">    2. based on the vol_binary, the signed distance function and the gradient field for propagation is computed</span>
<span class="sd">    3. initial points are then integrated along the gradient field iteratively using explicit Euler with new position x_next = x + d_step * gradient</span>
<span class="sd">    4. smoothing is used after each iteration to regularise the advected points. this is crucial for outward stepping when the interspacing between mesh points are increasing </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_params_ref : (UxVx3) array</span>
<span class="sd">        the unwrapped (u,v) image-indexed (x,y,z) surface to propagate</span>
<span class="sd">    vol_size : (m,n,l) 3-tuple</span>
<span class="sd">        the size of the original volume image</span>
<span class="sd">    preupsample : scalar</span>
<span class="sd">        if not none, unwrap_params is resized to preupsample times the current image size. This effectively increases the mesh sampling and is recommended to get a closed volume voxelization. </span>
<span class="sd">    smooth_sigma : scalar</span>
<span class="sd">        if not None, a Gaussian smooth of the indicated sigma is applied to smooth the voxelized binary, then rebinariesd by thresholding &gt;= 0.5. This process helps to diffuse and close over larger holes than binary closing.</span>
<span class="sd">    d_step : scalar</span>
<span class="sd">        the step size in voxels to move in the normal direction. A d_step of negative sign reverses the direction of advection</span>
<span class="sd">    n_dist : int</span>
<span class="sd">        if not None, the total number of steps to take in the normal direction. </span>
<span class="sd">    surf_pts_ref : (N,3) array </span>
<span class="sd">        if provided, this is a reference surface with which to automatically determine the n_dist when propagating the surface outwards to ensure the full reference shape is sampled in topography space.</span>
<span class="sd">    pad_dist : int </span>
<span class="sd">        an additional fudge factor added to the automatically determined n_dist when surf_pts_ref is provided and n_dist is not user provided</span>
<span class="sd">    smoothgradient : scalar</span>
<span class="sd">        if given, this is the parameter that controls the amount of smoothing in the `smoothN &lt;https://www.biomecardio.com/matlab/smoothn_doc.html&gt;`_ algorithm</span>
<span class="sd">    smoothrobust : bool </span>
<span class="sd">        if True, use the robust smoothing mode of smoothN algorithm </span>
<span class="sd">    smooth_method : str</span>
<span class="sd">        specifies the gradient smoothing mode per iteration to regularise the points. </span>

<span class="sd">        &#39;smoothN&#39; : str</span>
<span class="sd">            applies a spline-based smoothing of `Garcia &lt;https://www.biomecardio.com/matlab/smoothn_doc.html&gt;`_. This algorithm can be pretty slow. See :func:`unwrap3D.Unzipping.unzip.smooth_unwrap_params_3D_spherical_SmoothN`</span>
<span class="sd">        &#39;uniform&#39; : str</span>
<span class="sd">            treats the spacing of mesh points as uniform and applies fast separable 1D Gaussian smoothing along each axis of the 2D parameterization. See :func:`unwrap3D.Unzipping.unzip.smooth_unwrap_params_3D_spherical`</span>

<span class="sd">    smooth_win : int</span>
<span class="sd">        the smoothing window to smooth the advected points used in the uniform method. </span>
<span class="sd">    invertorder : bool</span>
<span class="sd">        if invertorder, the final concatenated stack of points of (D,U,V,3) where D is the total number of steps is inverted in the first dimension. </span>
<span class="sd">    squarenorm : bool </span>
<span class="sd">        if True, propagate using the gradient field, V normalised by magnitude squared i.e. :math:`V/(|V|^2)` instead of the unit magnitude normalization :math:`V/|V|`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unwrapped_coord_depth : (DxUxVx3) array</span>
<span class="sd">        the final unwrapped topography space of (d,u,v) image-indexed (x,y,z) surface which map an entire volume space to topography space.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="c1"># import pylab as plt </span>
    <span class="kn">from</span> <span class="nn">..Segmentation.segmentation</span> <span class="kn">import</span> <span class="n">surf_normal_sdf</span>
    <span class="kn">from</span> <span class="nn">..Image_Functions.image</span> <span class="kn">import</span> <span class="n">map_intensity_interp3</span>

    <span class="k">if</span> <span class="n">vol_binary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># construct a binary of the input mesh/points. # todo change to the better voxelizer.... </span>
        <span class="n">vol_binary</span> <span class="o">=</span> <span class="n">voxelize_unwrap_params</span><span class="p">(</span><span class="n">unwrap_params_ref</span><span class="p">,</span> 
                                             <span class="n">vol_shape</span><span class="o">=</span><span class="n">vol_size</span><span class="p">,</span> 
                                             <span class="n">preupsample</span><span class="o">=</span><span class="n">preupsample</span><span class="p">,</span> 
                                             <span class="n">ksize</span><span class="o">=</span><span class="n">ksize</span><span class="p">,</span> 
                                             <span class="n">smooth_sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">)</span>
        
        <span class="c1"># print(np.sum(vol_binary))</span>
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(vol_binary[vol_binary.shape[0]//2])</span>
        <span class="c1"># plt.show()</span>
        
        <span class="c1"># get the surface normal gradient outwards.  </span>
        <span class="c1"># binary_vol_grad = vol_gradient(vol_binary, smooth_sigma=smooth_sigma, normalize=True, invert=True, squarenorm=squarenorm) # always outwards. # i see. # we should get the sdf !.</span>
        <span class="c1"># binary_sdf_vol = sdf_distance_transform(binary, rev_sign=True, method=&#39;edt&#39;)</span>
        <span class="n">binary_vol_grad</span><span class="p">,</span> <span class="n">binary_vol_sdf</span> <span class="o">=</span> <span class="n">surf_normal_sdf</span><span class="p">(</span><span class="n">vol_binary</span><span class="p">,</span> 
                                                          <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">,</span> 
                                                          <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> 
                                                          <span class="n">norm_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">binary_vol_grad</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">binary_vol_grad</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    
        <span class="c1"># print(binary_vol_grad.shape)</span>
        <span class="c1"># print(np.min(binary_vol_sdf), np.max(binary_vol_sdf))</span>
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(binary_vol_grad[vol_binary.shape[0]//2,...,0])</span>
        <span class="c1"># plt.show()</span>
        
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(binary_vol_sdf[vol_binary.shape[0]//2])</span>
        <span class="c1"># plt.show()</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># print(np.sum(vol_binary))</span>
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(vol_binary[vol_binary.shape[0]//2])</span>
        <span class="c1"># plt.show()</span>
        
        <span class="c1"># get the surface normal gradient outwards.  </span>
        <span class="c1"># binary_vol_grad = vol_gradient(vol_binary, smooth_sigma=smooth_sigma, normalize=True, invert=True, squarenorm=squarenorm) # always outwards. # i see. # we should get the sdf !.</span>
        <span class="c1"># binary_sdf_vol = sdf_distance_transform(binary, rev_sign=True, method=&#39;edt&#39;)</span>
        <span class="n">binary_vol_grad</span><span class="p">,</span> <span class="n">binary_vol_sdf</span> <span class="o">=</span> <span class="n">surf_normal_sdf</span><span class="p">(</span><span class="n">vol_binary</span><span class="p">,</span> 
                                                          <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">,</span> 
                                                          <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> 
                                                          <span class="n">norm_vectors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">binary_vol_grad</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">binary_vol_grad</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    
        <span class="c1"># print(binary_vol_grad.shape)</span>
        <span class="c1"># print(np.min(binary_vol_sdf), np.max(binary_vol_sdf))</span>
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(binary_vol_grad[vol_binary.shape[0]//2,...,0])</span>
        <span class="c1"># plt.show()</span>
        
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(binary_vol_sdf[vol_binary.shape[0]//2])</span>
        <span class="c1"># plt.show()</span>
        
    <span class="c1"># infer the number of dists to step for from the reference if not prespecified. </span>
    <span class="k">if</span> <span class="n">n_dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">unwrap_params_ref_flat</span> <span class="o">=</span> <span class="n">unwrap_params_ref</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">unwrap_params_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># infer the maximum step size so as to cover the initial otsu surface.</span>
        <span class="n">mean_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">unwrap_params_ref_flat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># # more robust to do an ellipse fit. ? =&gt; doesn&#39;t seem so... seems best to take the extremal point -&gt; since we should have a self-similar shape. </span>
        <span class="c1"># unwrap_params_fit_major_len = np.max(np.linalg.eigvalsh(np.cov((unwrap_params_ref_flat-mean_pt[None,:]).T))); unwrap_params_fit_major_len=np.sqrt(unwrap_params_fit_major_len)</span>
        <span class="c1"># surf_ref_major_len = np.max(np.linalg.eigvalsh(np.cov((surf_pts_ref-mean_pt[None,:]).T))); surf_ref_major_len = np.sqrt(surf_ref_major_len)</span>

        <span class="n">mean_dist_unwrap_params_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unwrap_params_ref_flat</span><span class="o">-</span><span class="n">mean_pt</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">mean_surf_pts_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">surf_pts_ref</span><span class="o">-</span><span class="n">mean_pt</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># strictly should do an ellipse fit... </span>

        <span class="n">n_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mean_surf_pts_ref</span><span class="o">-</span><span class="n">mean_dist_unwrap_params_ref</span><span class="p">))</span>
        <span class="n">n_dist</span> <span class="o">=</span> <span class="n">n_dist</span> <span class="o">+</span> <span class="n">pad_dist</span> <span class="c1"># this is in pixels</span>
        <span class="n">n_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_dist</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_step</span><span class="p">)))</span> <span class="c1"># so if we take 1./2 step then we should step 2*</span>

        <span class="c1"># print(n_dist)</span>
        <span class="c1"># print(&#39;----&#39;)</span>

    <span class="n">unwrapped_coord_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">unwrap_params_ref</span><span class="p">]</span> <span class="c1"># initialise with the reference surface. </span>

    <span class="k">for</span> <span class="n">d_ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_dist</span><span class="p">)):</span>

        <span class="n">pts_next</span> <span class="o">=</span> <span class="n">unwrapped_coord_depth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">pts_next</span> <span class="o">=</span> <span class="n">pts_next</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">pts_next</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># pull the last and flatten. </span>

        <span class="c1"># get the gradient at the next point. </span>
        <span class="n">grad_next_x</span> <span class="o">=</span> <span class="n">map_intensity_interp3</span><span class="p">(</span><span class="n">pts_next</span><span class="p">,</span> 
                                            <span class="n">grid_shape</span><span class="o">=</span><span class="n">binary_vol_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">binary_vol_grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">grad_next_y</span> <span class="o">=</span> <span class="n">map_intensity_interp3</span><span class="p">(</span><span class="n">pts_next</span><span class="p">,</span> 
                                            <span class="n">grid_shape</span><span class="o">=</span><span class="n">binary_vol_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">binary_vol_grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">grad_next_z</span> <span class="o">=</span> <span class="n">map_intensity_interp3</span><span class="p">(</span><span class="n">pts_next</span><span class="p">,</span> 
                                            <span class="n">grid_shape</span><span class="o">=</span><span class="n">binary_vol_grad</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">binary_vol_grad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">grad_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">grad_next_x</span><span class="p">,</span> <span class="n">grad_next_y</span><span class="p">,</span> <span class="n">grad_next_z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unwrapped_coord_depth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># smooth the gradients. </span>
        <span class="k">if</span> <span class="n">smooth_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">smooth_method</span> <span class="o">==</span> <span class="s1">&#39;smoothN&#39;</span><span class="p">:</span>
                <span class="n">grad_next</span> <span class="o">=</span> <span class="n">smooth_unwrap_params_3D_spherical_SmoothN</span><span class="p">(</span><span class="n">grad_next</span><span class="p">,</span> 
                                                                        <span class="n">S</span><span class="o">=</span><span class="n">smoothgradient</span><span class="p">,</span> 
                                                                        <span class="n">isrobust</span><span class="o">=</span><span class="n">smoothrobust</span><span class="p">,</span> 
                                                                        <span class="n">pad_size</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># what is none?</span>
            <span class="k">if</span> <span class="n">smooth_method</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                <span class="n">grad_next</span> <span class="o">=</span> <span class="n">smooth_unwrap_params_3D_spherical</span><span class="p">(</span><span class="n">grad_next</span><span class="p">,</span> 
                                                              <span class="n">sigma_window</span><span class="o">=</span><span class="n">smooth_win</span><span class="p">,</span> 
                                                              <span class="n">filter_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                                              <span class="n">filter1d</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  
                                                              <span class="n">filter2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                                                <span class="n">filterALS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                                               <span class="n">ALS_lam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                                               <span class="n">ALS_p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                                               <span class="n">ALS_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># if pad_size is None:</span>
            <span class="c1"># #     # pad the mesh..... </span>
            <span class="c1"># #     grad_next = np.hstack([grad_next, grad_next, grad_next])</span>
            <span class="c1"># #     grad_next = np.vstack([grad_next[1:][::-1,::-1],</span>
            <span class="c1"># #                             grad_next,</span>
            <span class="c1"># #                             grad_next[:-1][::-1,::-1]])</span>
            <span class="c1"># # # else:</span>
            <span class="c1">#     grad_next = smooth_unwrap_params_3D_spherical(grad_next, </span>
            <span class="c1">#                                                 sigma_window=35, </span>
            <span class="c1">#                                                 isrobust=smoothrobust, </span>
            <span class="c1">#                                                 pad_size=None)</span>
            <span class="c1">#     # unwrap_xyz, sigma_window=15, filter_func=None, </span>
            <span class="c1">#     #                        filter1d=True,  filter2d=False, </span>
            <span class="c1">#     #                        filterALS=True, </span>
            <span class="c1">#     #                        ALS_lam=None, </span>
            <span class="c1">#     #                        ALS_p=None, </span>
            <span class="c1">#     #                        ALS_iter=None</span>
            <span class="c1"># # renormalize. </span>
            <span class="k">if</span> <span class="n">squarenorm</span><span class="p">:</span>
                <span class="n">grad_next</span> <span class="o">=</span> <span class="n">grad_next</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grad_next</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="c1"># renormalize! or we do square of the norm ? </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grad_next</span> <span class="o">=</span> <span class="n">grad_next</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grad_next</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="c1"># renormalize! or we do square of the norm ? </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># renormalize. </span>
            <span class="k">if</span> <span class="n">squarenorm</span><span class="p">:</span>
                <span class="n">grad_next</span> <span class="o">=</span> <span class="n">grad_next</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grad_next</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="c1"># renormalize! or we do square of the norm ? </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grad_next</span> <span class="o">=</span> <span class="n">grad_next</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grad_next</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="c1"># renormalize! or we do square of the norm ? </span>

        <span class="c1"># get the next point and clip.</span>
        <span class="n">pts_next_</span> <span class="o">=</span> <span class="n">unwrapped_coord_depth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_step</span> <span class="o">*</span> <span class="n">grad_next</span>

        <span class="c1"># clip the pts to the range of the image. </span>
        <span class="n">pts_next_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pts_next_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vol_binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pts_next_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pts_next_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vol_binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pts_next_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">pts_next_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vol_binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">unwrapped_coord_depth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts_next_</span><span class="p">)</span>

    <span class="n">unwrapped_coord_depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unwrapped_coord_depth</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">invertorder</span><span class="p">:</span>
        <span class="n">unwrapped_coord_depth</span> <span class="o">=</span> <span class="n">unwrapped_coord_depth</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unwrapped_coord_depth</span></div>


<span class="c1"># function to fix the bounds by reinterpolation based on griddata. </span>
<div class="viewcode-block" id="fix_unwrap_params_boundaries_spherical"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.fix_unwrap_params_boundaries_spherical">[docs]</a><span class="k">def</span> <span class="nf">fix_unwrap_params_boundaries_spherical</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a UV unwrapping of a closed spherical-like surface, this function enforces that the first and last rows map to single coordinate representing the North and South poles and conducts scattered interpolation to impute missing values.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_xyz : (UxVx3) array </span>
<span class="sd">        the unwrapped (u,v) image-indexed (x,y,z) surface to propagate</span>
<span class="sd">    pad : int </span>
<span class="sd">        the internal padding of unwrap_xyz to allow interpolation of missed edge coordinates and to have better continuity in internal regions. </span>
<span class="sd">    rescale : bool </span>
<span class="sd">        if True, rescales points to unit cube before performing interpolation. This is useful if some of the input dimensions have incommensurable units and differ by many orders of magnitude. see `griddata &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.griddata.html&gt;`_</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    unwrap_xyz_fix : (UxVx3) array </span>
<span class="sd">        the fixed unwrapped (u,v) image-indexed (x,y,z) of the same size as the input</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># assuming a spherical geometry. </span>
    <span class="n">unwrap_xyz_fix</span> <span class="o">=</span> <span class="n">unwrap_xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># use this to define the bound</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">min_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">max_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># first and last row map to singular points. </span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># wrap around to get a convex hull. </span>
    <span class="n">unwrap_xyz_fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">unwrap_xyz_fix</span><span class="p">[:,</span><span class="o">-</span><span class="n">pad</span><span class="p">:],</span> <span class="n">unwrap_xyz_fix</span><span class="p">,</span> <span class="n">unwrap_xyz_fix</span><span class="p">[:,:</span><span class="n">pad</span><span class="p">]])</span>
    <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unwrap_xyz_fix</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># now create a griddata. </span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="n">unwrap_xyz_fix</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">rows_</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
    <span class="n">cols_</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
    <span class="n">interp_x</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cols_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">rows_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]]),</span> <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">,</span><span class="mi">0</span><span class="p">],(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span>
    <span class="n">interp_y</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cols_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">rows_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]]),</span> <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">,</span><span class="mi">1</span><span class="p">],(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span>
    <span class="n">interp_z</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cols_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">rows_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]]),</span> <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">,</span><span class="mi">2</span><span class="p">],(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span>
    
    <span class="n">unwrap_xyz_fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">interp_x</span><span class="p">,</span> 
                                <span class="n">interp_y</span><span class="p">,</span> 
                                <span class="n">interp_z</span><span class="p">])</span>
    <span class="n">unwrap_xyz_fix</span> <span class="o">=</span> <span class="n">unwrap_xyz_fix</span><span class="p">[:,</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>

    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_x</span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">max_x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_x</span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_y</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_y</span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">max_y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_y</span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_z</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_z</span>
    <span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="n">unwrap_xyz_fix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_z</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_z</span>     

    <span class="k">return</span> <span class="n">unwrap_xyz_fix</span></div>


<div class="viewcode-block" id="pad_unwrap_params_3D_spherical"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.pad_unwrap_params_3D_spherical">[docs]</a><span class="k">def</span> <span class="nf">pad_unwrap_params_3D_spherical</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Function to pad a single or multichannel 2D image in a spherical manner topologically such that the left/right sides are periodic extensions. The top is extended with a 180 degree flip, and the bottom is also extended with a 180 degree flip</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_xyz : </span>
<span class="sd">        an input (MxN) or (MxNxd) image to pad</span>

<span class="sd">    pad : int </span>
<span class="sd">        The uniform padding in the width and height </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unwrap_xyz_pad : </span>
<span class="sd">        The padded image of dimensionality (M+2*pad x N+2*pad) or (M+2*pad x N+2*pad x d)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">unwrap_xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># periodic in x</span>
    <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">unwrap_xyz</span><span class="p">[:,</span><span class="o">-</span><span class="n">pad</span><span class="p">:],</span> 
                                <span class="n">unwrap_xyz</span><span class="p">,</span> 
                                <span class="n">unwrap_xyz</span><span class="p">[:,:</span><span class="n">pad</span><span class="p">]])</span>

    <span class="c1"># flip and pad in x # but don&#39;t take the first and last!!!! else we have a discontinuity.... </span>
    <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">unwrap_xyz_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">pad</span><span class="o">+</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                <span class="n">unwrap_xyz_pad</span><span class="p">,</span> 
                                <span class="n">unwrap_xyz_pad</span><span class="p">[</span><span class="o">-</span><span class="n">pad</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">unwrap_xyz_pad</span></div>


<div class="viewcode-block" id="pad_unwrap_params_3D_spherical_depth"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.pad_unwrap_params_3D_spherical_depth">[docs]</a><span class="k">def</span> <span class="nf">pad_unwrap_params_3D_spherical_depth</span><span class="p">(</span><span class="n">unwrap_depth_vals</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pad_depth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pad_depth_mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Function to pad a topographic space coordinate set in a spherical manner topologically such that the left/right sides are periodic extensions. The top is extended with a 180 degree flip, and the bottom is also extended with a 180 degree flip</span>
<span class="sd">    Optionally one can extend the depth (first channel) with the specified edge pad mode. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_depth_vals : array </span>
<span class="sd">        an input (DxMxNxd) image to pad</span>
<span class="sd">    pad : int </span>
<span class="sd">        The uniform padding in the width and height i.e. M, N axis</span>
<span class="sd">    pad_depth : bool</span>
<span class="sd">        If True, pad the depth dimension (D) also by ``pad`` </span>
<span class="sd">    pad_depth_mode : str</span>
<span class="sd">        if pad_depth is True, this specifies the handling of the padding. It should be one of the options in numpy.pad</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unwrap_depth_vals_pad : </span>
<span class="sd">        The padded image of dimensionality (D x M+2*pad x N+2*pad x d) for pad_depth=False or (D+2*pad x M+2*pad x N+2*pad x d) for pad_depth=True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># depth x m x n x ndim. </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="c1"># first pad in the horizontal then vertical ...</span>
    <span class="c1"># pad horizontal. </span>
    <span class="n">unwrap_depth_vals_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">unwrap_depth_vals</span><span class="p">[:,:,</span><span class="o">-</span><span class="n">pad</span><span class="p">:],</span> 
                                            <span class="n">unwrap_depth_vals</span><span class="p">,</span> 
                                            <span class="n">unwrap_depth_vals</span><span class="p">[:,:,:</span><span class="n">pad</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># pad vertical.</span>
    <span class="n">unwrap_depth_vals_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">unwrap_depth_vals_pad</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="n">pad</span><span class="o">+</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                            <span class="n">unwrap_depth_vals_pad</span><span class="p">,</span>
                                            <span class="n">unwrap_depth_vals_pad</span><span class="p">[:,</span><span class="o">-</span><span class="n">pad</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">pad_depth</span><span class="p">:</span>
        <span class="c1"># we must also pad in depth!. </span>
        <span class="n">unwrap_depth_vals_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">unwrap_depth_vals_pad</span><span class="p">,</span> <span class="p">[[</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_depth_mode</span><span class="p">)</span> 
    
    <span class="k">return</span> <span class="n">unwrap_depth_vals_pad</span></div>


<div class="viewcode-block" id="compute_unwrap_params_normal_curvature"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.compute_unwrap_params_normal_curvature">[docs]</a><span class="k">def</span> <span class="nf">compute_unwrap_params_normal_curvature</span><span class="p">(</span><span class="n">unwrap_depth_binary</span><span class="p">,</span>
                                           <span class="n">pad</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>  
                                           <span class="n">compute_curvature</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">smooth_gradient</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                           <span class="n">smooth_curvature</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                           <span class="n">mask_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Function to pad a topographic space coordinate set in a spherical manner topologically such that the left/right sides are periodic extensions. The top is extended with a 180 degree flip, and the bottom is also extended with a 180 degree flip</span>
<span class="sd">    Optionally one can extend the depth (first channel) with the specified edge pad mode. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_depth_vals : array </span>
<span class="sd">        an input (DxMxNxd) image to pad</span>
<span class="sd">    pad : int </span>
<span class="sd">        The uniform padding in the width and height i.e. M, N axis</span>
<span class="sd">    pad_depth : bool</span>
<span class="sd">        If True, pad the depth dimension (D) also by ``pad`` </span>
<span class="sd">    pad_depth_mode : str</span>
<span class="sd">        if pad_depth is True, this specifies the handling of the padding. It should be one of the options in numpy.pad</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unwrap_depth_vals_pad : </span>
<span class="sd">        The padded image of dimensionality (D x M+2*pad x N+2*pad x d) for pad_depth=False or (D+2*pad x M+2*pad x N+2*pad x d) for pad_depth=True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..Segmentation</span> <span class="kn">import</span> <span class="n">segmentation</span> <span class="k">as</span> <span class="n">segmentation</span>
    <span class="k">if</span> <span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="n">unwrap_depth_binary_pad</span> <span class="o">=</span> <span class="n">pad_unwrap_params_3D_spherical_depth</span><span class="p">(</span><span class="n">unwrap_depth_binary</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> 
                                                                        <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad_depth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pad_depth_mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
        <span class="n">unwrap_depth_binary_pad</span> <span class="o">=</span> <span class="n">unwrap_depth_binary_pad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unwrap_depth_binary_pad</span> <span class="o">=</span> <span class="n">unwrap_depth_binary</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">compute_curvature</span><span class="p">:</span>
        <span class="n">H_normal</span><span class="p">,</span> <span class="n">sdf_vol_normal</span><span class="p">,</span> <span class="n">sdf_vol</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">mean_curvature_binary</span><span class="p">(</span><span class="n">unwrap_depth_binary_pad</span><span class="p">,</span> 
                                                                                <span class="n">smooth</span><span class="o">=</span><span class="n">smooth_curvature</span><span class="p">,</span> 
                                                                                <span class="n">mask</span><span class="o">=</span><span class="n">mask_gradient</span><span class="p">,</span> 
                                                                                <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_gradient</span><span class="p">,</span> 
                                                                                <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unwrap_depth_binary_pad</span><span class="p">,</span> <span class="n">H_normal</span><span class="p">,</span> <span class="n">sdf_vol_normal</span><span class="p">,</span> <span class="n">sdf_vol</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sdf_vol_normal</span><span class="p">,</span> <span class="n">sdf_vol</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">surf_normal_sdf</span><span class="p">(</span><span class="n">unwrap_depth_binary_pad</span><span class="p">,</span> 
                                                                <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                                <span class="n">smooth_gradient</span><span class="o">=</span><span class="n">smooth_gradient</span><span class="p">,</span> 
                                                                <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unwrap_depth_binary_pad</span><span class="p">,</span> <span class="n">sdf_vol_normal</span><span class="p">,</span> <span class="n">sdf_vol</span> </div>

<span class="c1">### add in the weighted filtering variant taking into account local mapping errors. </span>
<div class="viewcode-block" id="smooth_unwrap_params_3D_spherical"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.smooth_unwrap_params_3D_spherical">[docs]</a><span class="k">def</span> <span class="nf">smooth_unwrap_params_3D_spherical</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">,</span> 
                                      <span class="n">sigma_window</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> 
                                      <span class="n">filter_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                      <span class="n">filter1d</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  
                                      <span class="n">filter2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                      <span class="n">filterALS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                      <span class="n">ALS_lam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                      <span class="n">ALS_p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                      <span class="n">ALS_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Applies image based smoothing techniques to smooth a (u,v) image parameterized (x,y,z) surface</span>

<span class="sd">    Options include</span>
<span class="sd">    - uniform 1d smoothing along x- and y- separately (filter1d=True)</span>
<span class="sd">    - Gaussian 2D smoothing (filter2d=True)</span>
<span class="sd">    - spline based smoothing (filterALS=True)   </span>
<span class="sd">    </span>
<span class="sd">    Only one of filter1d, filter2d and filterALS should be True</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_xyz : array </span>
<span class="sd">        an input (MxNxd) image to smooth</span>
<span class="sd">    sigma_window : int</span>
<span class="sd">        smoothing window in pixels </span>
<span class="sd">    filter_func : array</span>
<span class="sd">        specifies the ``weight`` in scipy.ndimage.filters.convolve1d for ``filter1d=True``. If filter_func=None, defaults to the uniform filter equivalent to taking the mean over the window ``2*sigma_window+1``</span>
<span class="sd">    filter1d : bool</span>
<span class="sd">        if True use scipy.ndimage.filters.convolve1d with the given weights, filter_func to filter the unwrapping coordinates. </span>
<span class="sd">    filter2d : bool</span>
<span class="sd">        if True, apply skimage.filters.gaussian with sigma=sigma_window</span>
<span class="sd">    filterALS : bool</span>
<span class="sd">        if True, asymmetric least squares is applied along independent x- and y- directions for smoothing with parameters given by ``ALS_lam, ALS_p and ALS_iter``. See :func:`unwrap3D.Analysis_Functions.timeseries.baseline_als`</span>
<span class="sd">    ALS_lam : scalar</span>
<span class="sd">        Controls the degree of smoothness in the baseline. The higher the smoother.</span>
<span class="sd">    ALS_p : scalar</span>
<span class="sd">        Controls the degree of smoothness in the baseline. The smaller the more asymmetric, the more the fitting biases towards the minimum value.</span>
<span class="sd">    ALS_iter : int</span>
<span class="sd">        The number of iterations to run the algorithm. Only a few iterations is required generally. This can generally be fixed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unwrap_xyz_filt : </span>
<span class="sd">        the smoothed output (MxNxd) image </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">convolve1d</span>
    <span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">gaussian</span>

    <span class="k">def</span> <span class="nf">baseline_als</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
        <span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span>
        
    <span class="k">if</span> <span class="n">filter_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assume uniform</span>
        <span class="n">filter_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma_window</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> 
        <span class="n">filter_func</span> <span class="o">=</span> <span class="n">filter_func</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">filter_func</span><span class="p">))</span> <span class="c1"># normalize</span>

    <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">pad_unwrap_params_3D_spherical</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">sigma_window</span><span class="p">)</span> <span class="c1"># we need to pad this more... to prevent edge effects...  </span>
    
    <span class="k">if</span> <span class="n">filter1d</span><span class="p">:</span> 
        <span class="n">unwrap_xyz_x</span> <span class="o">=</span> <span class="n">convolve1d</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">filter_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">convolve1d</span><span class="p">(</span><span class="n">unwrap_xyz_x</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">filter_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filterALS</span><span class="p">:</span>
        <span class="c1"># this idea works without fundamentally changing things -&gt; so we should be able to run proxTV ....</span>
        <span class="c1"># then we are going to filter.... if we set this too high ... we get moving average filter ( as the support of it is too high! )</span>
        <span class="n">unwrap_xyz_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">baseline_als</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="p">[</span><span class="n">ii</span><span class="p">,:,</span><span class="n">ch</span><span class="p">],</span> <span class="n">lam</span><span class="o">=</span><span class="n">ALS_lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">ALS_p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">ALS_iter</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="p">))])</span>  <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span> <span class="c1"># rows. </span>
        <span class="n">unwrap_xyz_x</span> <span class="o">=</span> <span class="n">unwrap_xyz_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">baseline_als</span><span class="p">(</span><span class="n">unwrap_xyz_x</span><span class="p">[:,</span><span class="n">ii</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> <span class="n">lam</span><span class="o">=</span><span class="n">ALS_lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">ALS_p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">ALS_iter</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>  <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">unwrap_xyz_filt</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filter2d</span><span class="p">:</span>
        <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gaussian</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma_window</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">unwrap_xyz_filt</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">unwrap_xyz_filt</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">sigma_window</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">sigma_window</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># because of extra padding. </span>
    <span class="n">unwrap_xyz_filt</span> <span class="o">=</span> <span class="n">unwrap_xyz_filt</span><span class="p">[:,</span><span class="mi">3</span><span class="o">*</span><span class="n">sigma_window</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">sigma_window</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">unwrap_xyz_filt</span></div>


<div class="viewcode-block" id="smooth_unwrap_params_3D_spherical_SmoothN"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.smooth_unwrap_params_3D_spherical_SmoothN">[docs]</a><span class="k">def</span> <span class="nf">smooth_unwrap_params_3D_spherical_SmoothN</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">,</span> 
                                              <span class="n">S</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                              <span class="n">isrobust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                              <span class="n">pad_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Applies the Whittaker smoother, smoothN of David Garcia to smooth a (u,v) image parameterized (x,y,z) surface. This is effectively a spline based smoothing</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_xyz : (UxVx3) array </span>
<span class="sd">        the input image to smooth</span>
<span class="sd">    S : scalar</span>
<span class="sd">        controls the extent of smoothing, the higher the more smoothing.    </span>
<span class="sd">    isrobust : bool</span>
<span class="sd">        if True, runs the filtering in robust mode </span>
<span class="sd">    pad_size : int</span>
<span class="sd">        if specified, pads the image by the given size else pads the image by replicating itself. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh_smooth : (UxVx3) array</span>
<span class="sd">        the smoothed output image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..Image_Functions.smoothn</span> <span class="kn">import</span> <span class="n">smoothn</span>

    <span class="k">if</span> <span class="n">pad_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pad the mesh..... </span>
        <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">unwrap_xyz</span><span class="p">,</span> <span class="n">unwrap_xyz</span><span class="p">,</span> <span class="n">unwrap_xyz</span><span class="p">])</span> <span class="c1"># this pad is correct. </span>
        <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">unwrap_xyz_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">unwrap_xyz_pad</span><span class="p">,</span>
                                    <span class="n">unwrap_xyz_pad</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unwrap_xyz_pad</span> <span class="o">=</span> <span class="n">pad_unwrap_params_3D_spherical</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad_size</span><span class="p">)</span>

    <span class="c1"># mesh_smooth_x,s,exitflag,Wtot = smoothn(unwrap_xyz_pad[...,0], s=S, isrobust=isrobust)</span>
    <span class="c1"># mesh_smooth_y,s,exitflag,Wtot = smoothn(unwrap_xyz_pad[...,1], s=S, isrobust=isrobust)</span>
    <span class="c1"># mesh_smooth_z,s,exitflag,Wtot = smoothn(unwrap_xyz_pad[...,2], s=S, isrobust=isrobust)</span>
    <span class="n">mesh_smooth</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">exitflag</span><span class="p">,</span><span class="n">Wtot</span> <span class="o">=</span> <span class="n">smoothn</span><span class="p">(</span><span class="n">unwrap_xyz_pad</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">isrobust</span><span class="o">=</span><span class="n">isrobust</span><span class="p">)</span>
    <span class="c1"># mesh_smooth = np.dstack([mesh_smooth_x, </span>
    <span class="c1">#                          mesh_smooth_y, </span>
    <span class="c1">#                          mesh_smooth_z])</span>

    <span class="k">if</span> <span class="n">pad_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_smooth</span> <span class="o">=</span> <span class="n">mesh_smooth</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">unwrap_xyz</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mesh_smooth</span> <span class="o">=</span> <span class="n">mesh_smooth</span><span class="p">[:,</span><span class="n">unwrap_xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">unwrap_xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_smooth</span> <span class="o">=</span> <span class="n">mesh_smooth</span><span class="p">[</span><span class="n">pad_size</span><span class="p">:</span><span class="o">-</span><span class="n">pad_size</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mesh_smooth</span> <span class="o">=</span> <span class="n">mesh_smooth</span><span class="p">[:,</span><span class="n">pad_size</span><span class="p">:</span><span class="o">-</span><span class="n">pad_size</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">mesh_smooth</span></div>


<div class="viewcode-block" id="impute_2D_spherical"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.impute_2D_spherical">[docs]</a><span class="k">def</span> <span class="nf">impute_2D_spherical</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">pad_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blank_pixels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Imputes an image with spherical boundary conditions using interpolation </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : (UxV) array </span>
<span class="sd">        the input image to impute with missing pixels indicated by np.isnan (by default)</span>
<span class="sd">    method : str</span>
<span class="sd">        interpolation method, one of the possible option specified in scipy.interpolate.griddata. Linear interpolation is used by default </span>
<span class="sd">    pad_size : int</span>
<span class="sd">        if specified, pads the image by the given size else pads the image by replicating itself fully</span>
<span class="sd">    blank : scalar</span>
<span class="sd">        if specified, the alternative pixel intensity used to label the pixels to be imputed. By default we use np.isnan</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_interp : (UxV) array</span>
<span class="sd">        the imputed image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">scinterpolate</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># prepad. </span>
    <span class="k">if</span> <span class="n">pad_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pad the mesh..... </span>
        <span class="n">img_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">])</span> <span class="c1"># this pad is correct. </span>
        <span class="n">img_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">img_pad</span><span class="p">,</span>
                             <span class="n">img_pad</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_pad</span> <span class="o">=</span> <span class="n">pad_unwrap_params_3D_spherical</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad_size</span><span class="p">)</span>

    <span class="n">YY</span><span class="p">,</span> <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">img_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">blank_pixels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">img_pad</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">img_pad</span><span class="o">==</span><span class="n">blank_pixels</span><span class="p">)</span> 
    
    <span class="n">YYXX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">YY</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span> 
                      <span class="n">XX</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="n">fill_interp</span> <span class="o">=</span> <span class="n">scinterpolate</span><span class="o">.</span><span class="n">griddata</span><span class="p">(</span><span class="n">YYXX</span><span class="p">,</span> 
                                         <span class="n">img_pad</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span> 
                                         <span class="p">(</span><span class="n">YY</span><span class="p">,</span> <span class="n">XX</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">pad_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fill_interp</span> <span class="o">=</span> <span class="n">fill_interp</span><span class="p">[</span><span class="n">M</span><span class="p">:</span><span class="o">-</span><span class="n">M</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># crop out the row</span>
        <span class="n">fill_interp</span> <span class="o">=</span> <span class="n">fill_interp</span><span class="p">[:,</span><span class="n">N</span><span class="p">:</span><span class="o">-</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># crop out the col</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fill_interp</span> <span class="o">=</span> <span class="n">fill_interp</span><span class="p">[</span><span class="n">pad_size</span><span class="p">:</span><span class="o">-</span><span class="n">pad_size</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">fill_interp</span> <span class="o">=</span> <span class="n">fill_interp</span><span class="p">[:,</span><span class="n">pad_size</span><span class="p">:</span><span class="o">-</span><span class="n">pad_size</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">fill_interp</span> </div>


<div class="viewcode-block" id="find_principal_axes_uv_surface"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface">[docs]</a><span class="k">def</span> <span class="nf">find_principal_axes_uv_surface</span><span class="p">(</span><span class="n">uv_coords</span><span class="p">,</span> <span class="n">pts_weights</span><span class="p">,</span> <span class="n">map_to_sphere</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ascending&#39;</span><span class="p">,</span> <span class="n">return_pts</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the principal axes of a uv parametrized surface with given pixel weights.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters </span>
<span class="sd">    ----------</span>
<span class="sd">    uv_coords : (UxVx3) array </span>
<span class="sd">        the input image specifying the uv unwrapped (x,y,z) surface to find the principal axis of in original Cartesian (x,y,z) space</span>
<span class="sd">    pts_weights : (UxV) array</span>
<span class="sd">        the positive weights at each pixel, specifying its relative importance in the computation of the principal axes </span>
<span class="sd">    map_to_sphere : bool</span>
<span class="sd">        if True, the unit sphere coordinate i.e. spherical parametrization of the uv grid is used instead of the actual (x,y,z) coordinate positions to compute principal axes. This enables geometry-independent computation useful for e.g. getting directional alignment based only on surface intensity</span>
<span class="sd">    sort : &#39;ascending&#39; or &#39;descending&#39;</span>
<span class="sd">        the sorting order of the eigenvectors in terms of the absolute value of the respective eigenvalues</span>
<span class="sd">    return_pts : bool</span>
<span class="sd">        if True, return the demeaned points used to compute the principal axes</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    w : (3,) array</span>
<span class="sd">        the sorted eigenvalues of the three principal eigenvectors</span>
<span class="sd">    v : (3,3) array    </span>
<span class="sd">        the sorted eigenvectors of the corresponding eigenvalues</span>
<span class="sd">    pts_demean : (UxVx3) array </span>
<span class="sd">        the demeaned points used for doing the principal components analysis</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity` : </span>
<span class="sd">        Equivalent for finding the principal eigenvectors when give a surface mesh of unordered points. </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">..Geometry</span> <span class="kn">import</span> <span class="n">geometry</span> <span class="k">as</span> <span class="n">geometry</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="n">uv_coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">uv_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pts_weights</span> <span class="o">=</span> <span class="n">pts_weights</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">map_to_sphere</span><span class="p">:</span>
        <span class="c1"># we replace the pts with that of the unit sphere (x,y,z) </span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">uv_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> 
        <span class="n">psi_theta_grid_ref</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">img_2_angles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sphere_from_img_angles</span><span class="p">(</span><span class="n">psi_theta_grid_ref</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">psi_theta_grid_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># demean </span>
        <span class="n">pts_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">-</span> <span class="n">pts_mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

    <span class="c1"># unweighted version. </span>
    <span class="n">pts_demean_</span> <span class="o">=</span> <span class="n">pts_demean</span> <span class="o">*</span> <span class="n">pts_weights</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pts_weights</span><span class="p">))</span>
    <span class="n">pts_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">pts_demean_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># 3x3 matrix #-&gt; expect symmetric. </span>

    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">pts_cov</span><span class="p">)</span>
    <span class="c1"># sort large to small. </span>
    <span class="k">if</span> <span class="n">sort</span><span class="o">==</span><span class="s1">&#39;descending&#39;</span><span class="p">:</span>
        <span class="n">w_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sort</span><span class="o">==</span><span class="s1">&#39;ascending&#39;</span><span class="p">:</span>
        <span class="n">w_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">w_sort</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="n">w_sort</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_pts</span><span class="p">:</span>
        <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts_demean</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">uv_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pts_demean</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> </div>


<span class="c1">##### unwrap_params_rotate, integrating the beltrami coefficient optimization. </span>
<div class="viewcode-block" id="unwrap_params_rotate_coords"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.unwrap_params_rotate_coords">[docs]</a><span class="k">def</span> <span class="nf">unwrap_params_rotate_coords</span><span class="p">(</span><span class="n">unwrap_params</span><span class="p">,</span> 
                                <span class="n">rot_matrix</span><span class="p">,</span> 
                                <span class="n">invert_transform</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> 
                                <span class="n">cast_uint8</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">optimize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">h_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> 
                                <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a (u,v) parametrization of an (x,y,z) surface. This function derives the corresponding (u,v) parametrization for an arbitrary rotation of the (x,y,z) surface by rotating the spherical parametrization and interpolating without needing to completely do a new spherical parametrization. </span>
<span class="sd">   </span>
<span class="sd">    Parameters </span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_params : (UxVx3) array </span>
<span class="sd">        the input image specifying the uv unwrapped (x,y,z) surface </span>
<span class="sd">    rot_matrix : (4x4) array</span>
<span class="sd">        the specified rotation given as a 4x4 homogeneous rotation matrix  </span>
<span class="sd">    invert_transform : bool</span>
<span class="sd">        if True, the rotation matrix is applied inverted to get the corresponding coordinates forming the new (u,v) parametrization. This should be set to true if the rotation_matrix is the forward transformation that rotates the current surface to the new surface.  </span>
<span class="sd">    method : str </span>
<span class="sd">        the interpolation method. Either of &#39;spline&#39; to use scipy.interpolate.RectBivariateSpline or one of those available for scipy.interpolate.RegularGridInterpolator</span>
<span class="sd">    optimize : bool</span>
<span class="sd">        if True, the aspect ratio of the image will be optimized to minimize metric distortion based on the Beltrami coefficient, see :func:`unwrap3D.Unzipping.unzip.beltrami_coeff_uv_opt` </span>
<span class="sd">    h_range : 2-tuple</span>
<span class="sd">        a list of aspect ratios to search for the optimal aspect ratio when optimize=True</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small number for numerical stability </span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    xy_rot : (M,N,2)</span>
<span class="sd">        the (u,v) coordinates of the input unwrap_params that form the new (u,v) of the rotated surface. The size (M,N) will be the same as input if optimize=False.</span>
<span class="sd">    unwrap_params_new : (M,N,3)</span>
<span class="sd">        the new uv unwrapped (x,y,z) surface coordinates denoting the rotated surface. </span>
<span class="sd">    h_opt : scalar</span>
<span class="sd">        the optimal aspect ratio found within the given ``h_range`` which minimizes the Beltrami coefficient, if ``optimize=True``. The new size is (U, int(h_opt*U), 3) </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">..Geometry</span> <span class="kn">import</span> <span class="n">geometry</span> <span class="k">as</span> <span class="n">geometry</span>
    <span class="kn">from</span> <span class="nn">..Image_Functions.image</span> <span class="kn">import</span> <span class="n">map_intensity_interp2</span>
    <span class="c1"># from LightSheet_Analysis.Geometry import meshtools</span>
    <span class="c1"># from LightSheet_Analysis.Geometry.geometry import compute_surface_distance_ref </span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1. define the uv grid of the reference sphere. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> 
    <span class="n">psi_theta_grid_ref</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">img_2_angles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2. define the reference xyz of the unit sphere for pullback. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sphere_xyz</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sphere_from_img_angles</span><span class="p">(</span><span class="n">psi_theta_grid_ref</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">psi_theta_grid_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">sphere_xyz_grid</span> <span class="o">=</span> <span class="n">sphere_xyz</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3. apply the inverse intended rotation matrix to the reference sphere. </span>
<span class="sd">        # rot_matrix is 4x4, so is just the inverse</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">invert_transform</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">T_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">T_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">sphere_xyz_grid_rot</span> <span class="o">=</span> <span class="n">T_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">sphere_xyz_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">sphere_xyz_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere_xyz_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">sphere_xyz_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))]))[:</span><span class="n">sphere_xyz_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">sphere_xyz_grid_rot</span> <span class="o">=</span> <span class="n">sphere_xyz_grid_rot</span><span class="o">.</span><span class="n">T</span>
    <span class="n">sphere_xyz_grid_rot</span> <span class="o">=</span> <span class="n">sphere_xyz_grid_rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sphere_xyz_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># this gives new (x,y,z) coordinates relating to the reference.</span>


    <span class="c1"># pull down now the transformed angles</span>
    <span class="n">psi_theta_grid_ref_rot</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">img_angles_from_sphere</span><span class="p">(</span><span class="n">sphere_xyz_grid_rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">sphere_xyz_grid_rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">psi_theta_grid_ref_rot</span> <span class="o">=</span> <span class="n">psi_theta_grid_ref_rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">psi_theta_grid_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1"># instead what we wdo is following https://github.com/henryseg/spherical_image_editing/blob/master/sphere_transforms_numpy.py</span>
    <span class="c1"># we turn the angles into x,y coordinates! then use normal rectangular interpolation !. </span>
    <span class="n">xy_rot</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">angles_2_img</span><span class="p">(</span><span class="n">psi_theta_grid_ref_rot</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="c1"># this is the new grid. </span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    4. we now do the reinterpolation of scalars. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># s is only used in the case of smoothing for spline based. </span>
    <span class="n">unwrap_params_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_intensity_interp2</span><span class="p">(</span><span class="n">xy_rot</span><span class="p">[</span><span class="o">...</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xy_rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">grid_shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">I_ref</span><span class="o">=</span><span class="n">unwrap_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">cast_uint8</span><span class="o">=</span><span class="n">cast_uint8</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
    <span class="n">unwrap_params_new</span> <span class="o">=</span> <span class="n">unwrap_params_new</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    5. we should add in the beltrami coefficient optimization for the new view. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
        <span class="n">h_opt</span><span class="p">,</span> <span class="n">unwrap_params_new</span> <span class="o">=</span> <span class="n">beltrami_coeff_uv_opt</span><span class="p">(</span><span class="n">unwrap_params_new</span><span class="p">,</span> <span class="n">h_range</span><span class="o">=</span><span class="n">h_range</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">apply_opt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># optimize and return this. </span>

        <span class="k">return</span> <span class="n">xy_rot</span><span class="p">,</span> <span class="n">unwrap_params_new</span><span class="p">,</span> <span class="n">h_opt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xy_rot</span><span class="p">,</span> <span class="n">unwrap_params_new</span></div>


<div class="viewcode-block" id="beltrami_coeff_uv_opt"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.beltrami_coeff_uv_opt">[docs]</a><span class="k">def</span> <span class="nf">beltrami_coeff_uv_opt</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">h_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">apply_opt</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find the optimal image aspect ratio to minimise the Beltrami coefficient which is a measure of metric distortion for a (u,v) parametrized (x,y,z) surface </span>

<span class="sd">    See https://en.wikipedia.org/wiki/Beltrami_equation </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface_uv_params : (UxVx3) array</span>
<span class="sd">        the input image specifying the uv unwrapped (x,y,z) surface </span>
<span class="sd">    h_range : 2-tuple</span>
<span class="sd">        specifies the [min, max] scaling factor of image width relative to height to search for the minimal Beltrami Coefficient      </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small number for numerical stability </span>
<span class="sd">    apply_opt : bool</span>
<span class="sd">        if True, additionally return the resized surface as a second output</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h_opt : scalar</span>
<span class="sd">        the optimal scaling factor within the specified h_range</span>
<span class="sd">    surface_uv_params_resize_opt : (U x W x 3)</span>
<span class="sd">        if apply_opt=True, the found aspect ratio is applied to the input image where the new width W is int(h_opt)*V. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fminbound</span>
    <span class="kn">import</span> <span class="nn">skimage.transform</span> <span class="k">as</span> <span class="nn">sktform</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">surface_uv_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">opt_score</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
        <span class="c1"># surface_unwrap_params_rot_resize = np.array([sktform.resize(surface_unwrap_params_rot[...,ch], (int(h*n),n), preserve_range=True) for ch in range(surface_unwrap_params_rot.shape[-1])])</span>
        <span class="n">surface_uv_params_resize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">m</span><span class="p">)),</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">surface_uv_params_resize</span> <span class="o">=</span> <span class="n">surface_uv_params_resize</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">beltrami_coeff</span> <span class="o">=</span> <span class="n">beltrami_coeff_uv</span><span class="p">(</span><span class="n">surface_uv_params_resize</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beltrami_coeff</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># using mean works. </span>

        <span class="k">return</span> <span class="n">score</span>

    <span class="n">h_opt</span> <span class="o">=</span> <span class="n">fminbound</span><span class="p">(</span><span class="n">opt_score</span><span class="p">,</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">if</span> <span class="n">apply_opt</span><span class="p">:</span>

        <span class="n">surface_uv_params_resize_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">],</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">h_opt</span><span class="o">*</span><span class="n">m</span><span class="p">)),</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">surface_uv_params_resize_opt</span> <span class="o">=</span> <span class="n">surface_uv_params_resize_opt</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">h_opt</span><span class="p">,</span> <span class="n">surface_uv_params_resize_opt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h_opt</span> </div>


<div class="viewcode-block" id="beltrami_coeff_uv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.beltrami_coeff_uv">[docs]</a><span class="k">def</span> <span class="nf">beltrami_coeff_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Computes the Beltrami coefficient, a measure of uniform metric distortion given a (u,v) parametrized (x,y,z) surface  </span>

<span class="sd">    See https://en.wikipedia.org/wiki/Beltrami_equation for mathematical definition</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface_uv_params : (U,V,3) array</span>
<span class="sd">        the input image specifying the uv unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small number for numerical stability </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mu : (U,V) array </span>
<span class="sd">        Complex array giving the Beltrami coefficient at each (u,v) pixel position</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://en.wikipedia.org/wiki/Beltrami_equation, return np.sum(np.abs(beltrami_coefficient(np.hstack([square_x[:,None],h*square_y[:,None]]),f,v))**2)</span>
    <span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># compute according to wikipedia.... </span>
    <span class="n">dS_du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> 
    <span class="n">dXdu</span> <span class="o">=</span> <span class="n">dS_du</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dYdu</span> <span class="o">=</span> <span class="n">dS_du</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dZdu</span> <span class="o">=</span> <span class="n">dS_du</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">dXdv</span> <span class="o">=</span> <span class="n">dS_dv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dYdv</span> <span class="o">=</span> <span class="n">dS_dv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dZdv</span> <span class="o">=</span> <span class="n">dS_dv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">E</span> <span class="o">=</span> <span class="n">dXdu</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dYdu</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dZdu</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">dXdv</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dYdv</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dZdv</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">dXdu</span><span class="o">*</span><span class="n">dXdv</span> <span class="o">+</span> <span class="n">dYdu</span><span class="o">*</span><span class="n">dYdv</span> <span class="o">+</span> <span class="n">dZdu</span><span class="o">*</span><span class="n">dZdv</span><span class="p">;</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span> <span class="o">-</span> <span class="n">G</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">E</span> <span class="o">+</span> <span class="n">G</span> <span class="o">+</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">G</span> <span class="o">-</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="n">eps</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">mu</span></div>


<div class="viewcode-block" id="gradient_uv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.gradient_uv">[docs]</a><span class="k">def</span> <span class="nf">gradient_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Jacobian of the uv parametrized (x,y,z) surface i.e. :math:`\partial S/\partial u` and `\partial S/\partial v`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface_uv_params : (UxVx3) array</span>
<span class="sd">        the input image giving the uv unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar </span>
<span class="sd">        small numerical value for numerical stability </span>
<span class="sd">    pad : bool </span>
<span class="sd">        if True, spherically pads by 1 pixel top and right to compute 1st order finite differences, if False using np.gradient to compute central differences</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dS_du : (UxVx3) array   </span>
<span class="sd">        :math:`\partial S/\partial u`, the change in the (x,y,z) surface coordinates in the direction of image u- axis (horizontal) </span>
<span class="sd">    dS_dv : (UxVx3) array </span>
<span class="sd">        :math:`\partial S/\partial v`, the change in the (x,y,z) surface coordinates in the direction of image v- axis (vertical) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if pad then wrap, else use the gradient. </span>
    <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
        <span class="n">surface_uv_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">surface_uv_params</span><span class="p">,</span> 
                                        <span class="n">surface_uv_params</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]])</span>
        <span class="n">surface_uv_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">surface_uv_params_</span><span class="p">,</span> 
                                        <span class="n">surface_uv_params_</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="kc">None</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">dS_du</span> <span class="o">=</span> <span class="n">surface_uv_params_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">surface_uv_params_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">surface_uv_params_</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">surface_uv_params_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dS_du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> 

    <span class="k">return</span> <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span></div>


<div class="viewcode-block" id="gradient_uv_depth"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.gradient_uv_depth">[docs]</a><span class="k">def</span> <span class="nf">gradient_uv_depth</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Jacobian of the topography (d,u,v) parametrized (x,y,z) volume i.e. :math:`\partial V/\partial d`, :math:`\partial V/\partial u` and :math:`\partial V/\partial v`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    depth_uv_params : (DxUxVx3) array</span>
<span class="sd">        the input volume image giving the topography (d,u,v) unwrapped (x,y,z) volume </span>
<span class="sd">    eps : scalar </span>
<span class="sd">        small numerical value for numerical stability </span>
<span class="sd">    pad : bool </span>
<span class="sd">        if True, spherically pads by 1 pixel depth, top and right to compute 1st order finite differences, if False use np.gradient to compute central differences</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dV_dd : (DxUxVx3) array</span>
<span class="sd">        :math:`\partial V/\partial d`, the change in the (x,y,z) volume coordinates in the direction of image d- axis (depth) </span>
<span class="sd">    dV_du : (DxUxVx3) array   </span>
<span class="sd">        :math:`\partial V/\partial u`, the change in the (x,y,z) volume coordinates in the direction of image u- axis (horizontal) </span>
<span class="sd">    dV_dv : (DxUxVx3) array </span>
<span class="sd">        :math:`\partial V/\partial v`, the change in the (x,y,z) volume coordinates in the direction of image v- axis (vertical) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if pad then wrap, else use the gradient. </span>
    <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
        <span class="n">depth_uv_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">depth_uv_params</span><span class="p">,</span> 
                                      <span class="n">depth_uv_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="kc">None</span><span class="p">,:]])</span>
        <span class="n">dV_dd</span> <span class="o">=</span> <span class="n">depth_uv_params_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">depth_uv_params_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># difference in d</span>

        <span class="n">depth_uv_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">depth_uv_params</span><span class="p">,</span> 
                                      <span class="n">depth_uv_params</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,:,</span><span class="kc">None</span><span class="p">,:]])</span>
        <span class="n">dV_du</span> <span class="o">=</span> <span class="n">depth_uv_params_</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">depth_uv_params_</span><span class="p">[:,:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># difference in d</span>

        <span class="n">depth_uv_params_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">depth_uv_params</span><span class="p">,</span> 
                                      <span class="n">depth_uv_params</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">][:,</span><span class="kc">None</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]])</span>
        <span class="n">dV_dv</span> <span class="o">=</span> <span class="n">depth_uv_params_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">depth_uv_params_</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dV_dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">dV_du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">dV_dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> 

    <span class="k">return</span> <span class="n">dV_dd</span><span class="p">,</span> <span class="n">dV_du</span><span class="p">,</span> <span class="n">dV_dv</span></div>


<div class="viewcode-block" id="conformality_error_uv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.conformality_error_uv">[docs]</a><span class="k">def</span> <span class="nf">conformality_error_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Quasi-conformal error for the uv parametrized (x,y,z) surface which is defined by the ratio of the largest to the smallest singular values of the Jacobian (see :func:`unwrap3D.Unzipping.unzip.gradient_uv`)</span>

<span class="sd">    .. math :: </span>
<span class="sd">        \mathcal{Q} = |\sigma_{max}| / |\sigma_{min}|</span>

<span class="sd">    where :math:`\sigma_{min}` and :math:`\sigma_{max}` denote the smaller and larger of the eigenvalues of :math:`J^T J`, where :math:`J` is the Jacobian matrix of the surface with respect to (u,v).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface_uv_params : (UxVx3) array</span>
<span class="sd">        the input image giving the uv unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar </span>
<span class="sd">        small numerical value for numerical stability </span>
<span class="sd">    pad : bool </span>
<span class="sd">        if True, spherically pads by 1 pixel top and right to compute 1st order finite differences, if False using np.gradient to compute central differences</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stretch_factor : (UxV) array   </span>
<span class="sd">        The quasi-conformal error at each pixel </span>
<span class="sd">    mean_stretch_factor : scalar</span>
<span class="sd">        The area weighted mean quasi-conformal error summarising the overall conformal error for the surface </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this is just the gradient area. </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">gradient_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>
    <span class="c1"># compile the jacobian.</span>
    <span class="n">Jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">dS_du</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                          <span class="n">dS_dv</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Jac</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># transpose. </span>
    
    <span class="n">Jac2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Jac</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">Jac</span><span class="p">)</span>
    <span class="n">stretch_eigenvalues</span><span class="p">,</span> <span class="n">stretch_eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Jac2</span><span class="p">)</span> <span class="c1"># compute J_T.dot(J) which is the first fundamental form.</span>

    <span class="n">stretch_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># since this was SVD decomposition. </span>

    <span class="c1"># compute the overall distortion factor, mean conformality error </span>
    <span class="n">areas3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dS_du</span><span class="p">,</span> 
                                      <span class="n">dS_dv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># # use the cross product</span>
    <span class="n">mean_stretch_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas3D</span><span class="o">*</span><span class="n">stretch_factor</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas3D</span><span class="p">))))</span>

    <span class="k">return</span> <span class="n">stretch_factor</span><span class="p">,</span> <span class="n">mean_stretch_factor</span></div>


<div class="viewcode-block" id="surface_area_uv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.surface_area_uv">[docs]</a><span class="k">def</span> <span class="nf">surface_area_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the total surface area of the unwrapped (u,v) parametrized surface using differential calculus. </span>

<span class="sd">    Assuming the parametrization is continuous, the differential element area for a pixel is the area of a differential rectangular element which can be written as a cross-product of the gradient vectors, </span>

<span class="sd">    .. math :: </span>
<span class="sd">        A_{pixel} &amp;= \left\|\frac{\partial S}{\partial u}\right\|\left\|\frac{\partial S}{\partial v}\right\| \\</span>
<span class="sd">                  &amp;= \left\|\frac{\partial S}{\partial u} \times \frac{\partial S}{\partial v}\right\|</span>

<span class="sd">    where :math:`\times` is the vector cross product</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface_uv_params : (UxVx3) array</span>
<span class="sd">        the input image giving the uv unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar </span>
<span class="sd">        small numerical value for numerical stability </span>
<span class="sd">    pad : bool </span>
<span class="sd">        if True, spherically pads by 1 pixel top and right to compute 1st order finite differences, if False using np.gradient to compute central differences</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dS_dudv : (UxV) array   </span>
<span class="sd">        The surface area of each pixel  </span>
<span class="sd">    total_dS_dudv : scalar</span>
<span class="sd">        the total summed surface area of all pixels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">gradient_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

    <span class="c1"># area of the original surface.</span>
    <span class="n">dS_dudv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dS_du</span><span class="p">,</span> 
                                      <span class="n">dS_dv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># # use the cross product</span>
    
    <span class="n">total_dS_dudv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dS_dudv</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dS_dudv</span><span class="p">,</span> <span class="n">total_dS_dudv</span></div>

<span class="c1"># add total volume for a topogarphy space. </span>
<div class="viewcode-block" id="volume_uv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.volume_uv">[docs]</a><span class="k">def</span> <span class="nf">volume_uv</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the total volume of the unwrapped (d,u,v) parametrized volume using differential calculus. </span>

<span class="sd">    Assuming the parametrization is continuous, the differential element element for a pixel is the volume of a differential parallelpiped element which can be written as a triple-product of the gradient vectors, </span>

<span class="sd">    .. math :: </span>
<span class="sd">        V_{pixel} &amp;= \left\|\frac{\partial V}{\partial d}\right\|\left\|\frac{\partial V}{\partial u}\right\|\left\|\frac{\partial V}{\partial v}\right\| \\</span>
<span class="sd">                  &amp;= \left\|\frac{\partial V}{\partial d} \cdot \frac{\partial V}{\partial u} \times \frac{\partial V}{\partial v} \right\|</span>

<span class="sd">    where :math:`\cdot` is the vector dot product and :math:`\times` is the vector cross product</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    depth_uv_params : (DxUxVx3) array</span>
<span class="sd">        the input image giving the topography (d,u,v) unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar </span>
<span class="sd">        small numerical value for numerical stability </span>
<span class="sd">    pad : bool </span>
<span class="sd">        if True, spherically pads by 1 pixel top and right to compute 1st order finite differences, if False using np.gradient to compute central differences</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dV : (DxUxV) array   </span>
<span class="sd">        The volume of each pixel  </span>
<span class="sd">    Volume : scalar</span>
<span class="sd">        the total summed volume of all pixels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">dV_dd</span><span class="p">,</span> <span class="n">dV_du</span><span class="p">,</span> <span class="n">dV_dv</span> <span class="o">=</span> <span class="n">gradient_uv_depth</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

    <span class="c1"># volume of the original surface.</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dV_du</span><span class="p">,</span> <span class="n">dV_dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dV_dd</span> <span class="o">*</span> <span class="n">dV</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dV</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># finally taking the magniude. </span>
    
    <span class="n">Volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dV</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dV</span><span class="p">,</span> <span class="n">Volume</span></div>

<div class="viewcode-block" id="area_distortion_uv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.area_distortion_uv">[docs]</a><span class="k">def</span> <span class="nf">area_distortion_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the area distortion given a (u,v) parameterized (x,y,z) surface, :math:`S`. The area distortion factor, :math:`\lambda` is defined as the normalised surface area measured in (u,v) divided by the normalised surface area in (x,y,z) </span>

<span class="sd">    .. math :: </span>
<span class="sd">        \lambda &amp;= \frac{dudv/\sum_{uv}dudv}{dS/\sum dS} \\</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    surface_uv_params : (UxVx3) array</span>
<span class="sd">        the input image giving the uv unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small number for numerical stability </span>
<span class="sd">    pad : bool</span>
<span class="sd">        if True, spherically pads by 1 pixel top and right to compute 1st order finite differences, if False using np.gradient to compute central differences</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this is just the gradient area. </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">gradient_uv</span><span class="p">(</span><span class="n">surface_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>
    <span class="c1"># area of the original surface.</span>
    <span class="n">dS_dudv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dS_du</span><span class="p">,</span> 
                                      <span class="n">dS_dv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># # use the cross product</span>
    <span class="n">dS_dudv</span> <span class="o">=</span> <span class="n">dS_dudv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dS_dudv</span><span class="p">)</span>

    <span class="c1"># area of a dudv element of unit area divided evenly. 1/(UV)</span>
    <span class="n">dudv</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dS_dudv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dS_dudv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">area_distortion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">dudv</span> <span class="o">/</span> <span class="n">dS_dudv</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">area_distortion</span></div>

<span class="c1"># add total volume distortion for a topogarphy space. </span>
<div class="viewcode-block" id="volume_distortion_duv"><a class="viewcode-back" href="../../../unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.volume_distortion_duv">[docs]</a><span class="k">def</span> <span class="nf">volume_distortion_duv</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the volume distortion given a (d,u,v) parameterized (x,y,z) surface, :math:`V`. The volume distortion factor, :math:`\lambda_{V}` is defined as the normalised volume measured in (d,u,v) divided by the normalised volume in (x,y,z) </span>

<span class="sd">    .. math :: </span>
<span class="sd">        \lambda_{V} &amp;= \frac{dd du dv/\sum_{duv}dd du dv}{dV/\sum dV} \\</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    depth_uv_params : (DxUxVx3) array</span>
<span class="sd">        the input image giving the (d,u,v) unwrapped (x,y,z) surface </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small number for numerical stability </span>
<span class="sd">    pad : bool</span>
<span class="sd">        if True, spherically pads by 1 pixel top and right to compute 1st order finite differences, if False using np.gradient to compute central differences</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this is just the gradient area. </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="n">dV_dd</span><span class="p">,</span> <span class="n">dV_du</span><span class="p">,</span> <span class="n">dV_dv</span> <span class="o">=</span> <span class="n">gradient_uv_depth</span><span class="p">(</span><span class="n">depth_uv_params</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>

    <span class="c1"># volume of the original surface.</span>
    <span class="n">dV_dddudv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dV_du</span><span class="p">,</span> <span class="n">dV_dv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dV_dddudv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dV_dd</span> <span class="o">*</span> <span class="n">dV_dddudv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dV_dddudv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dV_dddudv</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># finally taking the magniude. </span>

    <span class="n">dV_dddudv</span> <span class="o">=</span> <span class="n">dV_dddudv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dV_dddudv</span><span class="p">)</span> <span class="c1"># normalise the original surface volume. </span>
    <span class="c1"># area of a dddudv element of unit volume divided evenly. 1/(DUV)</span>
    <span class="n">dddudv</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dV_dddudv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dV_dddudv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dV_dddudv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># normalised current volume </span>

    <span class="n">volume_distortion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">dddudv</span> <span class="o">/</span> <span class="n">dV_dddudv</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">volume_distortion</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Y. Zhou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>