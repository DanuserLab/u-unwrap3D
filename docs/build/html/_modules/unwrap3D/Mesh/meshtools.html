<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>unwrap3D.Mesh.meshtools &mdash; u-Unwrap3D 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> u-Unwrap3D
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">u-Unwrap3D</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>unwrap3D.Mesh.meshtools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for unwrap3D.Mesh.meshtools</h1><div class="highlight"><pre>
<span></span>

<span class="kn">from</span> <span class="nn">..Geometry</span> <span class="kn">import</span> <span class="n">geometry</span> <span class="k">as</span> <span class="n">geom</span> 
<span class="kn">from</span> <span class="nn">..Unzipping</span> <span class="kn">import</span> <span class="n">unzip</span> <span class="k">as</span> <span class="n">uzip</span>


<div class="viewcode-block" id="read_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.read_mesh">[docs]</a><span class="k">def</span> <span class="nf">read_mesh</span><span class="p">(</span><span class="n">meshfile</span><span class="p">,</span> 
              <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
              <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
              <span class="n">keep_largest_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Wrapper around trimesh.load_mesh such that the mesh is read exactly with the same vertices and face indexes by default. Additionally we introduce a convenient flag to keep just the largest mesh component</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    meshfile : filepath</span>
<span class="sd">        input mesh of any common format, e.g. .obj, .ply, .dae, .stl, see https://trimsh.org/index.html</span>
<span class="sd">    process : bool</span>
<span class="sd">        If True, degenerate and duplicate faces will be removed immediately, and some functions will alter the mesh to ensure consistent results.</span>
<span class="sd">    validate : bool</span>
<span class="sd">        if True, Nan and Inf values will be removed immediately and vertices will be merged</span>
<span class="sd">    keep_largest_only : bool</span>
<span class="sd">        if True, keep only the largest connected component of the mesh, ignoring whether this is watertight or not </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh : trimesh.Trimesh or trimesh.Scene</span>
<span class="sd">        loaded mesh geometry</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">meshfile</span><span class="p">,</span> 
                             <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span> 
                             <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keep_largest_only</span><span class="p">:</span>
        <span class="n">mesh_comps</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_comps</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_comps</span><span class="p">])]</span>

    <span class="k">return</span> <span class="n">mesh</span> </div>

<div class="viewcode-block" id="create_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.create_mesh">[docs]</a><span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">faces</span><span class="p">,</span><span class="n">vertex_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">face_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Wrapper around trimesh.Trimesh to create a mesh given the vertices, faces and optionally vertex colors or face colors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices : (n_vertices,3) array </span>
<span class="sd">        the vertices of the mesh geometry </span>
<span class="sd">    faces : (n_faces,3) array</span>
<span class="sd">        the 0-indexed integer indices indicating how vertices are joined together to form a triangle element</span>
<span class="sd">    vertex_colors : (n_vertices,3) array</span>
<span class="sd">        if provided, an array of the RGB color values per vertex </span>
<span class="sd">    face_colors : (n_faces,3) array</span>
<span class="sd">        if provided, an array of the RGB color values per face </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh : trimesh.Trimesh or trimesh.Scene</span>
<span class="sd">        created mesh geometry with colors saved in mesh.visual.vertex_colors or mesh.visual.face_colors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">,</span>
                            <span class="n">faces</span><span class="o">=</span><span class="n">faces</span><span class="p">,</span> 
                            <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                            <span class="n">vertex_colors</span><span class="o">=</span><span class="n">vertex_colors</span><span class="p">,</span> 
                            <span class="n">face_colors</span><span class="o">=</span><span class="n">face_colors</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh</span> </div>

<div class="viewcode-block" id="submesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.submesh">[docs]</a><span class="k">def</span> <span class="nf">submesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">faces_sequence</span><span class="p">,</span>
            <span class="n">mesh_face_attributes</span><span class="p">,</span>
            <span class="n">repair</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">min_faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return a subset of a mesh. Function taken from the Trimesh library.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    mesh : Trimesh</span>
<span class="sd">        Source mesh to take geometry from</span>
<span class="sd">    faces_sequence : sequence (p,) int</span>
<span class="sd">        Indexes of mesh.faces</span>
<span class="sd">    only_watertight : bool</span>
<span class="sd">        Only return submeshes which are watertight.</span>
<span class="sd">    append : bool</span>
<span class="sd">        Return a single mesh which has the faces appended, if this flag is set, only_watertight is ignored</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    if append : Trimesh object</span>
<span class="sd">    else        list of Trimesh objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">def</span> <span class="nf">type_bases</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bases of the object passed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">collections</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">__base__</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># we do the hasattr as None/NoneType can be in the list of bases</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>

    
    <span class="k">def</span> <span class="nf">type_named</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to the type() builtin, but looks in class bases</span>
<span class="sd">        for named instance.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">        obj: object to look for class of</span>
<span class="sd">        name : str, name of class</span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        named class, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if obj is a member of the named class, return True</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">type_bases</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">base</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to extract class of name &#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
    
    <span class="c1"># evaluate generators so we can escape early</span>
    <span class="n">faces_sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">faces_sequence</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces_sequence</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># avoid nuking the cache on the original mesh</span>
    <span class="n">original_faces</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">original_vertices</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">visuals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># for reindexing faces</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_vertices</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">faces_sequence</span><span class="p">:</span>
        <span class="c1"># sanitize indices in case they are coming in as a set or tuple</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># regardless of type empty arrays are useless</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
            <span class="c1"># if passed a bool with no true continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="c1"># if fewer faces than minimum</span>
            <span class="k">if</span> <span class="n">min_faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_faces</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">min_faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_faces</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">original_faces</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># unique points. </span>

        <span class="c1"># redefine face indices from zero</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">unique</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">))</span>
        <span class="n">normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">face_normals</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">current</span><span class="p">])</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_vertices</span><span class="p">[</span><span class="n">unique</span><span class="p">])</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_face_attributes</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="n">visuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">face_subset</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># we use type(mesh) rather than importing Trimesh from base</span>
    <span class="c1"># to avoid a circular import</span>
    <span class="n">trimesh_type</span> <span class="o">=</span> <span class="n">type_named</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;Trimesh&#39;</span><span class="p">)</span>

    <span class="c1"># generate a list of Trimesh objects</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">trimesh_type</span><span class="p">(</span>
        <span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
        <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
        <span class="n">face_normals</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
        <span class="n">visual</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">),</span>
        <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span>
                                             <span class="n">faces</span><span class="p">,</span>
                                             <span class="n">normals</span><span class="p">,</span>
                                             <span class="n">visuals</span><span class="p">)]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">attributes</span></div>


<div class="viewcode-block" id="split_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.split_mesh">[docs]</a><span class="k">def</span> <span class="nf">split_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                <span class="n">mesh_face_attributes</span><span class="p">,</span> 
                <span class="n">adjacency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Split a mesh into multiple meshes from face connectivity taken from the Trimesh library. If only_watertight is true it will only return watertight meshes and will attempt to repair</span>
<span class="sd">    single triangle or quad holes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">    only_watertight: bool</span>
<span class="sd">        Only return watertight components</span>
<span class="sd">    adjacency : (n, 2) int</span>
<span class="sd">        Face adjacency to override full mesh</span>
<span class="sd">    engine : str or None</span>
<span class="sd">        Which graph engine to use</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    meshes : (m,) trimesh.Trimesh</span>
<span class="sd">        Results of splitting</span>
<span class="sd">    meshes_attributes : (m,d) attributes. </span>
<span class="sd">        associated splitted attributes. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">trimesh</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="c1"># used instead of trimesh functions in order to keep it consistent with the splitting of mesh attributes. </span>
    <span class="k">if</span> <span class="n">adjacency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adjacency</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">face_adjacency</span>

    <span class="c1"># if only watertight the shortest thing we can split has 3 triangles</span>
    <span class="k">if</span> <span class="n">only_watertight</span><span class="p">:</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">components</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span>
        <span class="n">edges</span><span class="o">=</span><span class="n">adjacency</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span>
        <span class="n">min_len</span><span class="o">=</span><span class="n">min_len</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

    <span class="n">meshes</span><span class="p">,</span> <span class="n">meshes_attributes</span> <span class="o">=</span> <span class="n">submesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">components</span><span class="p">,</span> 
                                    <span class="n">mesh_face_attributes</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">meshes</span><span class="p">,</span> <span class="n">meshes_attributes</span></div>


<div class="viewcode-block" id="decimate_resample_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.decimate_resample_mesh">[docs]</a><span class="k">def</span> <span class="nf">decimate_resample_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">remesh_samples</span><span class="p">,</span> <span class="n">predecimate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Downsample (decimate) and optionally resample the mesh to equilateral triangles. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh </span>
<span class="sd">    remesh_samples : 0-1</span>
<span class="sd">        fraction of the number of vertex points to target in size of the output mesh</span>
<span class="sd">    predecimate : bool</span>
<span class="sd">        if True, small edges are first collapsed using igl.decimate in the ``igl`` library</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        output mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this will for sure change the connectivity </span>
    <span class="kn">import</span> <span class="nn">pyacvd</span>
    <span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
    <span class="kn">import</span> <span class="nn">igl</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>

    <span class="k">if</span> <span class="n">predecimate</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">.9</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)))</span> <span class="c1"># there is bug? </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># have a check in here to prevent break down. </span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># why no good? </span>

    <span class="c1"># print(len(mesh.vertices))</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="c1"># convert to pyvista format. </span>
    <span class="n">clus</span> <span class="o">=</span> <span class="n">pyacvd</span><span class="o">.</span><span class="n">Clustering</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">clus</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">remesh_samples</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">)))</span> <span class="c1"># this guarantees a remesh is possible. </span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">clus</span><span class="o">.</span><span class="n">create_mesh</span><span class="p">()</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># we don&#39;t care. if change</span>
    <span class="c1"># print(mesh.is_watertight)</span>
    <span class="k">return</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="upsample_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.upsample_mesh">[docs]</a><span class="k">def</span> <span class="nf">upsample_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;inplane&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Upsample a given mesh using simple barycentric splittng (&#39;inplane&#39;) or using &#39;loop&#39;, which slightly smoothes the output </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    method : str</span>
<span class="sd">        one of &#39;inplane&#39; or &#39;loop&#39; allowed in igl.upsample</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh_out : trimesh.Trimesh</span>
<span class="sd">        output mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    inplane or loop</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span> 

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span><span class="s1">&#39;inplane&#39;</span><span class="p">:</span> 
        <span class="n">uv</span><span class="p">,</span> <span class="n">uf</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
        <span class="n">uv</span><span class="p">,</span> <span class="n">uf</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
   
    <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mesh_out</span> </div>


<div class="viewcode-block" id="upsample_mesh_and_vertex_vals"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.upsample_mesh_and_vertex_vals">[docs]</a><span class="k">def</span> <span class="nf">upsample_mesh_and_vertex_vals</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;inplane&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Upsample a given mesh using simple barycentric splittng (&#39;inplane&#39;) or using &#39;loop&#39;, which slightly smoothes the output and also reinterpolate any associated vertex values for the new mesh</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    vals : (n_vertices, n_features)</span>
<span class="sd">        vertex based values to also upsample</span>
<span class="sd">    method : str</span>
<span class="sd">        one of &#39;inplane&#39; or &#39;loop&#39; allowed in igl.upsample</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh_out : trimesh.Trimesh</span>
<span class="sd">        output mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    inplane only... vals is the same length as mesh vertices. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span><span class="s1">&#39;inplane&#39;</span><span class="p">:</span> 
        <span class="n">uv</span><span class="p">,</span> <span class="n">uf</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="c1"># get the new vertex and faces. </span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
        <span class="n">uv</span><span class="p">,</span> <span class="n">uf</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">loop</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="n">vals_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">uv</span><span class="p">),</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span> <span class="n">vals_new</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">max_ind_mesh_in</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">vals_new</span><span class="p">[:</span><span class="n">max_ind_mesh_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">old_new_edge_list</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">uf</span><span class="p">)</span> <span class="c1"># use the new faces. </span>
    <span class="n">old_new_edge_list</span> <span class="o">=</span> <span class="n">old_new_edge_list</span><span class="p">[</span><span class="n">old_new_edge_list</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">max_ind_mesh_in</span><span class="p">]</span>

    <span class="n">vals_new</span><span class="p">[</span><span class="n">old_new_edge_list</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">vals_new</span><span class="p">[</span><span class="n">old_new_edge_list</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="n">vals_new</span><span class="p">[</span><span class="n">old_new_edge_list</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">uf</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mesh_out</span><span class="p">,</span> <span class="n">vals_new</span></div>


<div class="viewcode-block" id="marching_cubes_mesh_binary"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.marching_cubes_mesh_binary">[docs]</a><span class="k">def</span> <span class="nf">marching_cubes_mesh_binary</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> 
                                <span class="n">presmooth</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> 
                                <span class="n">contourlevel</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> 
                                <span class="n">remesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                <span class="n">remesh_method</span><span class="o">=</span><span class="s1">&#39;pyacvd&#39;</span><span class="p">,</span> 
                                <span class="n">remesh_samples</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> 
                                <span class="n">remesh_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">predecimate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                <span class="n">min_mesh_size</span><span class="o">=</span><span class="mi">40000</span><span class="p">,</span> 
                                <span class="n">keep_largest_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                <span class="n">min_comp_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> 
                                <span class="n">split_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                <span class="n">upsamplemethod</span><span class="o">=</span><span class="s1">&#39;inplane&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Mesh an input binary volume using Marching Cubes algorithm with optional remeshing to improve mesh quality </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vol : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    presmooth : scalar</span>
<span class="sd">        pre Gaussian smoothing with the specified sigma to get a better marching cubes mesh. </span>
<span class="sd">    contourlevel : </span>
<span class="sd">        isolevel to extract the Marching cubes mesh</span>
<span class="sd">    remesh_method : str</span>
<span class="sd">        one of &#39;pyacvd&#39; or &#39;optimesh&#39;. </span>

<span class="sd">        &#39;pyacvd&#39; : str</span>
<span class="sd">            pyacvd uses voronoidal clustering i.e. kmeans clustering to produce a uniformly remeshing, see https://github.com/pyvista/pyacvd </span>
<span class="sd">        &#39;optimesh&#39; : str</span>
<span class="sd">            if selected, this method aims to relax the mesh vertices to a more uniform state, see https://github.com/meshpro/optimesh. This doesn&#39;t change the number of vertices and so effect of this is limited and there is some changing of the input shape</span>

<span class="sd">    remesh_samples : 0-1</span>
<span class="sd">        fraction of the number of vertex points to target in size of the output mesh</span>
<span class="sd">    remesh_params : dict</span>
<span class="sd">        only for remesh_method=&#39;optimesh&#39;. See :func:`unwrap3D.Parameters.params.optimesh_relaxation_config` for template of parameter settings</span>
<span class="sd">    predecimate : bool</span>
<span class="sd">        if True, collapse the small edges in the Marching Cubes output before remeshing</span>
<span class="sd">    min_mesh_size : int</span>
<span class="sd">        minimum number of vertices in the output mesh </span>
<span class="sd">    keep_largest_only : bool</span>
<span class="sd">        if True, check and keep only the largest mesh component </span>
<span class="sd">    min_comp_size : int</span>
<span class="sd">        if keep_largest_only=False, remesh=True and split_mesh=True, individual connected components of the mesh is checked and only those &gt; min_comp_size are kept. This is crucial if the mesh is to be remeshed. The remeshing fraction is applied to all components equally.  Without this check, there will be errors as some mesh components become zero.</span>
<span class="sd">    split_mesh : bool</span>
<span class="sd">        if True, runs connected component to filter out Marching cubes components that are too small (keep_largest_only=False) or keep only the largest (keep_largest_only=True) prior to remeshing        </span>
<span class="sd">    upsamplemethod : str</span>
<span class="sd">        one of &#39;inplane&#39; or &#39;loop&#39; allowed in igl.upsample. This is called to meet the minimum number of vertices in the final mesh as specified in ``min_mesh_size``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        output mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">gaussian</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">marching_cubes_lewiner</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">marching_cubes</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="k">if</span> <span class="n">presmooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">presmooth</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span> <span class="o">/</span> <span class="n">img</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># do this. </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">marching_cubes_lewiner</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">contourlevel</span><span class="p">,</span> <span class="n">allow_degenerate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">marching_cubes</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">contourlevel</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lewiner&#39;</span><span class="p">,</span> <span class="n">allow_degenerate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">split_mesh</span><span class="p">:</span>
        <span class="n">mesh_comps</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">keep_largest_only</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_comps</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_comps</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh_comps</span> <span class="o">=</span> <span class="p">[</span><span class="n">mm</span> <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">mesh_comps</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">min_comp_size</span><span class="p">]</span> <span class="c1"># keep a min_size else the remeshing doesn&#39;t work </span>
            <span class="c1"># combine_mesh_components</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">mesh_comps</span><span class="p">)</span>
        <span class="c1"># we need to recombine this</span>
        <span class="c1"># mesh = mesh_comps[np.argmax([len(cc.vertices) for cc in mesh_comps])]</span>
    <span class="k">if</span> <span class="n">remesh</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">remesh_method</span> <span class="o">==</span> <span class="s1">&#39;pyacvd&#39;</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">decimate_resample_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">remesh_samples</span><span class="p">,</span> <span class="n">predecimate</span><span class="o">=</span><span class="n">predecimate</span><span class="p">)</span>
            <span class="c1"># other remesh is optimesh which allows us to reshift the vertices (change the connections)</span>
        <span class="k">if</span> <span class="n">remesh_method</span> <span class="o">==</span> <span class="s1">&#39;optimesh&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">predecimate</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">.9</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)))</span> <span class="c1"># decimates up to the desired amount of faces? </span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mesh</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">mean_quality</span> <span class="o">=</span> <span class="n">relax_mesh</span><span class="p">(</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">relax_method</span><span class="o">=</span><span class="n">remesh_params</span><span class="p">[</span><span class="s1">&#39;relax_method&#39;</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">remesh_params</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">],</span> <span class="n">n_iters</span><span class="o">=</span><span class="n">remesh_params</span><span class="p">[</span><span class="s1">&#39;n_iters&#39;</span><span class="p">])</span> <span class="c1"># don&#39;t need the quality parameters. </span>
            <span class="c1"># print(&#39;mean mesh quality: &#39;, mean_quality)</span>

    <span class="n">mesh_check</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_mesh_size</span> <span class="c1"># mesh_min size is only applied here.!</span>
    <span class="k">while</span><span class="p">(</span><span class="n">mesh_check</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">upsample_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">upsamplemethod</span><span class="p">)</span>
        <span class="n">mesh_check</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_mesh_size</span>

    <span class="k">return</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="measure_props_trimesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.measure_props_trimesh">[docs]</a><span class="k">def</span> <span class="nf">measure_props_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">main_component</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute basic statistics and properties of a given mesh</span>

<span class="sd">    - is Convex : Yes/No</span>
<span class="sd">    - is Volume : Yes/No - is it closed such that a volume can be computed</span>
<span class="sd">    - is Watertight : Yes/No - is it closed such that a volume can be computed</span>
<span class="sd">    - orientability : Yes/No - can all faces be oriented the same way. Mobius strips and Klein bottles are non-orientable</span>
<span class="sd">    - Euler number : or Euler characteristic, :math:`\chi` #vertices - #edges + #faces</span>
<span class="sd">    - Genus : :math:`(2-2\chi)/2` if orientable or :math:`2-\chi` if nonorientable </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    main_component : bool </span>
<span class="sd">        if True, get the largest mesh component and compute statistics on this </span>
<span class="sd">    clean : bool</span>
<span class="sd">        if True, removes NaN and infs and degenerate and duplicate faces which may affect the computation of some of these statistics</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    props : dict</span>
<span class="sd">        A dictionary containing the metrics</span>

<span class="sd">        &#39;convex&#39; : bool</span>

<span class="sd">        &#39;volume&#39; : bool</span>

<span class="sd">        &#39;watertight&#39; : bool</span>

<span class="sd">        &#39;orientability&#39; : bool</span>

<span class="sd">        &#39;euler_number&#39; : scalar</span>

<span class="sd">        &#39;genus&#39; : scalar</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="c1"># check </span>
    <span class="c1"># make sure we do a split</span>
    <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> 
        <span class="n">mesh_</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">process</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mesh_comps</span> <span class="o">=</span> <span class="n">mesh_</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">mesh_comps</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_comps</span><span class="p">])]</span>
    
    <span class="n">props</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;convex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">is_convex</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">is_volume</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;watertight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">is_watertight</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;orientability&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">is_winding_consistent</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;euler_number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">euler_number</span>
    
    <span class="k">if</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">is_winding_consistent</span><span class="p">:</span>
        <span class="c1"># if orientable we can use the euler_number computation. see wolfram mathworld!. </span>
        <span class="n">genus</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">-</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;euler_number&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="c1"># euler = 2-2g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">genus</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">-</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;euler_number&#39;</span><span class="p">])</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;genus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genus</span>
    
    <span class="k">return</span> <span class="n">props</span></div>


<div class="viewcode-block" id="measure_triangle_props"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.measure_triangle_props">[docs]</a><span class="k">def</span> <span class="nf">measure_triangle_props</span><span class="p">(</span><span class="n">mesh_</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute statistics regarding the quality of the triangle faces</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh_ : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    clean : bool</span>
<span class="sd">        if True, removes NaN and infs and degenerate and duplicate faces which may affect the computation of some of these statistics</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    props : dict</span>
<span class="sd">        A dictionary containing the metrics</span>

<span class="sd">        &#39;min_angle&#39; : scalar</span>
<span class="sd">            minimum internal triangle angle of faces in degrees</span>
<span class="sd">        &#39;avg_angle&#39; : scalar</span>
<span class="sd">            mean internal triangle angle of faces in degrees</span>
<span class="sd">        &#39;max_angle&#39; : </span>
<span class="sd">            maximum internal triangle angle of faces in degrees</span>
<span class="sd">        &#39;std_dev angle&#39; : </span>
<span class="sd">            standard devation of internal triangle angle of faces in degrees</span>
<span class="sd">        &#39;min_quality&#39; : </span>
<span class="sd">            minimum triangle quality. triangle quality is measured as 2*inradius/circumradius</span>
<span class="sd">        &#39;avg_quality&#39; : </span>
<span class="sd">            mean triangle quality. triangle quality is measured as 2*inradius/circumradius</span>
<span class="sd">        &#39;max_quality&#39; : </span>
<span class="sd">            maximum triangle quality. triangle quality is measured as 2*inradius/circumradius</span>
<span class="sd">        &#39;quality&#39;</span>
<span class="sd">            per face quality. triangle quality is measured as 2*inradius/circumradius</span>
<span class="sd">        &#39;angles&#39; : </span>
<span class="sd">            all internal face angles </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">igl</span>
    
    <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> 
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">mesh_</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                <span class="n">mesh_</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">process</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="c1"># if use_igl:</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">internal_angles</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span>  <span class="mf">2.</span><span class="o">*</span> <span class="n">igl</span><span class="o">.</span><span class="n">inradius</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="n">igl</span><span class="o">.</span><span class="n">circumradius</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="c1"># 2 * inradius / circumradius</span>
            
    <span class="c1"># mesh_meshplex = meshplex.MeshTri(mesh.vertices, mesh.faces)</span>
    <span class="c1"># angles = mesh_meshplex.angles / np.pi * 180.</span>
    <span class="c1"># q = mesh_meshplex.q_radius_ratio</span>
    <span class="n">props</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;min_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;avg_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;max_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;std_dev_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;min_quality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;avg_quality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;max_quality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;quality&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles</span>
    
    <span class="k">return</span> <span class="n">props</span></div>

<div class="viewcode-block" id="PCA_rotate_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.PCA_rotate_mesh">[docs]</a><span class="k">def</span> <span class="nf">PCA_rotate_mesh</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh_contour_level</span><span class="o">=</span><span class="mf">.5</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute principal components of a given binary through extracting the surface mesh or a used specified surface mesh </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    binary : array</span>
<span class="sd">        input binary image </span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        a user-specified surface mesh</span>
<span class="sd">    mesh_contour_level : scalar</span>
<span class="sd">        if only a binary is provided Marching cubes is used to extract a surface mesh at the isolevel given by ``mesh_contour_level``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pca_model : scikit-learn PCA model instance</span>
<span class="sd">        a fitted princial components model for the mesh. see sklearn.decomposition.PCA for attributes</span>
<span class="sd">    mean_pts : (3,) array</span>
<span class="sd">        the centroid of the surface mesh with which points were demeaned prior to PCA</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">marching_cubes_lewiner</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># we don&#39;t have a given surface, instead we need to segment. </span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if use_surface:</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">marching_cubes_lewiner</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">mesh_contour_level</span><span class="p">)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     pts = np.argwhere(binary&gt;0)</span>
    <span class="c1">#     pts = np.vstack(pts)</span>
    <span class="n">barycenter</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="c1"># print(weights.shape)</span>
    <span class="c1"># print(barycenter.shape)</span>
    <span class="n">mean_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="p">(</span><span class="n">weights</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)))[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">barycenter</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">pts_</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">mean_pts</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="n">pca_model</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">pts_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pca_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">pts_</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pca_model</span><span class="p">,</span> <span class="n">mean_pts</span></div>


<div class="viewcode-block" id="voxelize_image_mesh_pts"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.voxelize_image_mesh_pts">[docs]</a><span class="k">def</span> <span class="nf">voxelize_image_mesh_pts</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">dilate_ksize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">erode_ksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">vol_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upsample_iters_max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a surface mesh, voxelises the mesh to create a closed binary volume to enable for exampled signed distance function comparison and for repairing small holes </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh </span>
<span class="sd">    pad : int </span>
<span class="sd">        integer isotropic pad to create a volume grid if vol_shape is not given </span>
<span class="sd">    dilate_ksize : int</span>
<span class="sd">        optional dilation of the voxelized volume with a ball kernel of specified radius to fill holes so that scipy.ndimage.morphology.binary_fill_holes will allow a complete volume to be otained</span>
<span class="sd">    erode_ksize : int</span>
<span class="sd">        optional erosion of the voxelized volume with a ball kernel of specified radius</span>
<span class="sd">    vol_shape : (m,n,l) tuple</span>
<span class="sd">        the size of the volume image to voxelize onto  </span>
<span class="sd">    upsample_iters_max : int </span>
<span class="sd">        the maximum number of recursive mesh subdivisions to achieve the target pitch </span>
<span class="sd">    pitch : scalar</span>
<span class="sd">        target side length of each voxel, the mesh will be recursively subdivided up to the maximum number of iterations specified by ``upsample_iters_max`` until this is met.</span>
<span class="sd">    </span>
<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    smooth_img_binary : (MxNxL) array </span>
<span class="sd">        binary volume image </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># works only for meshs from images. so all coordinates are positive. </span>
    <span class="c1"># this voxelizes the pts without need for an image. </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">binary_fill_holes</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    
    <span class="n">vv</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ff</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">vol_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># mesh_pts = mesh.vertices.copy() + 1</span>
        <span class="n">longest_edge_length</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="n">ff</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">longest_edge_length</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">dilate_ksize</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="c1"># print(factor)</span>
        <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;=</span> <span class="n">pitch</span> <span class="o">/</span> <span class="mf">2.</span> <span class="p">:</span>
            <span class="c1"># print(&#39;upsample&#39;)</span>
            <span class="c1"># # then we can&#39;t get a volume even if watertight. </span>
            <span class="n">upsample_iters</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">factor</span><span class="p">)))</span>
            <span class="c1"># print(upsample_iters)</span>
            <span class="n">upsample_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">upsample_iters</span><span class="p">,</span> <span class="n">upsample_iters_max</span><span class="p">])</span>
            <span class="n">vv</span><span class="p">,</span> <span class="n">ff</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">upsample_iters</span><span class="p">)</span>
        <span class="n">mesh_pts</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="n">ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># determine the boundaries. </span>
        <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">min_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mesh_pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">max_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mesh_pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># pad = int(np.min([min_x, min_y, min_z])) # auto determine the padding based on this. </span>
        <span class="c1"># new binary. </span>
        <span class="n">smooth_img_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">max_x</span><span class="p">)</span><span class="o">+</span><span class="n">pad</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_y</span><span class="p">)</span><span class="o">+</span><span class="n">pad</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_z</span><span class="p">)</span><span class="o">+</span><span class="n">pad</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># mesh_pts = mesh.vertices.copy() #+ .5</span>
        <span class="c1"># mesh_pts = mesh.vertices.copy() + 1</span>
        <span class="n">longest_edge_length</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="n">ff</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">longest_edge_length</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">dilate_ksize</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="k">if</span> <span class="n">factor</span> <span class="o">&gt;=</span> <span class="n">pitch</span> <span class="o">/</span> <span class="mf">2.</span> <span class="p">:</span>
            <span class="c1"># then we can&#39;t get a volume even if watertight. </span>
            <span class="n">upsample_iters</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">factor</span><span class="p">)))</span>
            <span class="n">upsample_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">upsample_iters</span><span class="p">,</span> <span class="n">upsample_iters_max</span><span class="p">])</span>
            <span class="n">vv</span><span class="p">,</span> <span class="n">ff</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">upsample_iters</span><span class="p">)</span>
        <span class="n">mesh_pts</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="n">ff</span><span class="p">)</span>
        <span class="n">smooth_img_binary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vol_shape</span><span class="p">)</span>

    <span class="n">smooth_img_binary</span><span class="p">[</span><span class="n">mesh_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                      <span class="n">mesh_pts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                      <span class="n">mesh_pts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">dilate_ksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smooth_img_binary</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">smooth_img_binary</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">dilate_ksize</span><span class="p">))</span>
    <span class="n">smooth_img_binary</span> <span class="o">=</span> <span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">smooth_img_binary</span><span class="p">)</span> <span class="c1"># since we dilated before to create a full mesh. we inturn must erode. </span>
    
    <span class="k">if</span> <span class="n">erode_ksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smooth_img_binary</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">smooth_img_binary</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">erode_ksize</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">smooth_img_binary</span> </div>


<div class="viewcode-block" id="area_normalize_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.area_normalize_mesh">[docs]</a><span class="k">def</span> <span class="nf">area_normalize_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">map_color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Normalize the mesh vertices by subtracting the centroid and dividing by the square root of the total surface area. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    map_color : bool </span>
<span class="sd">        if True, copy across the vertex and face colors to the new normalised mesh </span>
<span class="sd">    centroid : str</span>
<span class="sd">        specifies the method for computing the centroid of the mesh. If &#39;area&#39; the face area weighted centroid is computed from triangle barycenter. If &#39;points&#39; the centroid is computed from triangle barycenters with no weighting </span>
<span class="sd">    </span>
<span class="sd">    Returns </span>
<span class="sd">    ------- </span>
<span class="sd">    mesh_out : trimesh.Trimesh</span>
<span class="sd">        output normalized mesh </span>
<span class="sd">    (v_mean, v_out_scale) : ((3,) array, scalar)</span>
<span class="sd">        the computed centroid and scalar normalisation</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">centroid</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
        <span class="c1"># this uses barycenters. </span>
        <span class="n">area_weights_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> 
        <span class="n">v_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">area_weights_v</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_weights_v</span><span class="p">))</span> <span class="o">*</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">centroid</span> <span class="o">==</span> <span class="s1">&#39;points&#39;</span><span class="p">:</span>
        <span class="n">v_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 3*more barycenters</span>
    <span class="n">v_out</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v_mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="n">v_out_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
    <span class="n">v_out</span> <span class="o">=</span> <span class="n">v_out</span> <span class="o">/</span> <span class="n">v_out_scale</span>
    
    <span class="k">if</span> <span class="n">map_color</span><span class="p">:</span>
        <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">v_out</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">vertex_colors</span><span class="p">,</span> <span class="n">face_colors</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">face_colors</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">v_out</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mesh_out</span><span class="p">,</span> <span class="p">(</span><span class="n">v_mean</span><span class="p">,</span> <span class="n">v_out_scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="unit_sphere_normalize_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.unit_sphere_normalize_mesh">[docs]</a><span class="k">def</span> <span class="nf">unit_sphere_normalize_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">map_color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">centroid</span><span class="o">=</span><span class="s1">&#39;area&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Normalize the mesh vertices by direct projection onto the unit sphere by normalising the displacement vector relative to the centroid</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    map_color : bool </span>
<span class="sd">        if True, copy across the vertex and face colors to the new normalised mesh </span>
<span class="sd">    centroid : str</span>
<span class="sd">        specifies the method for computing the centroid of the mesh. If &#39;area&#39; the face area weighted centroid is computed from triangle barycenter. If &#39;points&#39; the centroid is computed from triangle barycenters with no weighting </span>
<span class="sd">    </span>
<span class="sd">    Returns </span>
<span class="sd">    ------- </span>
<span class="sd">    mesh_out : trimesh.Trimesh</span>
<span class="sd">        output normalized mesh </span>
<span class="sd">    (v_mean, v_out_scale) : ((3,) array, scalar)</span>
<span class="sd">        the computed centroid and scalar normalisation</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">centroid</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
        <span class="c1"># this uses barycenters. </span>
        <span class="n">area_weights_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> 
        <span class="n">v_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">area_weights_v</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_weights_v</span><span class="p">))</span> <span class="o">*</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">centroid</span> <span class="o">==</span> <span class="s1">&#39;points&#39;</span><span class="p">:</span>
        <span class="n">v_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 3*more barycenters</span>
    <span class="n">v_out</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v_mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="n">v_out_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v_out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v_out</span> <span class="o">=</span> <span class="n">v_out</span> <span class="o">/</span> <span class="n">v_out_scale</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">map_color</span><span class="p">:</span>
        <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">v_out</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vertex_colors</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">vertex_colors</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">v_out</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mesh_out</span><span class="p">,</span> <span class="p">(</span><span class="n">v_mean</span><span class="p">,</span> <span class="n">v_out_scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_uv_grid_tri_connectivity"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.get_uv_grid_tri_connectivity">[docs]</a><span class="k">def</span> <span class="nf">get_uv_grid_tri_connectivity</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Construct the vertex and faces indices to convert a (M,N,d) d-dimensional grid coordinates with spherical geometry to a triangle mesh where vertices=grid.ravel()[vertex_indices], faces=face_indices. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : (M,N) or (M,N,d) array</span>
<span class="sd">        input (u,v) image used to construct vertex and face indices for</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertex_indices_all : (N_all,3) array</span>
<span class="sd">        specifies the flattened indices in the grid to form the vertices of the triangle mesh</span>
<span class="sd">    triangles_all : </span>
<span class="sd">        specifies the flattened indices in the grid to form the faces of the triangle mesh </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid should be odd </span>
<span class="sd">    the first row is same point and degenerate. </span>
<span class="sd">    the last row is same point and degenerate. </span>

<span class="sd">    easier to build the vertex and face connectivity from scratch. in a non-degenerate way!.  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">interior_grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">img_grid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1"># img_grid_indices_interior = img_grid_indices[1:-1, :-1].copy()</span>
    <span class="n">img_grid_indices_interior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># set these as the new indices.</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">img_grid_indices_interior</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># print(m,n)</span>
    <span class="n">vertex_indices_interior</span>  <span class="o">=</span> <span class="p">(</span><span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="n">vertex_indices_north</span> <span class="o">=</span> <span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">vertex_indices_south</span> <span class="o">=</span> <span class="n">img_grid_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">vertex_indices_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">vertex_indices_interior</span><span class="p">,</span> 
                                    <span class="n">vertex_indices_north</span><span class="p">,</span> 
                                    <span class="n">vertex_indices_south</span><span class="p">])</span> <span class="c1"># get all the vertex indices. </span>
    
    <span class="c1"># build the interior grid periodic triangle connectivity. </span>
    <span class="n">img_grid_indices_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">img_grid_indices_interior</span><span class="p">,</span> 
                                       <span class="n">img_grid_indices_interior</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]])</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">img_grid_indices_main</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># squares_main = np.vstack([img_grid_indices_main[:m-2, :n-1].ravel(),</span>
    <span class="c1">#                           img_grid_indices_main[1:m-1, :n-1].ravel(), </span>
    <span class="c1">#                           img_grid_indices_main[1:m-1, 1:n].ravel(),</span>
    <span class="c1">#                           img_grid_indices_main[:m-2, 1:n].ravel()]).T    </span>
    <span class="n">squares_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices_main</span><span class="p">[:</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span><span class="p">,</span> <span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                              <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="n">img_grid_indices_main</span><span class="p">[:</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># trianglulate the square and this is indexed in terms of the uv grid. </span>
    <span class="n">squares_main_triangles</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">triangulate_quads</span><span class="p">(</span><span class="n">squares_main</span><span class="p">)</span>
    <span class="c1"># now add the triangles that connect to the poles. </span>
    <span class="n">triangles_north_pole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex_indices_interior</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])),</span> 
                                       <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> 
                                       <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="n">triangles_south_pole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>  <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span>
                                        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertex_indices_interior</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]))])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># compile all the triangles together. </span>
    <span class="n">triangles_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">squares_main_triangles</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">triangles_north_pole</span><span class="p">,</span>
                               <span class="n">triangles_south_pole</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="c1"># can determine the sign orientation using vector area. </span>
    <span class="c1"># implement triangle orientation check to check orientation consistency?</span>
    <span class="k">return</span> <span class="n">vertex_indices_all</span><span class="p">,</span> <span class="n">triangles_all</span> </div>


<div class="viewcode-block" id="build_img_2d_edges"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.build_img_2d_edges">[docs]</a><span class="k">def</span> <span class="nf">build_img_2d_edges</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;  Extract the 4-neighbor edge connectivity for a (M,N) 2D image, returning an array of the list of edge connections </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : (M,N) image</span>
<span class="sd">        input image of the width and height to get the edge connectivity between pixels</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e : (n_edges,2) array</span>
<span class="sd">        the list of unique edges specified in terms of the flattened indices in the grid. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">img_grid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                    <span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                    <span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">e3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                    <span class="n">img_grid_indices</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">e4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                    <span class="n">img_grid_indices</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">,</span><span class="n">e4</span><span class="p">])</span> <span class="c1"># these should be the upper triangular matrix. </span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">e</span> </div>

<div class="viewcode-block" id="get_inverse_distance_weight_grid_laplacian"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.get_inverse_distance_weight_grid_laplacian">[docs]</a><span class="k">def</span> <span class="nf">get_inverse_distance_weight_grid_laplacian</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_pts</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute a sparse grid Laplacian matrix for 2D image based on inverse weighting of edge lengths. This allows to take into account the length distortion of grid points constructed from 2D unwrapping  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : (M,N) image</span>
<span class="sd">        input image of the width and height to get the edge connectivity between pixels</span>
<span class="sd">    grid_pts : (M,N,d) image</span>
<span class="sd">        input image with which to compute edge lengths based on the Euclidean distance of the d-features. e.g. this could be the bijective (u,v) &lt;-&gt; (x,y,z) unwrapping parameters where d=3. </span>
<span class="sd">    alpha : scalar</span>
<span class="sd">        a shape factor that controls the inverse distance weights. In short, this is a small pseudo-distance added to measured distances to avoid division by zero or infs. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : (MxN,MxN) array</span>
<span class="sd">        the sparse grid Laplacian where edge connections factor into account the distance between ``grid_pts``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">normalize</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> 
    <span class="n">grid_pts_flat</span> <span class="o">=</span> <span class="n">grid_pts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">elist</span> <span class="o">=</span> <span class="n">build_img_2d_edges</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">dist_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grid_pts_flat</span><span class="p">[</span><span class="n">elist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">grid_pts_flat</span><span class="p">[</span><span class="n">elist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># make into a vertex edge distance matrix. </span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_pts_flat</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">dist_edges</span><span class="p">,</span> <span class="p">(</span><span class="n">elist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">elist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> 
                            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># make symmetric! # this is still not correct? # this should make symmetric!. </span>
    <span class="c1"># # D = spsparse.triu(D).tocsr()</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">)</span> <span class="c1"># should be computing the weights... </span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="c1"># make symmetric! </span>
    <span class="n">D</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="n">D</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="c1"># c.f. https://math.stackexchange.com/questions/4264675/handle-zero-in-inverse-distance-weighting</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="c1"># make symmetric! </span>

    <span class="c1"># to convert to laplacian we can simply do D - A. </span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="o">-</span> <span class="n">D</span> <span class="c1"># degree - adjacency matrix. </span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">L</span></div>


<span class="c1"># this version doesn&#39;t support mesh laplacian if using the corresponding 3D coordinates because the first row and last row maps to the same point and generates the triangles. - use the above triangle version. </span>
<div class="viewcode-block" id="get_uv_grid_quad_connectivity"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.get_uv_grid_quad_connectivity">[docs]</a><span class="k">def</span> <span class="nf">get_uv_grid_quad_connectivity</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">return_triangles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">):</span> 
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the quad and the triangle connectivity between pixels in a 2d grid with either spherical or no boundary conditions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : (M,N,d) image</span>
<span class="sd">        input image of the width and height to get the pixel connectivity, N must be odd if bounds=&#39;spherical&#39; due to the necessary rewrapping. </span>
<span class="sd">    return_triangles : bool</span>
<span class="sd">        if True, return in addition the triangle connectivity based on triangulation of the quad grid connectivity</span>
<span class="sd">    bounds : str</span>
<span class="sd">        string specifying the boundary conditions of the grid, either of &#39;spherical&#39; or &#39;none&#39;</span>

<span class="sd">        &#39;spherical&#39; : str</span>
<span class="sd">            this wraps the left to right side, pinches together the top and pinches together the bottom of the grid </span>
<span class="sd">        &#39;none&#39; : str</span>
<span class="sd">            this does no unwrapping and returns the grid connectivity of the image. This is the same as sklearn.feature_extraction.image.grid_to_graph</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    all_squares : (N_squares,4) array</span>
<span class="sd">        the 4-neighbor quad connectivity of flattened image indices</span>
<span class="sd">    all_squares_to_triangles : (2*N_squares,3) array</span>
<span class="sd">        the triangle connectivity of the flattened image indices. Each square splits into 2 triangles.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">img_grid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">bounds</span> <span class="o">==</span> <span class="s1">&#39;spherical&#39;</span><span class="p">:</span>

        <span class="n">img_grid_indices_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">,</span> <span class="n">img_grid_indices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]])</span>
        <span class="n">squares_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices_main</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                  <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                                  <span class="n">img_grid_indices_main</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                  <span class="n">img_grid_indices_main</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># then handle the top and bottom strips separately ... </span>
        <span class="n">img_grid_indices_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                          <span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">squares_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices_top</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">img_grid_indices_top</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                 <span class="n">img_grid_indices_top</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">img_grid_indices_top</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                                 <span class="n">img_grid_indices_top</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">img_grid_indices_top</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                 <span class="n">img_grid_indices_top</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">img_grid_indices_top</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
        
        <span class="n">img_grid_indices_bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">],</span> 
                                             <span class="n">img_grid_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">squares_bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices_bottom</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">img_grid_indices_bottom</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                    <span class="n">img_grid_indices_bottom</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">img_grid_indices_bottom</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                                    <span class="n">img_grid_indices_bottom</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">img_grid_indices_bottom</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                    <span class="n">img_grid_indices_bottom</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">img_grid_indices_bottom</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>

        
        <span class="n">all_squares</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">squares_main</span><span class="p">,</span> 
                                 <span class="n">squares_top</span><span class="p">,</span>
                                 <span class="n">squares_bottom</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">bounds</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">all_squares</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">img_grid_indices</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                 <span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> 
                                 <span class="n">img_grid_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                 <span class="n">img_grid_indices</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">all_squares</span> <span class="o">=</span> <span class="n">all_squares</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_triangles</span><span class="p">:</span>
        <span class="n">all_squares_to_triangles</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">triangulate_quads</span><span class="p">(</span><span class="n">all_squares</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">all_squares</span><span class="p">,</span> <span class="n">all_squares_to_triangles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_squares</span></div>


<div class="viewcode-block" id="parametric_mesh_constant_img_flow"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow">[docs]</a><span class="k">def</span> <span class="nf">parametric_mesh_constant_img_flow</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">external_img_gradient</span><span class="p">,</span> 
                                        <span class="n">niters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                        <span class="n">deltaL</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span> 
                                        <span class="n">step_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;implicit&#39;</span><span class="p">,</span> 
                                        <span class="n">robust_L</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                        <span class="n">mollify_factor</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                                        <span class="n">conformalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                        <span class="n">gamma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> 
                                        <span class="n">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                                        <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This function performs implicit Euler propagation of a 3D mesh with steps of constant ``step_size`` in the direction of an external image gradient specified by ``external_img_gradient``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh </span>
<span class="sd">    external_img_gradient : (MxNxLx3) array</span>
<span class="sd">        the 3D volumetric displacement field with x,y,z coordinates the last axis.</span>
<span class="sd">    niters : int</span>
<span class="sd">        the number of total steps</span>
<span class="sd">    deltaL : scalar</span>
<span class="sd">        a stiffness regularization constant for the conformalized mean curvature flow propagation </span>
<span class="sd">    step_size : scalar</span>
<span class="sd">        the multiplicative factor the image gradient is multipled with per iteration</span>
<span class="sd">    method : str</span>
<span class="sd">        one of &#39;implicit&#39; for implicit Euler or &#39;explicit&#39; for explicit Euler. &#39;implicit&#39; is slower but much more stable and results in mesh updates that minimize foldover and instabilities. &#39;explicit&#39; is unstable but fast.</span>
<span class="sd">    robust_L : bool</span>
<span class="sd">        if True, uses the robust Laplacian construction of Sharpe et al. [1]_. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</span>
<span class="sd">    mollify_factor : scalar</span>
<span class="sd">        the mollification factor used in the robust Laplacian. see https://github.com/nmwsharp/robust-laplacians-py</span>
<span class="sd">    conformalize : bool</span>
<span class="sd">        if True, uses the simplified conformalized mean curvature variant mesh propagation derived in the paper [2]_. If False, uses the normal active contours update which uses ``gamma``, ``alpha`` and ``beta`` parameters.</span>
<span class="sd">    gamma : scalar</span>
<span class="sd">        stability regularization parameter in the active contour</span>
<span class="sd">    alpha : scalar</span>
<span class="sd">        stiffness regularization parameters in the active contour</span>
<span class="sd">    beta : scalar</span>
<span class="sd">        bending regularization parameters in the active contour </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small constant for numerical stability </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Usteps : (n_vertices,3,n_iters+1) array</span>
<span class="sd">        the vertex positions of the mesh at every interation. The face connectivity of the mesh does not change. </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Sharp, Nicholas, and Keenan Crane. &quot;A laplacian for nonmanifold triangle meshes.&quot; Computer Graphics Forum. Vol. 39. No. 5. 2020.</span>
<span class="sd">    .. [2] c.f. Unwrapping paper.  </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="kn">from</span> <span class="nn">..Image_Functions</span> <span class="kn">import</span> <span class="n">image</span> <span class="k">as</span> <span class="n">image_fn</span> 

    <span class="n">vol_shape</span> <span class="o">=</span> <span class="n">external_img_gradient</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">robust_laplacian</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span> <span class="c1"># need to invert sign to be same convention as igl. </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    initialise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialise the save array. </span>
    <span class="n">Usteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">niters</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    propagation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">niters</span><span class="p">)):</span>

        <span class="n">U_prev</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="c1"># make a copy. </span>
        <span class="c1"># get the next image gradient</span>
        <span class="n">U_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">image_fn</span><span class="o">.</span><span class="n">map_intensity_interp3</span><span class="p">(</span><span class="n">U_prev</span><span class="p">,</span> 
                                                      <span class="n">grid_shape</span><span class="o">=</span><span class="n">vol_shape</span><span class="p">,</span> 
                                                      <span class="n">I_ref</span><span class="o">=</span><span class="n">external_img_gradient</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">])</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">U_grad</span> <span class="o">=</span> <span class="n">U_grad</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;explicit&#39;</span><span class="p">:</span>
            <span class="n">U_grad</span> <span class="o">=</span> <span class="n">U_grad</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">U_grad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="c1"># square this. </span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">U_prev</span> <span class="o">+</span> <span class="n">U_grad</span> <span class="o">*</span> <span class="n">step_size</span> <span class="c1">#update. </span>
            <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;implicit&#39;</span><span class="p">:</span>
            <span class="n">U_grad</span> <span class="o">=</span> <span class="n">U_grad</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">U_grad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">conformalize</span><span class="p">:</span>
                <span class="c1"># if ii ==0:</span>
                <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">robust_laplacian</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">U_prev</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">)</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">U_prev</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_BARYCENTRIC</span><span class="p">)</span> <span class="c1"># -&gt; this is the only matrix that doesn&#39;t degenerate.               </span>
                <span class="c1"># # implicit solve. </span>
                <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">deltaL</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="c1"># what happens when we invert? </span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U_prev</span> <span class="o">+</span> <span class="n">U_grad</span> <span class="o">*</span> <span class="n">step_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># construct the active contour version.</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">L</span>  <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">U_prev</span> <span class="o">+</span> <span class="n">U_grad</span> <span class="o">*</span> <span class="n">step_size</span>
            
            <span class="c1"># get the next coordinate by solving </span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># return all the intermediate steps. </span>
    <span class="k">return</span> <span class="n">Usteps</span></div>


<div class="viewcode-block" id="parametric_uv_unwrap_mesh_constant_img_flow"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.parametric_uv_unwrap_mesh_constant_img_flow">[docs]</a><span class="k">def</span> <span class="nf">parametric_uv_unwrap_mesh_constant_img_flow</span><span class="p">(</span><span class="n">uv_grid</span><span class="p">,</span> 
                                        <span class="n">external_img_gradient</span><span class="p">,</span> 
                                        <span class="n">niters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                        <span class="n">deltaL</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span> 
                                        <span class="n">surf_pts_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                        <span class="n">step_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">pad_dist</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;implicit&#39;</span><span class="p">,</span> 
                                        <span class="n">robust_L</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                        <span class="n">mollify_factor</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                                        <span class="n">conformalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This convenience function performs implicit Euler propagation of an open uv-parametrized 3D mesh with steps of constant ``step_size`` in the direction of an external image gradient specified by ``external_img_gradient``</span>

<span class="sd">    the uv-parametrization is closed before propagating in 3D (x,y,z) space</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uv_grid : (M,N,3) image</span>
<span class="sd">        input mesh as an image with xyz on the last dimension.</span>
<span class="sd">    external_img_gradient : (MxNxLx3) array</span>
<span class="sd">        the 3D volumetric displacement field with x,y,z coordinates the last axis.</span>
<span class="sd">    niters : int</span>
<span class="sd">        the number of total steps</span>
<span class="sd">    deltaL : scalar</span>
<span class="sd">        a stiffness regularization constant for the conformalized mean curvature flow propagation </span>
<span class="sd">    surf_pts_ref : (N,3) array </span>
<span class="sd">        if provided, this is a reference surface with which to automatically determine the niters when propagating the surface outwards to ensure the full reference shape is sampled in topography space.</span>
<span class="sd">    step_size : scalar</span>
<span class="sd">        the multiplicative factor the image gradient is multipled with per iteration</span>
<span class="sd">    pad_dist : int</span>
<span class="sd">        an additional fudge factor added to the automatically determined n_dist when surf_pts_ref is provided and n_dist is not user provided</span>
<span class="sd">    method : str</span>
<span class="sd">        one of &#39;implicit&#39; for implicit Euler or &#39;explicit&#39; for explicit Euler. &#39;implicit&#39; is slower but much more stable and results in mesh updates that minimize foldover and instabilities. &#39;explicit&#39; is unstable but fast.</span>
<span class="sd">    robust_L : bool</span>
<span class="sd">        if True, uses the robust Laplacian construction of Sharpe et al. [1]_. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</span>
<span class="sd">    mollify_factor : scalar</span>
<span class="sd">        the mollification factor used in the robust Laplacian. see https://github.com/nmwsharp/robust-laplacians-py</span>
<span class="sd">    conformalize : bool</span>
<span class="sd">        if True, uses the simplified conformalized mean curvature variant mesh propagation derived in the paper [2]_. If False, uses the normal active contours update which uses ``gamma``, ``alpha`` and ``beta`` parameters.</span>
<span class="sd">    gamma : scalar</span>
<span class="sd">        stability regularization parameter in the active contour</span>
<span class="sd">    alpha : scalar</span>
<span class="sd">        stiffness regularization parameters in the active contour</span>
<span class="sd">    beta : scalar</span>
<span class="sd">        bending regularization parameters in the active contour </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small constant for numerical stability </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Usteps_out_rec : (niters+1,M,N,3) array</span>
<span class="sd">        the vertex positions of the mesh for every interation for every pixel position</span>

<span class="sd">    See Also </span>
<span class="sd">    --------</span>
<span class="sd">    :func:`unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow` : </span>
<span class="sd">        the propagation for a general 3D mesh</span>
<span class="sd">    :func:`unwrap3D.Unzipping.unzip.prop_ref_surface` : </span>
<span class="sd">        the equivalent for explicit Euler propagation using the uv-based image coordinates without closing the mesh </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Sharp, Nicholas, and Keenan Crane. &quot;A laplacian for nonmanifold triangle meshes.&quot; Computer Graphics Forum. Vol. 39. No. 5. 2020.</span>
<span class="sd">    .. [2] c.f. Unwrapping paper.  </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    convert the uv image into a trimesh object and prop this with some conformal regularization in one function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="kn">from</span> <span class="nn">..Unzipping</span> <span class="kn">import</span> <span class="n">unzip_new</span> <span class="k">as</span> <span class="n">uzip</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>

    <span class="n">vol_shape</span> <span class="o">=</span> <span class="n">external_img_gradient</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the UV mesh connectivity. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">uv_connectivity_verts</span><span class="p">,</span> <span class="n">uv_connectivity_tri</span> <span class="o">=</span> <span class="n">get_uv_grid_tri_connectivity</span><span class="p">(</span><span class="n">uv_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">uv_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="n">uv_connectivity_verts</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">uv_connectivity_tri</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">mesh_tri</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                               <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> 
                               <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">trimesh</span><span class="o">.</span><span class="n">repair</span><span class="o">.</span><span class="n">fix_winding</span><span class="p">(</span><span class="n">mesh_tri</span><span class="p">)</span> <span class="c1"># fix any orientation issues. </span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    determine the propagation distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># infer the number of dists to step for from the reference if not prespecified. </span>
    <span class="k">if</span> <span class="n">niters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">unwrap_params_ref_flat</span> <span class="o">=</span> <span class="n">uv_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">uv_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># infer the maximum step size so as to cover the initial otsu surface.</span>
        <span class="n">mean_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">unwrap_params_ref_flat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># # more robust to do an ellipse fit. ? =&gt; doesn&#39;t seem so... seems best to take the extremal point -&gt; since we should have a self-similar shape. </span>
        <span class="c1"># unwrap_params_fit_major_len = np.max(np.linalg.eigvalsh(np.cov((unwrap_params_ref_flat-mean_pt[None,:]).T))); unwrap_params_fit_major_len=np.sqrt(unwrap_params_fit_major_len)</span>
        <span class="c1"># surf_ref_major_len = np.max(np.linalg.eigvalsh(np.cov((surf_pts_ref-mean_pt[None,:]).T))); surf_ref_major_len = np.sqrt(surf_ref_major_len)</span>
        <span class="n">mean_dist_unwrap_params_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unwrap_params_ref_flat</span><span class="o">-</span><span class="n">mean_pt</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">mean_surf_pts_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">surf_pts_ref</span><span class="o">-</span><span class="n">mean_pt</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c1"># strictly should do an ellipse fit... </span>

        <span class="n">niters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mean_surf_pts_ref</span><span class="o">-</span><span class="n">mean_dist_unwrap_params_ref</span><span class="p">))</span>
        <span class="n">niters</span> <span class="o">=</span> <span class="n">niters</span> <span class="o">+</span> <span class="n">pad_dist</span> <span class="c1"># this is in pixels</span>
        <span class="n">niters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">niters</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">step_size</span><span class="p">))))</span> <span class="c1"># so if we take 1./2 step then we should step 2*</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;auto_infer_prop_distance&#39;</span><span class="p">,</span> <span class="n">niters</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----&#39;</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Do the propagation wholly with this watertight mesh. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Usteps_out</span> <span class="o">=</span> <span class="n">parametric_mesh_constant_img_flow</span><span class="p">(</span><span class="n">mesh_tri</span><span class="p">,</span> 
                                                    <span class="n">external_img_gradient</span><span class="o">=</span><span class="n">external_img_gradient</span><span class="p">,</span> 
                                                    <span class="n">niters</span><span class="o">=</span><span class="n">niters</span><span class="p">,</span> 
                                                    <span class="n">deltaL</span><span class="o">=</span><span class="n">deltaL</span><span class="p">,</span> 
                                                    <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span> 
                                                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                    <span class="n">robust_L</span><span class="o">=</span><span class="n">robust_L</span><span class="p">,</span> 
                                                    <span class="n">conformalize</span><span class="o">=</span><span class="n">conformalize</span><span class="p">,</span> 
                                                    <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> 
                                                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> 
                                                    <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> 
                                                    <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>

    <span class="n">Usteps_out_rec</span> <span class="o">=</span> <span class="n">Usteps_out</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">uv_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">uv_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Usteps_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Usteps_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">Usteps_out_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Usteps_out_rec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> 
                               <span class="n">Usteps_out_rec</span><span class="p">,</span> 
                               <span class="n">Usteps_out_rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]])</span>
    <span class="n">Usteps_out_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Usteps_out_rec</span><span class="p">,</span> 
                               <span class="n">Usteps_out_rec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]])</span>

    <span class="c1"># return all the intermediate steps. </span>
    <span class="k">return</span> <span class="n">Usteps_out_rec</span> <span class="c1"># return the propagated out mesh. </span></div>


<div class="viewcode-block" id="area_distortion_flow_relax_sphere"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.area_distortion_flow_relax_sphere">[docs]</a><span class="k">def</span> <span class="nf">area_distortion_flow_relax_sphere</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> 
                                      <span class="n">mesh_orig</span><span class="p">,</span> 
                                      <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                                      <span class="n">smooth_iters</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  
                                      <span class="n">delta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                                      <span class="n">stepsize</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span> 
                                      <span class="n">conformalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">flip_delaunay</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">robust_L</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">mollify_factor</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                                      <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span>
                                      <span class="n">debugviz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This function relaxes the area distortion of a spherical mesh by advecting vertex coordinates whilst maintaining the spherical geometry. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input unit spherical mesh to relax</span>
<span class="sd">    mesh_orig : trimesh.Trimesh </span>
<span class="sd">        the input original geometric mesh whose vertices correspond 1 to 1 with vertices of the spherical mesh. This is used to compute the area distortion per iteration</span>
<span class="sd">    max_iter : int</span>
<span class="sd">        the number of iterations relaxation will occur. The function may exit early if the mesh becomes unable to support further relaxation. A collapsed mesh will return vertices that are all np.nan</span>
<span class="sd">    smooth_iters : int</span>
<span class="sd">        if &gt; 0, the number of Laplacian smoothing to smooth the per vertex area distortion </span>
<span class="sd">    delta : scalar</span>
<span class="sd">        a stiffness constant of the mesh. it used to ensure maintenance of relative topology during advection</span>
<span class="sd">    stepsize : scalar</span>
<span class="sd">        the stepsize in the direction of steepest descent of area distortion. smaller steps can improve stability and precision but with much slower convergence</span>
<span class="sd">    conformalize : bool</span>
<span class="sd">        if True, uses the initial Laplacian without recomputing the Laplacian. This is a very severe penalty and stops area relaxation flow without reducing ``delta``. In general set this as False since relaxing area is in opposition to minimizing conformal error. </span>
<span class="sd">    flip_delaunay : bool</span>
<span class="sd">        if True, flip triangles during advection. On the sphere we find this slows flow, affects barycentric interpolation and is generated not required. This option requires the ``meshplex`` library</span>
<span class="sd">    robust_L : bool</span>
<span class="sd">        if True, uses the robust Laplacian construction of Sharpe et al. [1]_. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</span>
<span class="sd">    mollify_factor : scalar</span>
<span class="sd">        the mollification factor used in the robust Laplacian. see https://github.com/nmwsharp/robust-laplacians-py</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small constant for numerical stability </span>
<span class="sd">    debugviz : bool</span>
<span class="sd">        if True, a histogram of the area distortion is plotted per iteration to check if the flow is working properly. The area distortion is plotted as log(distortion) and so should move towards a peak of 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v_steps : list of (n_vertices, 3) array</span>
<span class="sd">        the vertex position at every iteration </span>
<span class="sd">    f_steps : list of (n_faces, 3) array</span>
<span class="sd">        the face connectivity at every iteration. This will be the same for all timepoints unless flip_delaunay=True</span>
<span class="sd">    area_distortion_iter : list</span>
<span class="sd">        the area distortion factor per face computed as area_original/area_sphere for every timepoint. </span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Sharp, Nicholas, and Keenan Crane. &quot;A laplacian for nonmanifold triangle meshes.&quot; Computer Graphics Forum. Vol. 39. No. 5. 2020.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="c1"># import meshplex</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">robust_laplacian</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span> <span class="c1"># need to invert sign to be same convention as igl. </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>

    <span class="n">area_distortion_iter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">v_steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="n">f_steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)):</span>
        
        <span class="k">try</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">conformalize</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
                    <span class="n">L</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">);</span> <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">;</span> <span class="c1"># this must be computed. # if not... then no growth -&gt; flow must change triangle shape!. </span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_BARYCENTRIC</span><span class="p">)</span>

            <span class="c1"># # compute the area distortion of the face -&gt; having normalized for surface area. -&gt; this is because the sphere minimise the surface area. -&gt; guaranteeing positive. </span>

            <span class="c1"># which is correct? </span>
            <span class="c1"># why we need to use the original connectivity? </span>
            <span class="c1"># area_distortion_mesh = igl.doublearea(mesh_orig.vertices/np.sqrt(np.nansum(igl.doublearea(mesh_orig.vertices,mesh_orig.faces)*.5)), mesh_orig.faces) / igl.doublearea(v/np.sqrt(np.nansum(igl.doublearea(v,f)*.5)), f) # this is face measure!. and the connectivity is allowed to change! during evolution !. </span>
            <span class="n">area_distortion_mesh</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">mesh_orig</span><span class="o">.</span><span class="n">vertices</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">mesh_orig</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)),</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)),</span> <span class="n">f</span><span class="p">)</span> <span class="c1"># this is face measure!. and the connectivity is allowed to change! during evolution !. </span>
            <span class="c1"># area_distortion_mesh = area_distortion(mesh_orig.vertices,f, v)</span>
            <span class="c1"># area_distortion_mesh = area_distortion(mesh_orig.vertices)</span>
            <span class="c1"># area_distortion_iter.append(area_distortion_mesh) # append this. </span>
            <span class="c1"># push to vertex. </span>
            <span class="n">area_distortion_mesh_vertex</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> 
                                                                    <span class="n">f</span><span class="p">,</span> 
                                                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">area_distortion_mesh</span><span class="p">,</span><span class="n">area_distortion_mesh</span><span class="p">,</span><span class="n">area_distortion_mesh</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
        
            <span class="c1"># smooth ... </span>
            <span class="k">if</span> <span class="n">debugviz</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">area_distortion_mesh_vertex</span><span class="p">))</span> <span class="c1"># why no change? </span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">smooth_iters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">smooth_area_distortion_mesh_vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">area_distortion_mesh_vertex</span><span class="p">,</span><span class="n">area_distortion_mesh_vertex</span><span class="p">,</span><span class="n">area_distortion_mesh_vertex</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="c1"># smooth this instead of the gradient. </span>

                <span class="k">for</span> <span class="n">iter_ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">smooth_iters</span><span class="p">):</span>
                    <span class="n">smooth_area_distortion_mesh_vertex</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">per_vertex_attribute_smoothing</span><span class="p">(</span><span class="n">smooth_area_distortion_mesh_vertex</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="c1"># seems to work.</span>
                <span class="n">area_distortion_mesh_vertex</span> <span class="o">=</span> <span class="n">smooth_area_distortion_mesh_vertex</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        
            <span class="c1"># compute the gradient. </span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> 
                         <span class="n">f</span><span class="p">)</span>

            <span class="c1"># if method == &#39;Kazhdan2019&#39;:</span>
            <span class="c1"># compute the vertex advection gradient.</span>
            <span class="n">gA</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">area_distortion_mesh_vertex</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span> 
            <span class="c1"># scale by the edge length.</span>
            <span class="n">gu_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gA</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">max_size</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">avg_edge_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">gu_mag</span><span class="p">)</span> <span class="c1"># if divide by median less good. </span>
            
            <span class="n">vA</span> <span class="o">=</span> <span class="n">max_size</span><span class="o">*</span><span class="n">gA</span> <span class="c1"># this is vector. </span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
            <span class="c1"># Vvertex = Vvertex - np.nansum(v*normal, axis=-1)[:,None]*normal # this projection actually makes it highly unstable? </span>
            <span class="n">vA_vertex</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> 
                                                  <span class="n">f</span><span class="p">,</span> <span class="n">vA</span><span class="p">)</span>
            <span class="n">vA_vertex</span> <span class="o">=</span> <span class="n">vA_vertex</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">vA_vertex</span><span class="o">*</span><span class="n">normal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">normal</span> <span class="c1"># this seems necessary... </span>

            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            advection step </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">delta</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>

            <span class="c1"># if adaptive_step:</span>
            <span class="c1">#     v = spsparse.linalg.spsolve(S, m.dot(v + scale_factor * stepsize * vA_vertex))</span>
            <span class="c1"># else:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">stepsize</span> <span class="o">*</span> <span class="n">vA_vertex</span><span class="p">))</span>
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            rescale and reproject back to normal</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)</span> <span class="c1">#total area. </span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">((</span><span class="mf">0.5</span><span class="o">*</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># this is just weighted centroid</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> 
            <span class="c1"># sphericalize </span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="c1"># forces sphere.... topology.... relaxation. </span>

            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            flip delaunay ? or use optimesh refine? -&gt; to improve triangle quality? </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">flip_delaunay</span><span class="p">:</span>

                <span class="kn">import</span> <span class="nn">meshplex</span>
                <span class="c1"># this clears out the overlapping. is this necessary</span>
                <span class="n">mesh_out</span> <span class="o">=</span> <span class="n">meshplex</span><span class="o">.</span><span class="n">MeshTri</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                <span class="n">mesh_out</span><span class="o">.</span><span class="n">flip_until_delaunay</span><span class="p">()</span>
            
                <span class="c1"># update v and f!</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">mesh_out</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">mesh_out</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="s1">&#39;points&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 

            <span class="c1"># update. </span>
            <span class="n">v_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">f_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">area_distortion_iter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area_distortion_mesh</span><span class="p">)</span> <span class="c1"># append this. </span>

        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># if error then get out quickly. </span>
            <span class="k">return</span> <span class="n">v_steps</span><span class="p">,</span> <span class="n">f_steps</span><span class="p">,</span> <span class="n">area_distortion_iter</span>

    <span class="k">return</span> <span class="n">v_steps</span><span class="p">,</span> <span class="n">f_steps</span><span class="p">,</span> <span class="n">area_distortion_iter</span></div>



<div class="viewcode-block" id="area_distortion_flow_relax_disk"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.area_distortion_flow_relax_disk">[docs]</a><span class="k">def</span> <span class="nf">area_distortion_flow_relax_disk</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_orig</span><span class="p">,</span> 
                                    <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                                    <span class="c1"># smooth_iters=5,  </span>
                                    <span class="n">delta_h_bound</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                                    <span class="n">stepsize</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span> 
                                    <span class="n">flip_delaunay</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1"># do this in order to dramatically improve flow!. </span>
                                    <span class="n">robust_L</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># use the robust laplacian instead of cotmatrix - slows flow. </span>
                                    <span class="n">mollify_factor</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                                    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
                                    <span class="n">lam</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span> 
                                    <span class="n">debugviz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">debugviz_tri</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This function relaxes the area distortion of a mesh with disk topology i.e. a disk, square or rectangle mesh by advecting inner vertex coordinates to minimise area distortion. </span>
<span class="sd">    </span>
<span class="sd">    The explicit Euler scheme of [1]_ is used. Due to the numerical instability of such a scheme, the density of mesh vertices and the stepsize constrains the full extent of relaxation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input disk, square or rectangle mesh to relax. The first coordinate of all the vertices, i.e. mesh.vertices[:,0] should be uniformly set to a constant e.g. 0 to specify a 2D mesh</span>
<span class="sd">    mesh_orig : trimesh.Trimesh </span>
<span class="sd">        the input original geometric mesh whose vertices correspond 1 to 1 with vertices of the input mesh. This is used to compute the area distortion per iteration    </span>
<span class="sd">    delta_h_bound : scalar</span>
<span class="sd">        the maximum value of the absolute area difference between original and the relaxing mesh. This constrains the maximum gradient difference, avoiding updating local areas too fast which will then destroy local topology. </span>
<span class="sd">    stepsize : scalar</span>
<span class="sd">        the stepsize in the direction of steepest descent of area distortion. smaller steps can improve stability and precision but with much slower convergence</span>
<span class="sd">    flip_delaunay : bool</span>
<span class="sd">        if True, flip triangles during advection. We find this is important with the explicit Euler scheme adopted here to ensure correct topology and ensure fast relaxation.</span>
<span class="sd">    robust_L : bool</span>
<span class="sd">        if True, uses the robust Laplacian construction of Sharpe et al. [2]_. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</span>
<span class="sd">    mollify_factor : scalar</span>
<span class="sd">        the mollification factor used in the robust Laplacian. see https://github.com/nmwsharp/robust-laplacians-py</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        small constant for numerical stability </span>
<span class="sd">    debugviz : bool</span>
<span class="sd">        if True, a histogram of the area distortion is plotted per iteration to check if the flow is working properly. The area distortion is plotted as log(distortion) and so should move towards a peak of 0</span>
<span class="sd">    debugvis_tri : bool</span>
<span class="sd">        if True, plots the triangle mesh per iteration.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v_steps : list of (n_vertices, 3) array</span>
<span class="sd">        the vertex position at every iteration. The first coordinate of the vertices is set to 0. </span>
<span class="sd">    f_steps : list of (n_faces, 3) array</span>
<span class="sd">        the face connectivity at every iteration. This will be the same for all timepoints unless flip_delaunay=True</span>
<span class="sd">    area_distortion_iter : list</span>
<span class="sd">        the area distortion factor per face computed as area_original/area_sphere for every timepoint. </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zou, Guangyu, et al. &quot;Authalic parameterization of general surfaces using Lie advection.&quot; IEEE Transactions on Visualization and Computer Graphics 17.12 (2011): 2005-2014.</span>
<span class="sd">    .. [2] Sharp, Nicholas, and Keenan Crane. &quot;A laplacian for nonmanifold triangle meshes.&quot; Computer Graphics Forum. Vol. 39. No. 5. 2020.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="c1"># import meshplex</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">robust_laplacian</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">intrinsic_delaunay_triangulation</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>

    <span class="n">area_distortion_iter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">v_steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="n">f_steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)):</span>
        
        <span class="c1"># try:</span>

        <span class="c1"># if conformalize == False:</span>
        <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">);</span> <span class="c1"># this must be computed. # if not... then no growth -&gt; flow must change triangle shape!. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>

        <span class="n">v_bound</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                
        <span class="c1"># # compute the area distortion of the face -&gt; having normalized for surface area. -&gt; this is because the sphere minimise the surface area. -&gt; guaranteeing positive. </span>
        <span class="n">A2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">mesh_orig</span><span class="o">.</span><span class="n">vertices</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">mesh_orig</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)),</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">A1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)),</span> <span class="n">f</span><span class="p">)</span>
        
        <span class="c1"># B = np.log10(A1/(A2)) # - 1</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">A1</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">A2</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># adding regularizer to top and bottom is better!. </span>

        <span class="n">area_distortion_mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">+</span><span class="n">eps</span><span class="p">))</span> <span class="c1"># this is face measure!. and the connectivity is allowed to change! during evolution !. </span>
        <span class="n">area_distortion_mesh_vertex</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> 
                                                                <span class="n">f</span><span class="p">,</span> 
                                                                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">area_distortion_mesh</span><span class="p">,</span><span class="n">area_distortion_mesh</span><span class="p">,</span><span class="n">area_distortion_mesh</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># smooth ... </span>
        <span class="k">if</span> <span class="n">debugviz</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">area_distortion_mesh_vertex</span><span class="p">))</span> <span class="c1"># why no change? </span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># if smooth_iters &gt; 0:</span>
        <span class="c1">#     smooth_area_distortion_mesh_vertex = np.vstack([area_distortion_mesh_vertex,area_distortion_mesh_vertex,area_distortion_mesh_vertex]).T # smooth this instead of the gradient. </span>

        <span class="c1">#     for iter_ii in range(smooth_iters):</span>
        <span class="c1">#         smooth_area_distortion_mesh_vertex = igl.per_vertex_attribute_smoothing(smooth_area_distortion_mesh_vertex, f) # seems to work.</span>
        <span class="c1">#     area_distortion_mesh_vertex = smooth_area_distortion_mesh_vertex[:,0]</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="n">delta_h_bound</span><span class="p">,</span> <span class="n">delta_h_bound</span><span class="p">)</span> <span class="c1"># bound above and below. </span>
        <span class="c1"># B_vertex = igl.average_onto_vertices(v, </span>
        <span class="c1">#                                       f, </span>
        <span class="c1">#                                       np.vstack([B,B,B]).T)[:,0] # more accurate? </span>
        <span class="n">B_vertex</span> <span class="o">=</span> <span class="n">f2v</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

        <span class="c1"># from scipy.sparse.linalg import lsqr ---- this sometimes fails!... </span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="c1"># tikholov regulariser. </span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">((</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B_vertex</span><span class="p">))</span> <span class="c1"># solve for a smooth potential field.  # this is the least means square. </span>
        <span class="c1"># g = spsparse.linalg.lsqr(L.T.dot(L), L.dot(B_vertex), iter_lim=100)[0] # is there a better way to solve this quadratic? </span>

        <span class="n">face_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">face_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                                <span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">face_normals</span> <span class="o">=</span> <span class="n">face_normals</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">face_normals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="c1"># face_normals = np.vstack([np.ones(len(face_vertex)), </span>
        <span class="c1">#                           np.zeros(len(face_vertex)),</span>
        <span class="c1">#                           np.zeros(len(face_vertex))]).T # should this be something else? </span>
        <span class="n">face_g</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># vertex_normals = igl.per_vertex_normals(v,f)</span>

        <span class="c1"># i,j,k = 1,2,3</span>
        <span class="n">face_vertex_lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([(</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">,:],</span>
                                          <span class="p">(</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">face_vertex</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">,:],</span>
                                          <span class="n">face_normals</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        <span class="n">face_g_rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([(</span><span class="n">face_g</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">face_g</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="p">(</span><span class="n">face_g</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">face_g</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">face_g</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>


        <span class="c1"># solve a simultaneous set of 3x3 problems</span>
        <span class="n">dg_face</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span> <span class="n">face_vertex_lhs</span><span class="p">,</span> <span class="n">face_g_rhs</span><span class="p">)</span>

        <span class="n">gu_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dg_face</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        <span class="n">max_size</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">avg_edge_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">gu_mag</span><span class="p">)</span> <span class="c1"># stable if divide by nanmax # must be nanmax!. </span>
        
        <span class="c1"># dg_face = stepsize*max_size*dg_face # this is vector. and is scaled by step size </span>
        <span class="c1"># dg_face = max_size*dg_face</span>
        
        <span class="c1"># average onto the vertex. </span>
        <span class="n">dg_vertex</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_vertices</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> 
                                              <span class="n">f</span><span class="p">,</span> 
                                              <span class="n">dg_face</span><span class="p">)</span>
        <span class="n">dg_vertex</span> <span class="o">=</span> <span class="n">dg_vertex</span> <span class="o">*</span> <span class="n">max_size</span>
        <span class="c1"># dg_vertex = dg_vertex - np.nansum(dg_vertex*vertex_normals,axis=-1)[:,None]*vertex_normals</span>
        
        <span class="c1"># correct the flow at the boundary!. # this is good? ---&gt; this is good for an explicit euler. </span>
        <span class="n">normal_vect</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">normal_vect</span> <span class="o">=</span> <span class="n">normal_vect</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal_vect</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="c1"># dg_vertex[v_bound] = dg_vertex[v_bound] - np.nansum(dg_vertex[v_bound] * v[v_bound], axis=-1)[:,None]*v[v_bound]</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this is the gradient at the vertex. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dg_vertex</span><span class="p">[</span><span class="n">v_bound</span><span class="p">]</span> <span class="o">=</span> <span class="n">dg_vertex</span><span class="p">[</span><span class="n">v_bound</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dg_vertex</span><span class="p">[</span><span class="n">v_bound</span><span class="p">]</span> <span class="o">*</span> <span class="n">normal_vect</span><span class="p">[</span><span class="n">v_bound</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">normal_vect</span><span class="p">[</span><span class="n">v_bound</span><span class="p">]</span>
        <span class="c1"># disps.append(dg_vertex)</span>
        
        <span class="c1"># print(&#39;no_adaptive&#39;)</span>
        <span class="n">scale_factor</span><span class="o">=</span><span class="n">stepsize</span>
        <span class="c1"># print(&#39;scale_factor, &#39;, scale_factor)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        advection step </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># v = V[:,1:] + np.array(disps).sum(axis=0)[:,1:] # how to make this step stable? </span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">scale_factor</span><span class="o">*</span><span class="n">dg_vertex</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># last one. </span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">v</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">flip_delaunay</span><span class="p">:</span> <span class="c1"># we have to flip!. </span>
            <span class="c1"># import meshplex</span>
            <span class="c1"># # this clears out the overlapping. is this necessary</span>
            <span class="c1"># mesh_out = meshplex.MeshTri(v, f)</span>
            <span class="c1"># mesh_out.flip_until_delaunay()</span>
        
            <span class="c1"># # update v and f!</span>
            <span class="c1"># v = mesh_out.points.copy()</span>
            <span class="c1"># f = mesh_out.cells(&#39;points&#39;).copy() </span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">intrinsic_delaunay_triangulation</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">edge_lengths</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">debugviz_tri</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">.1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="n">v_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">f_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">area_distortion_iter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area_distortion_mesh</span><span class="p">)</span> <span class="c1"># append this. </span>

        <span class="c1"># except:</span>
        <span class="c1">#     # if error then break</span>
        <span class="c1">#     return v_steps, f_steps, area_distortion_iter</span>

    <span class="k">return</span> <span class="n">v_steps</span><span class="p">,</span> <span class="n">f_steps</span><span class="p">,</span> <span class="n">area_distortion_iter</span></div>


<div class="viewcode-block" id="adjacency_edge_cost_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.adjacency_edge_cost_matrix">[docs]</a><span class="k">def</span> <span class="nf">adjacency_edge_cost_matrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Build the Laplacian matrix for a line given the vertices and the undirected edge-edge connections </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V : (n_points,d) array</span>
<span class="sd">        the vertices of the d-dimensional line</span>
<span class="sd">    E : (n_edges,2) array</span>
<span class="sd">        the edge connections as integer vertex indices specifying how the vertices are joined together</span>
<span class="sd">    n : int</span>
<span class="sd">        if specified, the size of the Laplacian matrix, if not the same as the number of points in V. the returned Laplacian matrix will be of dimension ((n,n))</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : (n,n) sparse array</span>
<span class="sd">        the n x n symmetric vertex laplacian matrix </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="c1"># % compute edge norms</span>
    <span class="n">edge_norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">V</span><span class="p">[</span><span class="n">E</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># % number of vertices</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
    <span class="c1">#% build sparse adjacency matrix with non-zero entries indicated edge costs</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">edge_norms</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># to make undirected. </span>
    
    <span class="k">return</span> <span class="n">C</span></div>

<div class="viewcode-block" id="adjacency_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.adjacency_matrix">[docs]</a><span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Build the Laplacian matrix for a line given the undirected edge-edge connections without taking into account distances between vertices</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    E : (n_edges,2) array</span>
<span class="sd">        the edge connections as integer vertex indices specifying how the vertices are joined together</span>
<span class="sd">    n : int</span>
<span class="sd">        if specified, the size of the Laplacian matrix, if not the same as the number of points in V. the returned Laplacian matrix will be of dimension ((n,n))</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : (n,n) sparse array</span>
<span class="sd">        the n x n symmetric vertex laplacian matrix </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="c1"># % number of vertices</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
    <span class="c1">#% build sparse adjacency matrix with non-zero entries indicated edge costs</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)),</span> <span class="p">(</span><span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># to make undirected. </span>
    
    <span class="k">return</span> <span class="n">C</span></div>
        
<div class="viewcode-block" id="mass_matrix2D"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.mass_matrix2D">[docs]</a><span class="k">def</span> <span class="nf">mass_matrix2D</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Build the Mass matrix for a given adjacency or Laplacian matrix. The mass matrix is a diagonal matrix of the row sums of the input matrix, A</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : (N,N) array or sparse array </span>
<span class="sd">        the Adjacency or symmetric Laplacian matrix </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : (N,N) sparse array</span>
<span class="sd">        a diagonal matrix whose entries are the row sums of the symmetric input matrix </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># M = M / np.max(M.diagonal())</span>
    
    <span class="k">return</span> <span class="n">M</span> </div>


<div class="viewcode-block" id="vertex_dihedral_angle_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.vertex_dihedral_angle_matrix">[docs]</a><span class="k">def</span> <span class="nf">vertex_dihedral_angle_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Build the Dihedral angle matrix for vertices given an input mesh. The dihedral angles, is the angle between the normals of pairs of vertices measures the local mesh convexity. the dihedral angle is captured as a cosime distance</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input mesh</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small constant scalar for numerical stability </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angles_edges_matrix : (n_vertices, n_vertices) sparse array</span>
<span class="sd">        a matrix capturing the dihedral angle between vertex_i to vertex_j between vertex neighbors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="c1"># we use the dihdral angle formula... </span>
    <span class="n">vertex_edge_list</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="n">normals1</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span><span class="p">[</span><span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="p">;</span> <span class="n">normals1</span> <span class="o">=</span> <span class="n">normals1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normals1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>  <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">normals2</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span><span class="p">[</span><span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="p">;</span> <span class="n">normals2</span> <span class="o">=</span> <span class="n">normals2</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normals2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>  <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    
    <span class="c1"># dot product. </span>
    <span class="n">angles_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">normals1</span> <span class="o">*</span> <span class="n">normals2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this is signed cosine.. </span>
    <span class="c1"># cosine distance matrix </span>
    <span class="n">angles_edges</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">angles_edges</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> <span class="c1"># this makes it a proper distance!. # smaller should be closer...? </span>

    <span class="c1"># make into adjacency matrix</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">angles_edges_matrix</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">angles_edges</span><span class="p">,</span> <span class="p">(</span><span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> 
                            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">angles_edges_matrix</span> <span class="o">=</span> <span class="n">angles_edges_matrix</span> <span class="o">+</span> <span class="n">angles_edges_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># symmetric</span>

    <span class="k">return</span> <span class="n">angles_edges_matrix</span></div>

<div class="viewcode-block" id="vertex_edge_lengths_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.vertex_edge_lengths_matrix">[docs]</a><span class="k">def</span> <span class="nf">vertex_edge_lengths_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Build the edge distance matrix between local vertex neighbors of the input mesh </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input mesh</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : (n_vertices, n_vertices) sparse array</span>
<span class="sd">        a matrix capturing the euclidean edge distance between vertex_i to vertex_j of vertex neighbors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="n">vertex_edge_list</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="c1"># this is unique edges hence not undirected. (upper triangular)</span>
    <span class="c1"># get the distance matrix between the edges. </span>
    <span class="n">dist_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> 
                                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># make into adjacency matrix</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">dist_edges</span><span class="p">,</span> <span class="p">(</span><span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertex_edge_list</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> 
                            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># make symmetric! </span>

    <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="vertex_edge_affinity_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix">[docs]</a><span class="k">def</span> <span class="nf">vertex_edge_affinity_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute an affinity distance matrix of the edge distances. This is done by computing the pairwise edge length distances between vertex neighbors and applying a heat kernel.</span>

<span class="sd">    .. math:: </span>
<span class="sd">        A_{dist} = \exp^{\left(\frac{-D_{dist}^2}{2\sigma^2}\right)}</span>

<span class="sd">    where :math:`sigma` is set as the mean distance of :math:`D` or :math:`\gamma` if provided.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input mesh</span>
<span class="sd">    gamma : scalar</span>
<span class="sd">        a scalar normalisation of the distances in the distance matrix </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (n_vertices, n_vertices) sparse array</span>
<span class="sd">        a matrix capturing the euclidean edge affinity between vertex_i to vertex_j of vertex neighbors. This is a normalised measure of distances with values mainly in the scale of [0,1]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">vertex_edge_lengths_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">distance_to_heat_affinity_matrix</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span> </div>

<div class="viewcode-block" id="vertex_dihedral_angle_affinity_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix">[docs]</a><span class="k">def</span> <span class="nf">vertex_dihedral_angle_affinity_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute an affinity distance matrix of the vertex dihedral angles. This is done by computing the vertex dihedral angle distances and applying a heat kernel.</span>

<span class="sd">    .. math:: </span>
<span class="sd">        A_{angle} = \exp^{\left(\frac{-D_{angle}^2}{2\sigma^2}\right)}</span>

<span class="sd">    where :math:`sigma` is set as the mean distance of :math:`D` or :math:`\gamma` if provided.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input mesh</span>
<span class="sd">    gamma : scalar</span>
<span class="sd">        a scalar normalisation of the distances in the distance matrix </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small constant for numerical stability </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : (n_vertices, n_vertices) sparse array</span>
<span class="sd">        a matrix capturing the euclidean dihedral angle cosine distance affinity between vertex_i to vertex_j of vertex neighbors. This is a normalised measure of distances with values mainly in the scale of [0,1]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">vertex_dihedral_angle_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">distance_to_heat_affinity_matrix</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="vertex_geometric_affinity_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.vertex_geometric_affinity_matrix">[docs]</a><span class="k">def</span> <span class="nf">vertex_geometric_affinity_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute an affinity matrix balancing geodesic distances and convexity by taking a weighted average of the edge distance affinity matrix and the vertex dihedral angle affinity matrix. </span>

<span class="sd">    .. math:: </span>
<span class="sd">        A = \alpha A_{dist} + (1-\alpha) A_{dihedral}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input mesh</span>
<span class="sd">    gamma : scalar</span>
<span class="sd">        a scalar normalisation of the distances in the distance matrix </span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small constant for numerical stability of the dihedral angle distance matrix </span>
<span class="sd">    alpha : 0-1</span>
<span class="sd">        the weight for averaging the two affinity matrices</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        if True, apply left normalization to the averaged affinity matrix given by :math:`M^{-1}A` where :math:`M` is the mass matrix. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : (n_vertex, n_vertex) scipy sparse matrix</span>
<span class="sd">        the combined average affinity matrix</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix` : </span>
<span class="sd">        function used to compute the vertex edge distance affinity matrix</span>
<span class="sd">    :func:`unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix` : </span>
<span class="sd">        function used to compute the vertex dihedral angle distance affinity matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">Distance_matrix</span> <span class="o">=</span> <span class="n">vertex_edge_affinity_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">Convexity_matrix</span> <span class="o">=</span> <span class="n">vertex_dihedral_angle_affinity_matrix</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>

    <span class="n">W</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">Distance_matrix</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">Convexity_matrix</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">DD</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">DD</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># this is perfect normalization. </span>

    <span class="k">return</span> <span class="n">W</span> </div>

<div class="viewcode-block" id="distance_to_heat_affinity_matrix"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.distance_to_heat_affinity_matrix">[docs]</a><span class="k">def</span> <span class="nf">distance_to_heat_affinity_matrix</span><span class="p">(</span><span class="n">Dmatrix</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Convert any distance matrix to an affinity matrix by applying a heat kernel.</span>

<span class="sd">    .. math:: </span>
<span class="sd">        A = \exp^{\left(\frac{-D^2}{2\sigma^2}\right)}</span>

<span class="sd">    where :math:`sigma` is set as the mean distance of :math:`D` or :math:`\gamma` if provided.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Dmatrix : (N,N) sparse array</span>
<span class="sd">        a scipy.sparse input distance matrix</span>
<span class="sd">    gamma : scalar</span>
<span class="sd">        the normalisation scale factor of distances</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    A : (N,N) sparse array</span>
<span class="sd">        a scipy.sparse output affinity distance matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">Dmatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Dmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigma_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigma_D</span> <span class="o">=</span> <span class="n">gamma</span>
    <span class="n">den_D</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma_D</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">den_D</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># diagonal is 1 by definition. </span>

    <span class="k">return</span> <span class="n">A</span> </div>


<div class="viewcode-block" id="conformalized_mean_line_flow"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.conformalized_mean_line_flow">[docs]</a><span class="k">def</span> <span class="nf">conformalized_mean_line_flow</span><span class="p">(</span> <span class="n">contour_pts</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">close_contour</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fixed_boundary</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lambda_flow</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">niters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">topography_edge_fix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">conformalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Conformalized mean curvature flow of a curve, also known as the isoperimetric flow.</span>

<span class="sd">    This function is adapted from the Matlab GPToolbox </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    contour_pts : (n_points,d) array</span>
<span class="sd">        the list of coordinates of the line </span>
<span class="sd">    E : (n_edges,2) array</span>
<span class="sd">        the edge connectivity of points on the line </span>
<span class="sd">    close_contour : bool</span>
<span class="sd">        if True and E is None, construct the edge connectivity assuming the order of the given contour_pts and connecting the last point to the 1st point. If False and E is None, the order of the given contour_pts is still assumed but the last point to the 1st point is not connected by an edge</span>
<span class="sd">    fixed_boundary : bool</span>
<span class="sd">        if True, the ends of the contour_pts is not involved but is pinned to its original position. Only the interior points are updated</span>
<span class="sd">    lambda_flow : scalar</span>
<span class="sd">        controls the stepsize of the evolution per iteration. Smaller values given less movement</span>
<span class="sd">    niters : int</span>
<span class="sd">        the number of iterations to run </span>
<span class="sd">    topography_edge_fix : bool</span>
<span class="sd">        this is only relevant for :func:`unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography` or lines coming from topographic boundaries where we wish to remove all flow in other directions except that in the depth axis at the boundary. </span>
<span class="sd">    conformalize : bool </span>
<span class="sd">        if True, the Laplacian matrix is not recomputed at every iteration. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    contour_pts_flow : (n_points,d,niters+1)</span>
<span class="sd">        the list of coordinates of the line at each iteration including the initial position. The edge connectivity is the same as input </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Fix boundary will find all degree = 1 nodes and make their laplacian 0 ---&gt; inducing no flow. and therefore returning the identity  </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">close_contour</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">)),</span> 
                 <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">))[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                 <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">adjacency_edge_cost_matrix</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">A</span><span class="o">-</span><span class="n">spsparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))));</span> <span class="c1"># why is this so slow? </span>

    <span class="k">if</span> <span class="n">fixed_boundary</span><span class="p">:</span>
        <span class="n">boundary_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">))[</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">L</span><span class="p">[</span><span class="n">boundary_nodes</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># slice this in. </span>
    
    <span class="c1"># so we need no flux boundary conditions to prevent flow in x,y at the boundary!....----&gt; one way is to do mirror...( with rectangular grid this is easy... but with triangle is harder...)</span>
    <span class="n">contour_pts_flow</span> <span class="o">=</span> <span class="p">[</span><span class="n">contour_pts</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">iter_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">niters</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">adjacency_edge_cost_matrix</span><span class="p">(</span><span class="n">contour_pts_flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">E</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conformalize</span> <span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">A</span><span class="o">-</span><span class="n">spsparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))));</span>
            <span class="k">if</span> <span class="n">fixed_boundary</span><span class="p">:</span>
                <span class="n">boundary_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contour_pts</span><span class="p">))[</span><span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">L</span><span class="p">[</span><span class="n">boundary_nodes</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># slice this in. </span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">mass_matrix2D</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># # unfixed version of the problem </span>
        <span class="c1"># vvv = spsparse.linalg.spsolve(M-lambda_flow*L, M.dot(boundary_mesh_pos[-1]))</span>
        <span class="k">if</span> <span class="n">topography_edge_fix</span><span class="p">:</span>
            <span class="n">rhs_term</span> <span class="o">=</span>  <span class="o">-</span><span class="n">lambda_flow</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">contour_pts_flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># this balances the flow. # the x-y plane has normal with z. # so we just the opposite.</span>
            <span class="n">rhs_term</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># ok this is correct - this blocks all into plane flow. but what if we relax this.... -&gt; permit just not orthogonal....</span>
            <span class="n">vvv</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">lambda_flow</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">contour_pts_flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="o">+</span> <span class="n">rhs_term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vvv</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">lambda_flow</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">contour_pts_flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="n">contour_pts_flow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vvv</span><span class="p">)</span>
    <span class="n">contour_pts_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">contour_pts_flow</span><span class="p">)</span>
    <span class="n">contour_pts_flow</span> <span class="o">=</span> <span class="n">contour_pts_flow</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contour_pts_flow</span></div>


<div class="viewcode-block" id="conformalized_mean_curvature_flow"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow">[docs]</a><span class="k">def</span> <span class="nf">conformalized_mean_curvature_flow</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span> <span class="n">rescale_output</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">min_diff</span> <span class="o">=</span> <span class="mf">1e-13</span><span class="p">,</span> <span class="n">conformalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">robust_L</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Conformalized mean curvature flow of a mesh of Kazhdan et al. [1]_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input 3D mesh  </span>
<span class="sd">    max_iter : int</span>
<span class="sd">        the number of iterations</span>
<span class="sd">    delta : scalar</span>
<span class="sd">        controls the stepsize of the evolution per iteration. Smaller values gives less deformation</span>
<span class="sd">    rescale_output : bool</span>
<span class="sd">        if False will return a surface area normalised mesh instead. if True return the mean curvature flow surfaces at the same scale as the input mesh</span>
<span class="sd">    min_diff : </span>
<span class="sd">        not used for now </span>
<span class="sd">    conformalize : </span>
<span class="sd">        if True, the Laplacian matrix is not recomputed at every iteration. </span>
<span class="sd">    robust_L : bool</span>
<span class="sd">        if True, uses the robust Laplacian construction of Sharpe et al. [2]_. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</span>
<span class="sd">    mollify_factor : scalar</span>
<span class="sd">        the mollification factor used in the robust Laplacian. see https://github.com/nmwsharp/robust-laplacians-py    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Usteps : (n_points,3,niters+1) array</span>
<span class="sd">        an array of the vertex coordinates of the mesh at each iteration</span>
<span class="sd">    F : (n_faces,3) array</span>
<span class="sd">        the face connectivity of the mesh </span>
<span class="sd">    flow_metrics_dict : dict</span>
<span class="sd">        a dict of various statistical measures of the flow </span>
<span class="sd">        </span>
<span class="sd">        &#39;mean_curvature_iter&#39; : array</span>
<span class="sd">            mean of absolute values of mean curvature per face per iteration </span>
<span class="sd">        &#39;max_curvature_iter&#39; : array</span>
<span class="sd">            maximum of absolute values of mean curvature per face per iteration </span>
<span class="sd">        &#39;gauss_curvature_iter&#39; : array</span>
<span class="sd">            mean of absolute values of Gaussian curvature per face per iteration </span>
<span class="sd">        &#39;canonical_c_all&#39; : array</span>
<span class="sd">            array of the computed face area weighted centroid per iteration with respect to an area normalised mesh</span>
<span class="sd">        &#39;canonical_area_all&#39; : array </span>
<span class="sd">            array of the total surface area used for area normalising per iteration</span>
<span class="sd">        &#39;flow_d_all&#39; : array</span>
<span class="sd">            matrix norm difference between current and previous vertex coordinate positions</span>
<span class="sd">        &#39;V0_max&#39; : scalar</span>
<span class="sd">            the maximum scalar value over all coordinate values used to initially scale the mesh vertices</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Kazhdan, Michael, Jake Solomon, and Mirela BenChen. &quot;Can meancurvature flow be modified to be nonsingular?.&quot; Computer Graphics Forum. Vol. 31. No. 5. Oxford, UK: Blackwell Publishing Ltd, 2012.</span>
<span class="sd">    .. [2] Sharp, Nicholas, and Keenan Crane. &quot;A laplacian for nonmanifold triangle meshes.&quot; Computer Graphics Forum. Vol. 39. No. 5. 2020.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    input is a trimesh mesh object with vertices, faces etc. </span>
<span class="sd">        delta: the step size of diffusion. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">robust_laplacian</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> 
    <span class="c1"># V = V - np.mean(V, axis=0) # center this </span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span>

    <span class="c1"># or the robust version (tufted -&gt; see Keenan Crane) # sign is inversed..... from IGL. </span>
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">);</span> 
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># first build the laplacian.  </span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">)</span> <span class="c1"># this is negative semi-definite </span>
    
    <span class="c1"># make a copy of the initial vertex, face</span>
    <span class="n">SF</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># make a copy that is the initial faces connectivity. </span>
    <span class="n">V0</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    <span class="c1"># V0_max = float(np.abs(V).max())</span>
    <span class="n">V0_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="c1"># V0_max = 1</span>

    <span class="c1"># initialise the save array. </span>
    <span class="n">Usteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1"># first step. </span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    <span class="c1"># pre-normalize for stability. </span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">/</span> <span class="n">V0_max</span> <span class="c1"># pre-divided by U.max().... here so we are in [0,1] # this is best for image-derived meshes.. not for scanned meshes? </span>
    <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># initialise. </span>
    
    <span class="c1"># save various curvature measures of intermediate. </span>
    <span class="n">curvature_steps</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">max_curvature_steps</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">gauss_curvature_steps</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># these must be applied iteratively in order to reconstitute the actual size ? </span>
    <span class="n">c_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">area_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">area0</span> <span class="o">=</span> <span class="mf">1.</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)):</span>

        <span class="c1"># iterate. </span>
        <span class="n">U_prev</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="c1"># make a copy. </span>
        <span class="c1"># % &#39;full&#39; seems slight more stable than &#39;barycentric&#39; which is more stable</span>
        <span class="c1"># % than &#39;voronoi&#39;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">robust_L</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_BARYCENTRIC</span><span class="p">)</span> <span class="c1"># -&gt; this is the only matrix that doesn&#39;t degenerate. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L_</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">);</span> <span class="n">L_</span> <span class="o">=</span> <span class="o">-</span><span class="n">L_</span>
        <span class="c1"># M = igl.massmatrix(U, F, igl.MASSMATRIX_TYPE_FULL) # what about this ? </span>
        <span class="c1"># %     M = massmatrix(U,F,&#39;full&#39;);</span>
        <span class="k">if</span> <span class="n">conformalize</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">robust_L</span><span class="p">:</span>
                <span class="c1"># L = laplacian(V,F);</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">F</span><span class="p">)</span> <span class="c1"># should be recomputation. </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">L_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
        <span class="c1"># # implicit solve. </span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">delta</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="c1"># what happens when we invert? </span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
        <span class="c1"># b = U.copy()</span>

        <span class="c1"># # Solve # compare with spsolve. # best way to solve? ---&gt; S is symmetric therefore we can do splu then solve.---&gt; which should be really fast!.</span>
        <span class="c1"># u1,xx = spsparse.linalg.bicgstab(S, b[:,0]) # not that bad... </span>
        <span class="c1"># u2,yy = spsparse.linalg.bicgstab(S, b[:,1]) </span>
        <span class="c1"># u3,zz = spsparse.linalg.bicgstab(S, b[:,2])</span>
        <span class="c1"># u1,xx = spsparse.linalg.cg(S, b[:,0], maxiter=100) # not that bad... </span>
        <span class="c1"># u2,yy = spsparse.linalg.cg(S, b[:,1], maxiter=100) </span>
        <span class="c1"># u3,zz = spsparse.linalg.cg(S, b[:,2], maxiter=100)</span>
        <span class="c1"># u1,xx = spsparse.linalg.bicg(S, b[:,0], maxiter=100) # not that bad... </span>
        <span class="c1"># u2,yy = spsparse.linalg.bicg(S, b[:,1], maxiter=100) </span>
        <span class="c1"># u3,zz = spsparse.linalg.bicg(S, b[:,2], maxiter=100)</span>
        <span class="c1"># U = np.vstack([u1,u2,u3]).T</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if we detect nan, no good. </span>
            <span class="k">break</span> 
        <span class="k">else</span><span class="p">:</span>
        
            <span class="c1"># canonical centering is a must to stabilize -&gt; essentially affects a scaling + translation.  </span>
            <span class="c1"># rescale by the area? # is this a mobius transformation? ( can)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">SF</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)</span> <span class="c1">#total area. </span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mf">0.5</span><span class="o">*</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">SF</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">F</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># this is just weighted centroid</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> 
            <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="p">))</span> <span class="c1"># avoid zero area</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">((((</span><span class="n">U</span><span class="o">-</span><span class="n">U_prev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="o">-</span><span class="n">U_prev</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># assessment of convergence. </span>

            <span class="n">d_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="c1"># append key parameters. </span>
            <span class="n">c_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">area_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute assessments of smoothness.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># compute the mean curvature # use the principal curvature computation. </span>
            <span class="c1"># ll = igl.cotmatrix(U, F)</span>
            <span class="c1"># mm = igl.massmatrix(U, F, igl.MASSMATRIX_TYPE_VORONOI)</span>
            <span class="c1"># minv = spsparse.diags(1 / mm.diagonal())</span>
            <span class="c1"># hn = -minv.dot(ll.dot(U))</span>
            <span class="c1"># h = np.linalg.norm(hn, axis=1)</span>

            <span class="c1"># more robust:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">principal_curvature</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
            <span class="n">h2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span><span class="p">)</span>
            <span class="n">curvature_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h2</span><span class="p">)))</span>
            <span class="n">max_curvature_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h2</span><span class="p">)))</span>
            
            <span class="c1"># this is the best. </span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">gaussian_curvature</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
            <span class="n">gauss_curvature_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kk</span><span class="p">)))</span>
            
            <span class="k">if</span> <span class="n">rescale_output</span><span class="p">:</span> 
                <span class="c1"># x area + c</span>
                <span class="n">c0</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">c</span>
                <span class="n">area0</span> <span class="o">=</span> <span class="n">area0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
                <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">U</span> <span class="o">*</span> <span class="n">area0</span><span class="p">)</span> <span class="o">+</span> <span class="n">c0</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># since it is just iterative... </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># copy the current iteration into it. </span>

    <span class="n">c_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">c_all</span><span class="p">)</span>
    <span class="n">area_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">area_all</span><span class="p">)</span>
    <span class="n">Usteps</span> <span class="o">=</span> <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">area_all</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">rescale_output</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># area = np.sum(igl.doublearea(Usteps[...,0],SF)*0.5); # original area. </span>
        <span class="c1"># c = np.sum((0.5*igl.doublearea(Usteps[...,0],SF)/area)[...,None] * igl.barycenter(Usteps[...,0],SF), axis=0);</span>
        <span class="c1"># below is more easy to get back </span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">area_all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># this is wrong? # -&gt; this might be the problem ... we should have the same as number of iterations. </span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c_all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(area, c)</span>
        <span class="c1"># if nargout &gt; 1</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Usteps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Usteps</span><span class="p">[:,:,</span><span class="n">iteration</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Usteps</span><span class="p">[:,:,</span><span class="n">iteration</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="p">);</span>
            <span class="n">Usteps</span><span class="p">[:,:,</span><span class="n">iteration</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Usteps</span><span class="p">[:,:,</span><span class="n">iteration</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

    <span class="c1"># finally multiply all Usteps by umax</span>
    <span class="n">Usteps</span> <span class="o">=</span> <span class="n">Usteps</span> <span class="o">*</span> <span class="n">V0_max</span>

    <span class="c1"># to save the key parameters that we will make use of .... </span>
    <span class="n">flow_metrics_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean_curvature_iter&#39;</span><span class="p">:</span> <span class="n">curvature_steps</span><span class="p">,</span> 
                         <span class="s1">&#39;max_curvature_iter&#39;</span><span class="p">:</span> <span class="n">max_curvature_steps</span><span class="p">,</span> 
                         <span class="s1">&#39;gauss_curvature_iter&#39;</span><span class="p">:</span> <span class="n">gauss_curvature_steps</span><span class="p">,</span> 
                         <span class="s1">&#39;canonical_c_all&#39;</span><span class="p">:</span> <span class="n">c_all</span><span class="p">,</span> 
                         <span class="s1">&#39;canonical_area_all&#39;</span><span class="p">:</span> <span class="n">area_all</span><span class="p">,</span> 
                         <span class="s1">&#39;flow_d_all&#39;</span><span class="p">:</span> <span class="n">d_all</span><span class="p">,</span>
                         <span class="s1">&#39;V0_max&#39;</span><span class="p">:</span> <span class="n">V0_max</span><span class="p">}</span>
    
    <span class="k">return</span> <span class="n">Usteps</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">flow_metrics_dict</span></div>


<div class="viewcode-block" id="conformalized_mean_curvature_flow_topography"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography">[docs]</a><span class="k">def</span> <span class="nf">conformalized_mean_curvature_flow_topography</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> 
                                                 <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> 
                                                 <span class="n">delta</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span> 
                                                 <span class="n">min_diff</span> <span class="o">=</span> <span class="mf">1e-13</span><span class="p">,</span> 
                                                 <span class="n">conformalize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                                 <span class="n">robust_L</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                                 <span class="n">mollify_factor</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adapted conformalized mean curvature flow of a mesh of Kazhdan et al. [1]_ to allow for topographic meshes such that iterative applications flattens the topography to the plane.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        the input topography mesh </span>
<span class="sd">    max_iter : int</span>
<span class="sd">        the number of iterations</span>
<span class="sd">    delta : scalar</span>
<span class="sd">        controls the stepsize of the evolution per iteration. Smaller values gives less deformation</span>
<span class="sd">    min_diff : </span>
<span class="sd">        not used for now </span>
<span class="sd">    conformalize : </span>
<span class="sd">        if True, the Laplacian matrix is not recomputed at every iteration. </span>
<span class="sd">    robust_L : bool</span>
<span class="sd">        if True, uses the robust Laplacian construction of Sharpe et al. [2]_. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</span>
<span class="sd">    mollify_factor : scalar</span>
<span class="sd">        the mollification factor used in the robust Laplacian. see https://github.com/nmwsharp/robust-laplacians-py    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Usteps : (n_points,3,niters+1) array</span>
<span class="sd">        an array of the vertex coordinates of the mesh at each iteration</span>
<span class="sd">    F : (n_faces,3) array</span>
<span class="sd">        the face connectivity of the mesh </span>
<span class="sd">    flow_metrics_dict : dict</span>
<span class="sd">        a dict of various statistical measures of the flow </span>
<span class="sd">        </span>
<span class="sd">        &#39;mean_curvature_iter&#39; : array</span>
<span class="sd">            mean of absolute values of mean curvature per face per iteration </span>
<span class="sd">        &#39;max_curvature_iter&#39; : array</span>
<span class="sd">            maximum of absolute values of mean curvature per face per iteration </span>
<span class="sd">        &#39;gauss_curvature_iter&#39; : array</span>
<span class="sd">            mean of absolute values of Gaussian curvature per face per iteration </span>
<span class="sd">        &#39;canonical_c_all&#39; : array</span>
<span class="sd">            array of the computed face area weighted centroid per iteration with respect to an area normalised mesh</span>
<span class="sd">        &#39;canonical_area_all&#39; : array </span>
<span class="sd">            array of the total surface area used for area normalising per iteration</span>
<span class="sd">        &#39;flow_d_all&#39; : array</span>
<span class="sd">            matrix norm difference between current and previous vertex coordinate positions</span>
<span class="sd">        &#39;V0_max&#39; : scalar</span>
<span class="sd">            the maximum scalar value over all coordinate values used to initially scale the mesh vertices</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Kazhdan, Michael, Jake Solomon, and Mirela BenChen. &quot;Can meancurvature flow be modified to be nonsingular?.&quot; Computer Graphics Forum. Vol. 31. No. 5. Oxford, UK: Blackwell Publishing Ltd, 2012.</span>
<span class="sd">    .. [2] Sharp, Nicholas, and Keenan Crane. &quot;A laplacian for nonmanifold triangle meshes.&quot; Computer Graphics Forum. Vol. 39. No. 5. 2020.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> 
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">robust_laplacian</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> 
    <span class="n">F</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span>

    <span class="c1"># parsing the boundary loop -&gt; we assume largely a simple surface with just the 1 major boundary</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="c1"># boundary </span>
    <span class="n">v_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># this is the unique vertex indices. </span>
    <span class="c1"># build edge connectivity matrix in original index. </span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> 
         <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">## List of all vertex indices</span>
    <span class="n">v_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1">## List of interior indices</span>
    <span class="n">v_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">v_all</span><span class="p">,</span> <span class="n">v_b</span><span class="p">)</span>

    <span class="c1"># build the laplacian for the boundary loop. </span>
    <span class="n">A_b</span> <span class="o">=</span> <span class="n">adjacency_edge_cost_matrix</span><span class="p">(</span> <span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">v_all</span><span class="p">))</span>
    <span class="n">L_b</span> <span class="o">=</span> <span class="n">A_b</span><span class="o">-</span><span class="n">spsparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_b</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))));</span>  

    <span class="c1"># or the robust version (tufted -&gt; see Keenan Crane) # sign is inversed..... from IGL. </span>
    <span class="k">if</span> <span class="n">robust_L</span><span class="p">:</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">);</span> 
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># first build the laplacian.  </span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">)</span> <span class="c1"># this is negative semi-definite </span>
    <span class="n">L</span><span class="p">[</span><span class="n">v_b</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_b</span><span class="p">[</span><span class="n">v_b</span><span class="p">]</span> <span class="c1"># slice in is allowed. wow.</span>
    
    <span class="c1"># make a copy of the initial vertex, face</span>
    <span class="n">SF</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># make a copy that is the initial faces connectivity. </span>
    <span class="n">V0</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    <span class="c1"># better to do area norm straight up!. </span>
    <span class="c1"># V0_max = float(np.sum(igl.doublearea(V0,SF)*.5)) # rescale - assume this is image based</span>
    <span class="c1"># V0_max = float(V.max())</span>
    <span class="n">V0_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
    <span class="c1"># initialise the save array. </span>
    <span class="n">Usteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1"># first step. </span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    <span class="c1"># pre-normalize for stability. # actually might not be the case but will help convergence. </span>
    <span class="c1"># U = U / V0_max # pre-divided by U.max().... here so we are in [0,1] # this is best for image-derived meshes.. not for scanned meshes? </span>
    <span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># initialise. </span>
    
    <span class="c1"># save various curvature measures of intermediate. </span>
    <span class="n">curvature_steps</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">max_curvature_steps</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">gauss_curvature_steps</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># these must be applied iteratively in order to reconstitute the actual size ? </span>
    <span class="n">c_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">area_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">area0</span> <span class="o">=</span> <span class="mf">1.</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)):</span>

        <span class="c1"># iterate. </span>
        <span class="n">U_prev</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="c1"># make a copy. </span>
        <span class="c1"># % &#39;full&#39; seems slight more stable than &#39;barycentric&#39; which is more stable</span>
        <span class="c1"># % than &#39;voronoi&#39;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">robust_L</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_BARYCENTRIC</span><span class="p">)</span> <span class="c1"># -&gt; this is the only matrix that doesn&#39;t degenerate. </span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L_</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">robust_laplacian</span><span class="o">.</span><span class="n">mesh_laplacian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">mollify_factor</span><span class="o">=</span><span class="n">mollify_factor</span><span class="p">);</span> <span class="n">L_</span> <span class="o">=</span> <span class="o">-</span><span class="n">L_</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="n">A_b</span> <span class="o">=</span> <span class="n">adjacency_edge_cost_matrix</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">v_all</span><span class="p">))</span>
        <span class="n">M_b</span> <span class="o">=</span> <span class="n">mass_matrix2D</span><span class="p">(</span><span class="n">A_b</span><span class="p">);</span> <span class="n">M_b</span> <span class="o">=</span> <span class="n">M_b</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">M</span><span class="p">[</span><span class="n">v_b</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">M_b</span><span class="p">[</span><span class="n">v_b</span><span class="p">,:]</span>

        <span class="c1"># M = igl.massmatrix(U, F, igl.MASSMATRIX_TYPE_FULL) # what about this ? </span>
        <span class="c1"># %     M = massmatrix(U,F,&#39;full&#39;);</span>
        <span class="k">if</span> <span class="n">conformalize</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">robust_L</span><span class="p">:</span>
                <span class="c1"># L = laplacian(V,F);</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">F</span><span class="p">)</span> <span class="c1"># should be recomputation. </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">L_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">L_b</span> <span class="o">=</span> <span class="n">A_b</span><span class="o">-</span><span class="n">spsparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A_b</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))));</span>  
            <span class="n">L</span><span class="p">[</span><span class="n">v_b</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_b</span><span class="p">[</span><span class="n">v_b</span><span class="p">]</span> <span class="c1"># slice in is allowed. wow.</span>
            
        <span class="c1"># # implicit solve. </span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">delta</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="c1"># what happens when we invert? </span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add additional boundary term on right</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b_bnd_all</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span><span class="o">*</span><span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
        <span class="n">b_bnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b_bnd_all</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">b_bnd</span><span class="p">[</span><span class="n">v_b</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">b_bnd_all</span><span class="p">[</span><span class="n">v_b</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># this generically destroys all x-y plane deformation. </span>
        
        <span class="c1"># # do prefactorisation? </span>
        <span class="c1"># S = S.tocsc()</span>
        <span class="c1"># # S_ = spsparse.linalg.splu(S)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">b_bnd</span><span class="p">)</span>
        <span class="c1"># U = S_.solve(b + b_bnd)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if we detect nan, no good. </span>
            <span class="k">break</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># canonical centering is a must to stabilize -&gt; essentially affects a scaling + translation.  </span>
            <span class="c1"># rescale by the area? # is this a mobius transformation? ( can)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">SF</span><span class="p">)</span><span class="o">*</span><span class="mf">.5</span><span class="p">)</span> <span class="c1">#total area. </span>
            <span class="c1"># c = np.sum((0.5*igl.doublearea(U,SF)/area)[...,None] * igl.barycenter(U,F), axis=0) # this is just weighted centroid</span>
            <span class="c1"># U = U - c[None,:] </span>
            <span class="c1"># U = U/(np.sqrt(area)) # avoid zero area</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">((((</span><span class="n">U</span><span class="o">-</span><span class="n">U_prev</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="o">-</span><span class="n">U_prev</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># assessment of convergence. </span>
            <span class="c1"># U = U*(np.sqrt(area)) </span>

            <span class="n">d_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="c1"># append key parameters. </span>
            <span class="c1"># c_all.append(c)</span>
            <span class="n">area_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute assessments of smoothness.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># # compute the mean curvature</span>
            <span class="c1"># ll = igl.cotmatrix(U, F)</span>
            <span class="c1"># mm = igl.massmatrix(U, F, igl.MASSMATRIX_TYPE_VORONOI)</span>
            <span class="c1"># minv = spsparse.diags(1 / mm.diagonal())</span>
            <span class="c1"># hn = -minv.dot(ll.dot(U))</span>
            <span class="c1"># h = np.linalg.norm(hn, axis=1)</span>
            <span class="c1"># curvature_steps.append(np.nanmean(np.abs(h)))</span>
            <span class="c1"># max_curvature_steps.append(np.nanmax(np.abs(h)))</span>
            
            <span class="c1"># more robust:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">principal_curvature</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
            <span class="n">h2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span><span class="p">)</span>
            <span class="n">curvature_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h2</span><span class="p">)))</span>
            <span class="n">max_curvature_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h2</span><span class="p">)))</span>
            
            <span class="c1"># this is the best. </span>
            <span class="n">kk</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">gaussian_curvature</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
            <span class="n">gauss_curvature_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kk</span><span class="p">)))</span>
            
            <span class="c1"># if rescale_output: </span>
            <span class="c1">#     # # x area + c</span>
            <span class="c1">#     # c0 = c0 + c</span>
            <span class="c1">#     area0 = area0*np.sqrt(area)</span>
            <span class="c1">#     Usteps[...,ii+1] = U * area0 #+ c0[None,:]).copy() # since it is just iterative... </span>
            <span class="c1"># else:</span>
            <span class="c1">#     Usteps[...,ii+1] = U.copy() # copy the current iteration into it. </span>
            <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># c_all = np.vstack(c_all)</span>
    <span class="n">area_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">area_all</span><span class="p">)</span>
    <span class="n">Usteps</span> <span class="o">=</span> <span class="n">Usteps</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">area_all</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="c1"># if rescale_output == False:</span>
    <span class="c1">#     # area = np.sum(igl.doublearea(Usteps[...,0],SF)*0.5); # original area. </span>
    <span class="c1">#     # c = np.sum((0.5*igl.doublearea(Usteps[...,0],SF)/area)[...,None] * igl.barycenter(Usteps[...,0],SF), axis=0);</span>
    <span class="c1">#     # below is more easy to get back </span>
    <span class="c1">#     area = area_all[0] # this is wrong? # -&gt; this might be the problem ... we should have the same as number of iterations. </span>
    <span class="c1">#     # c = c_all[0]</span>
    <span class="c1">#     # print(area, c)</span>
    <span class="c1">#     # if nargout &gt; 1</span>
    <span class="c1">#     for iteration in range(Usteps.shape[-1]-1):</span>
    <span class="c1">#         Usteps[:,:,iteration+1] = Usteps[:,:,iteration+1]*np.sqrt(area);</span>
    <span class="c1">#         # Usteps[:,:,iteration+1] = Usteps[:,:,iteration+1] + c[None,:]</span>

    <span class="c1"># # finally multiply all Usteps by umax</span>
    <span class="c1"># Usteps = Usteps * V0_max</span>
    <span class="n">Usteps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Usteps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># to save the key parameters that we will make use of .... </span>
    <span class="n">flow_metrics_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean_curvature_iter&#39;</span><span class="p">:</span> <span class="n">curvature_steps</span><span class="p">,</span> 
                         <span class="s1">&#39;max_curvature_iter&#39;</span><span class="p">:</span> <span class="n">max_curvature_steps</span><span class="p">,</span> 
                         <span class="s1">&#39;gauss_curvature_iter&#39;</span><span class="p">:</span> <span class="n">gauss_curvature_steps</span><span class="p">,</span> 
                         <span class="s1">&#39;canonical_c_all&#39;</span><span class="p">:</span> <span class="n">c_all</span><span class="p">,</span> 
                         <span class="s1">&#39;canonical_area_all&#39;</span><span class="p">:</span> <span class="n">area_all</span><span class="p">,</span> 
                         <span class="s1">&#39;flow_d_all&#39;</span><span class="p">:</span> <span class="n">d_all</span><span class="p">,</span>
                         <span class="s1">&#39;V0_max&#39;</span><span class="p">:</span> <span class="n">V0_max</span><span class="p">}</span>
    
    <span class="k">return</span> <span class="n">Usteps</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">flow_metrics_dict</span></div>


<div class="viewcode-block" id="recover_img_coordinate_conformal_mean_flow"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.recover_img_coordinate_conformal_mean_flow">[docs]</a><span class="k">def</span> <span class="nf">recover_img_coordinate_conformal_mean_flow</span><span class="p">(</span><span class="n">Usteps</span><span class="p">,</span> <span class="n">flow_dict</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This function reverses the iterative, centroid computation, subtraction and area normalisation in the conformalized mean curvature flow of a general 3D mesh, :func:`unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow`</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Usteps : (n_vertices,3,niters) array</span>
<span class="sd">        the area normalised vertex positions of a 3D mesh for every iteration of the conformalized mean curvature flow. 1st output of :func:`unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow` computed with rescale_output=False</span>
<span class="sd">    flow_dict : </span>
<span class="sd">        the statistical measures of a mesh deformed under conformalized mean curvature flow. 3rd output of :func:`unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow`</span>
<span class="sd">        </span>
<span class="sd">        &#39;mean_curvature_iter&#39; : array</span>
<span class="sd">            mean of absolute values of mean curvature per face per iteration </span>
<span class="sd">        &#39;max_curvature_iter&#39; : array</span>
<span class="sd">            maximum of absolute values of mean curvature per face per iteration </span>
<span class="sd">        &#39;gauss_curvature_iter&#39; : array</span>
<span class="sd">            mean of absolute values of Gaussian curvature per face per iteration </span>
<span class="sd">        &#39;canonical_c_all&#39; : array</span>
<span class="sd">            array of the computed face area weighted centroid per iteration with respect to an area normalised mesh</span>
<span class="sd">        &#39;canonical_area_all&#39; : array </span>
<span class="sd">            array of the total surface area used for area normalising per iteration</span>
<span class="sd">        &#39;flow_d_all&#39; : array</span>
<span class="sd">            matrix norm difference between current and previous vertex coordinate positions</span>
<span class="sd">        &#39;V0_max&#39; : scalar</span>
<span class="sd">            the maximum scalar value over all coordinate values used to initially scale the mesh vertices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Usteps_ : (n_vertices,3,niters) array</span>
<span class="sd">        the reconstructed image vertex positions of a 3D mesh for every iteration of the conformalized mean curvature flow, identical to if :func:`unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow` had been run with rescale_output=True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="c1"># in the default case, all the secondary points have recovered </span>
    <span class="n">sqrt_area_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;canonical_area_all&#39;</span><span class="p">]))</span> <span class="c1"># this is not such an easy scaling factor..... </span>
    <span class="n">c_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;canonical_c_all&#39;</span><span class="p">])</span>
    <span class="n">U_max</span> <span class="o">=</span> <span class="n">flow_dict</span><span class="p">[</span><span class="s1">&#39;V0_max&#39;</span><span class="p">]</span>

    <span class="n">cum_area_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">sqrt_area_all</span><span class="p">)</span> <span class="c1"># this should be cumulative. </span>
    <span class="n">cum_c_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">Usteps_</span> <span class="o">=</span> <span class="n">Usteps</span> <span class="o">/</span> <span class="n">U_max</span> <span class="c1"># first divide this. </span>
    <span class="n">Usteps_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Usteps_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">cum_c_all</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">,:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="n">cum_area_all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># remove... </span>
    <span class="n">Usteps_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Usteps_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cum_area_all</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]))</span> <span class="o">+</span> <span class="n">cum_c_all</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># multiply first.</span>
    <span class="n">Usteps_</span> <span class="o">=</span> <span class="n">Usteps_</span><span class="o">*</span><span class="n">U_max</span>

    <span class="k">return</span> <span class="n">Usteps_</span></div>


<div class="viewcode-block" id="relax_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.relax_mesh">[docs]</a><span class="k">def</span> <span class="nf">relax_mesh</span><span class="p">(</span> <span class="n">mesh_in</span><span class="p">,</span> <span class="n">relax_method</span><span class="o">=</span><span class="s1">&#39;CVT (block-diagonal)&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span> <span class="n">n_iters</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; wraps the optimesh library to perform mesh relaxation with Delaunay edge flipping. This is done mainly to improve triangle quality to improve the convergence of linear algebra solvers </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh_in : trimesh.Trimesh</span>
<span class="sd">        input mesh to relax</span>
<span class="sd">    relax_method : str</span>
<span class="sd">        any of those compatible with optimesh.optimize()</span>
<span class="sd">    tol : scalar</span>
<span class="sd">        sets the accepted tolerance for convergence</span>
<span class="sd">    n_iters : int</span>
<span class="sd">        the maximum number of iterations</span>
<span class="sd">    omega : scalar</span>
<span class="sd">        controls the stepping size, smaller values will have better accuracy but slower convergence.</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        output relaxed mesh with no change in the number of vertices but with changes to faces</span>
<span class="sd">    opt_result : optimization results</span>
<span class="sd">        returns tuple of number of iterations and difference </span>
<span class="sd">    mean_mesh_quality : scalar</span>
<span class="sd">        mean triangle quanlity, where trangle quality is 2*inradius/circumradius</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">optimesh</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">meshplex</span> 

    <span class="n">points</span> <span class="o">=</span> <span class="n">mesh_in</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="n">mesh_in</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">meshplex</span><span class="o">.</span><span class="n">MeshTri</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
    <span class="n">opt_result</span> <span class="o">=</span> <span class="n">optimesh</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">relax_method</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">max_num_steps</span><span class="o">=</span><span class="n">n_iters</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>
    <span class="n">mean_mesh_quality</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">q_radius_ratio</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="c1"># give back the mesh. </span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="s1">&#39;points&#39;</span><span class="p">),</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># suppress any other processing to keep the correct lookup.</span>

    <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">opt_result</span><span class="p">,</span> <span class="n">mean_mesh_quality</span></div>


<div class="viewcode-block" id="smooth_scalar_function_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.smooth_scalar_function_mesh">[docs]</a><span class="k">def</span> <span class="nf">smooth_scalar_function_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">scalar_fn</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_iters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; wraps the optimesh library to perform mesh relaxation with Delaunay edge flipping. This is done mainly to improve triangle quality to improve the convergence of linear algebra solvers </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh</span>
<span class="sd">    scalar_fn : (n_vertices,d) array</span>
<span class="sd">        the d-dimensional scalar values to spatially smooth over the mesh  </span>
<span class="sd">    exact : bool</span>
<span class="sd">        if True, evaluates the normalised :math:`M^-1 L` where :math:`M` is the mass and :math:`L` is the cotan Laplacian matrices respectively and uses this as the weights for spatial smoothing. The inversion is very slow. Setting to False, use the cotan Laplacian to smooth. </span>
<span class="sd">    n_iters : int</span>
<span class="sd">        the maximum number of iterations</span>
<span class="sd">    weights : (n_vertices,n_vertices) sparse array</span>
<span class="sd">        user-specified vertex smoothing matrix. This overrides the options of ``exact``. </span>
<span class="sd">    return_weights : bool</span>
<span class="sd">        return additionally the weights matrix used as a second optional output</span>
<span class="sd">    alpha : 0-1 scalar</span>
<span class="sd">        not used at present</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    scalar0 : (n_vertices,d) array</span>
<span class="sd">        the spatially smoothed d-dimensional scalar values over the mesh </span>
<span class="sd">    weights : (n_vertices,n_vertices) sparse array</span>
<span class="sd">        if return_weights=True, the weights used is returned for convenience if the user wishes to reuse the weights e.g. to avoid recomputing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If exact we use M-1^L else we use the cotangent laplacian which is super fast with no inversion required. </span>
<span class="sd">    allow optional usage of weights. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    
    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">scalar0</span> <span class="o">=</span> <span class="n">scalar_fn</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># # if ii ==0:</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> 
                       <span class="n">f</span><span class="p">,</span> 
                       <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_BARYCENTRIC</span><span class="p">)</span> <span class="c1"># -&gt; this is the only matrix that doesn&#39;t degenerate.            </span>
    
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># t1 = time.time()</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span> <span class="c1"># m_inv_l # this inversion is slow.....  the results for me is very similar....  but much slower!. </span>
            <span class="c1"># print(&#39;matrix inversion for weights in: &#39;, time.time() - t1,&#39;s&#39;) # 65s? </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">L</span>
        
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_iters</span><span class="p">):</span>
        
        <span class="n">scalar0_next</span> <span class="o">=</span>  <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scalar0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span> 
        <span class="n">scalar0_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scalar0_next</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">scalar0_next</span> <span class="o">=</span> <span class="n">scalar0_next</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">scalar_fn</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">scalar0</span> <span class="o">=</span> <span class="n">scalar0_next</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># print(kappa0_next.shape)</span>
        
    <span class="n">scalar0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scalar0</span><span class="p">)</span>
    <span class="c1"># case to numpy array and return</span>
    <span class="k">if</span> <span class="n">return_weights</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scalar0</span><span class="p">,</span> <span class="n">weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scalar0</span></div>


<div class="viewcode-block" id="connected_components_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.connected_components_mesh">[docs]</a><span class="k">def</span> <span class="nf">connected_components_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">original_face_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_len</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; find the connected face components given a mesh or submesh</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh, </span>
<span class="sd">    original_face_indices : (N,) array</span>
<span class="sd">        if provided these should be the original face indices that mesh.faces come from. The final connected components will be re-indexed with the provided original_face_indices. </span>
<span class="sd">    engine : str</span>
<span class="sd">        Which graph engine to use (&#39;scipy&#39;, &#39;networkx&#39;)</span>
<span class="sd">    min_len : int</span>
<span class="sd">        the minimum number of faces in a connected component. Those with a number of faces that these will be dropped</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    components : list of arrays</span>
<span class="sd">        list of an array of face indices forming a connected component </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span>
                <span class="n">edges</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">face_adjacency</span><span class="p">,</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span>
                <span class="n">min_len</span><span class="o">=</span><span class="n">min_len</span><span class="p">,</span> <span class="c1"># this makes sure we don&#39;t exclude everything!. by setting this to 1!!!! c.f. trimesh definitions. </span>
                <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

    <span class="c1"># if the original_face_indices is provided, then the mesh was formed as a subset of the triangles and we want to get this back!. </span>
    <span class="k">if</span> <span class="n">original_face_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_face_indices</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span> <span class="c1"># remap to the original indexing</span>

    <span class="k">return</span> <span class="n">components</span></div>


<div class="viewcode-block" id="get_k_neighbor_ring"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.get_k_neighbor_ring">[docs]</a><span class="k">def</span> <span class="nf">get_k_neighbor_ring</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stateful</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find all vertex indices within a K-ring neighborhood of individual vertices of a mesh. For a vertex its K-Neighbors are all those of maximum length K edges away. The result is return as an adjacency list</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh, </span>
<span class="sd">    K : int</span>
<span class="sd">        the maximum distance of a topological neighbor defined by the number of edge-hops away. </span>
<span class="sd">    stateful : bool</span>
<span class="sd">        if True, returns list of adjacency lists for all neighborhoods k=1..to..K. if False, only the asked for K neighborhood is returned.</span>
<span class="sd">    </span>
<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    k_rings : (n_vertex long adjacency list) or (list of n_vertex long adjacency list)</span>
<span class="sd">        if stateful=False, one adjacency list for the specified K of length n_vertex is returned else all list of adjacency lists for all neighborhoods k=1..to..K is provided</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># by default we only compute the 1_ring</span>
    <span class="c1"># if return_sparse_matrix then map tp adjacency ..... </span>
    <span class="c1"># if stateful return list if k&gt;1 </span>

    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">)</span> <span class="c1"># build edges .</span>
    <span class="n">one_ring</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">))]</span> <span class="c1"># one neighborhood.... </span>
    
    <span class="k">if</span> <span class="n">K</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">k_rings</span> <span class="o">=</span> <span class="p">[</span><span class="n">one_ring</span><span class="p">]</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="n">K</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">iter_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
            <span class="n">k_ring</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">one_ring</span><span class="p">[</span><span class="n">rrr</span><span class="p">]</span> <span class="k">for</span> <span class="n">rrr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">k_rings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">rr</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">one_ring</span><span class="p">))]</span>    
            <span class="n">k_ring</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([(</span><span class="n">k_rings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">rr_ii</span><span class="p">],</span> <span class="n">k_ring</span><span class="p">[</span><span class="n">rr_ii</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">rr_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k_ring</span><span class="p">))]</span> <span class="c1"># make sure the previous was covered. </span>
            
            <span class="n">k_rings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k_ring</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">stateful</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">k_rings</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k_rings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">k_rings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">k_rings</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k_rings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">one_ring</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k_rings</span></div>


<span class="c1"># # edge_list to sparse matrix. ?</span>
<span class="c1"># def edge_list_to_matrix(edge_list):</span>
<span class="c1">#     r&quot;&quot;&quot; Function to convert a given list or array of edge connections to an adjacency matrix where 1 denotes the presence of an edge between </span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     import scipy.sparse as spsparse    </span>
<span class="c1">#     import numpy as np </span>
    
<span class="c1">#     row_inds = np.hstack([[ii]*len(edge_list[ii]) for ii in len(edge_list)])</span>
<span class="c1">#     col_inds = np.hstack(edge_list)</span>
<span class="c1">#     # crucial third array in python, which can be left out in r</span>
<span class="c1">#     ones = np.ones(len(row_inds), np.uint32)</span>
<span class="c1">#     matrix = spsparse.csr_matrix((ones, (row_inds, col_inds)))</span>
    
<span class="c1">#     return matrix # useful for clustering applications. and for saving .... </span>


<div class="viewcode-block" id="find_central_ind"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.find_central_ind">[docs]</a><span class="k">def</span> <span class="nf">find_central_ind</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex_components_indices</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a list of mesh patches in the form of vertex indices of the mesh, find the index on the mesh surface for each patch that is closest to the patch centroid. This assumes that each patch is local such that the patch centroid is covered by the convex hull.</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertex,3)</span>
<span class="sd">        vertices of the full 3D mesh</span>
<span class="sd">    vertex_components_indices : list of arrays </span>
<span class="sd">        list of patches, where each patch is given as vertex indices into ``v``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    central_inds : (n_components,)</span>
<span class="sd">        an array the same number as the given vertex patches/components given the index into ``v`` closest to the geometrical centroid of the vertex component</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">central_inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component_inds</span> <span class="ow">in</span> <span class="n">vertex_components_indices</span><span class="p">:</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">component_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mean_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">central_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component_inds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">verts</span> <span class="o">-</span> <span class="n">mean_verts</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]))])</span>
    <span class="n">central_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">central_inds</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">central_inds</span></div>

<div class="viewcode-block" id="compute_geodesic_sources_distance_on_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.compute_geodesic_sources_distance_on_mesh">[docs]</a><span class="k">def</span> <span class="nf">compute_geodesic_sources_distance_on_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">source_vertex_indices</span><span class="p">,</span> <span class="n">t_diffuse</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="n">return_solver</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;heat&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the geodesic distance of all vertex points on a mesh to given sources using the fast approximate vector heat method of Crane et al. [1]_, [2]_ or using exact Djikstras shortest path algorithm</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh </span>
<span class="sd">    source_vertex_indices : list of arrays</span>
<span class="sd">        List of individual &#39;sources&#39; specifying multiple sources to compute distance from. Sources are vertex points where the geodesic distance are 0. The vector heat method, method=&#39;heat&#39; allows arrays to describe individual sources as non-point like. if method=&#39;exact&#39;, multipoint sources are reduced to a central single-point source   </span>
<span class="sd">    t_diffuse : scalar</span>
<span class="sd">        set the time used for short-time heat flow in method=&#39;heat&#39;. Larger values may make the solution more stable at the cost of over-smoothing</span>
<span class="sd">    return_solver : bool</span>
<span class="sd">        if True, return the solver used in the vector heat method, see https://github.com/nmwsharp/potpourri3d</span>
<span class="sd">    method : str</span>
<span class="sd">        specifies the geodesic distance computation method. either of &#39;heat&#39; for vector heat or &#39;exact&#39; for Djikstra</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if method == &#39;heat&#39; :</span>
<span class="sd">        geodesic_distances_components : (n_sources, n_vertex) array</span>
<span class="sd">            the geodesic distance of each vertex point of the mesh to each of the sources specified in ``source_vertex_indices``</span>
<span class="sd">        solver : potpourri3d MeshHeatMethodDistanceSolver instance </span>
<span class="sd">            if return_solver=True, return the vector heat solver used for geodesic distance computation </span>

<span class="sd">    if method == &#39;exact&#39; :</span>
<span class="sd">        distances : (n_vertex,) array</span>
<span class="sd">            an array of the shortest geodesic distance to any source for each vertex</span>
<span class="sd">        best_source : (n_vertex,) array</span>
<span class="sd">            the id of the closest source for each vertex</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Crane, Keenan, Clarisse Weischedel, and Max Wardetzky. &quot;The heat method for distance computation.&quot; Communications of the ACM 60.11 (2017): 90-99.</span>
<span class="sd">    .. [2] Sharp, Nicholas, Yousuf Soliman, and Keenan Crane. &quot;The vector heat method.&quot; ACM Transactions on Graphics (TOG) 38.3 (2019): 1-19.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> <span class="c1"># igl version is incredibly slow!. use nick sharps potpourri3D! </span>
    <span class="c1"># import potpourri3d as pp3d</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 

    <span class="c1"># geodesic_distances_components = [igl.heat_geodesic(v=v, </span>
    <span class="c1">#                                                    f=f, </span>
    <span class="c1">#                                                    t=t_diffuse, </span>
    <span class="c1">#                                                    gamma=np.array(cc)) for cc in source_vertex_indices]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;heat&#39;</span><span class="p">:</span>
        
        <span class="kn">import</span> <span class="nn">potpourri3d</span> <span class="k">as</span> <span class="nn">pp3d</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">pp3d</span><span class="o">.</span><span class="n">MeshHeatMethodDistanceSolver</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">t_coef</span><span class="o">=</span><span class="n">t_diffuse</span><span class="p">)</span>
        <span class="n">geodesic_distances_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">solver</span><span class="o">.</span><span class="n">compute_distance_multisource</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">source_vertex_indices</span><span class="p">]</span>
        <span class="n">geodesic_distances_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geodesic_distances_components</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_solver</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">solver</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geodesic_distances_components</span>
        
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;exact&#39;</span><span class="p">:</span>
        <span class="c1"># use the very fast method in pygeodesic.</span>
        <span class="kn">import</span> <span class="nn">pygeodesic.geodesic</span> <span class="k">as</span> <span class="nn">geodesic</span>
        <span class="n">geoalg</span> <span class="o">=</span> <span class="n">geodesic</span><span class="o">.</span><span class="n">PyGeodesicAlgorithmExact</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        
        <span class="n">source_centre_vertex_indices</span> <span class="o">=</span> <span class="n">find_central_ind</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">source_vertex_indices</span><span class="p">)</span>
        <span class="n">source_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_centre_vertex_indices</span><span class="p">)</span> <span class="c1"># just one ind per component. </span>
        <span class="n">target_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">best_source</span> <span class="o">=</span> <span class="n">geoalg</span><span class="o">.</span><span class="n">geodesicDistances</span><span class="p">(</span><span class="n">source_indices</span><span class="p">,</span> <span class="n">target_indices</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">best_source</span></div>


<span class="c1"># using the above we can do watershed with seed regions and optional masks.... </span>
<div class="viewcode-block" id="mesh_watershed_segmentation_faces"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.mesh_watershed_segmentation_faces">[docs]</a><span class="k">def</span> <span class="nf">mesh_watershed_segmentation_faces</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">face_components</span><span class="p">,</span> <span class="n">t_diffuse</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="n">mesh_face_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_solver</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;heat&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Do marker seeded watershed segmentation on the mesh by assigning individual faces to the user provided &#39;seeds&#39; or sources by geodesic distance. Output is an integer label for each mesh face with -1 denoting a user masked out face.    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        input mesh </span>
<span class="sd">    face_components : list of arrays</span>
<span class="sd">        the seeds or &#39;sources&#39; given as a list of face index components</span>
<span class="sd">    t_diffuse : scalar </span>
<span class="sd">        set the time used for short-time heat flow in method=&#39;heat&#39;. Larger values may make the solution more stable at the cost of over-smoothing</span>
<span class="sd">    mesh_face_mask : (n_faces,) array</span>
<span class="sd">        a binary array 0 or 1 specifying which faces should not be included in the final labels. Masked out faces are assigned a label of -1, whereas all valid labels are integer 0 or above. </span>
<span class="sd">    return_solver : bool</span>
<span class="sd">        if True, return the solver used in the vector heat method, see https://github.com/nmwsharp/potpourri3d</span>
<span class="sd">    method : str</span>
<span class="sd">        specifies the geodesic distance computation method. either of &#39;heat&#39; for vector heat or &#39;exact&#39; for Djikstra</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    geodesic_distances_components : (n_faces,) array</span>
<span class="sd">        for each face, the geodesic distance to the assigned source</span>
<span class="sd">    geodesic_distances_label : (n_faces,) array</span>
<span class="sd">        for each faces, the id of the source assigned </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># also see. https://pypi.org/project/pygeodesic/</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span> 

    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 

    <span class="c1"># convert the face to vertex components for processing</span>
    <span class="n">vertex_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">ff_c</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="k">for</span> <span class="n">ff_c</span> <span class="ow">in</span> <span class="n">face_components</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;heat&#39;</span><span class="p">:</span>
        <span class="c1"># give the face components directly in terms of the original mesh indices. </span>
        <span class="k">if</span> <span class="n">return_solver</span><span class="p">:</span>
            <span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">heat_solver</span> <span class="o">=</span> <span class="n">compute_geodesic_sources_distance_on_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">vertex_components</span><span class="p">,</span> <span class="n">t_diffuse</span><span class="o">=</span><span class="n">t_diffuse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geodesic_distances_components</span> <span class="o">=</span> <span class="n">compute_geodesic_sources_distance_on_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">vertex_components</span><span class="p">,</span> <span class="n">t_diffuse</span><span class="o">=</span><span class="n">t_diffuse</span><span class="p">)</span>
        <span class="c1"># average onto the faces. </span>
        <span class="c1"># use the average onto faces to get n_components x n_faces. </span>
        <span class="n">geodesic_distances_components</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_faces</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">geodesic_distances_components</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># assign to nearest neighbor. </span>
        <span class="n">geodesic_distances_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="c1"># apply mask if exists.</span>
        <span class="k">if</span> <span class="n">mesh_face_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geodesic_distances_label</span><span class="p">[</span><span class="n">mesh_face_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># assign this negative.</span>
    
        <span class="c1"># return the original distance computations as well as the nearest neighbor. </span>
        <span class="k">if</span> <span class="n">return_solver</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">geodesic_distances_label</span><span class="p">,</span> <span class="n">heat_solver</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">geodesic_distances_label</span>
        
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span><span class="s1">&#39;exact&#39;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">spstats</span>
        <span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">geodesic_distances_label</span> <span class="o">=</span> <span class="n">compute_geodesic_sources_distance_on_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">vertex_components</span><span class="p">,</span> <span class="n">t_diffuse</span><span class="o">=</span><span class="n">t_diffuse</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="c1"># project onto faces.</span>
        <span class="n">geodesic_distances_components</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_faces</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">geodesic_distances_components</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        
        <span class="n">geodesic_distances_label</span> <span class="o">=</span> <span class="n">spstats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span> <span class="n">geodesic_distances_label</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">geodesic_distances_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">geodesic_distances_label</span><span class="p">)</span>
    
        <span class="c1"># apply mask if exists.</span>
        <span class="k">if</span> <span class="n">mesh_face_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geodesic_distances_label</span><span class="p">[</span><span class="n">mesh_face_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># assign this negative.</span>
            
        <span class="k">return</span> <span class="n">geodesic_distances_components</span><span class="p">,</span> <span class="n">geodesic_distances_label</span></div>
    

<div class="viewcode-block" id="find_curvature_cutoff_index"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.find_curvature_cutoff_index">[docs]</a><span class="k">def</span> <span class="nf">find_curvature_cutoff_index</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absval</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; For a given array of values, find the first index where the difference or absolute difference between two values falls below a threshold value. This function can be used to find the stopping iteration number for conformalized mean curvature smoothing based on the dcrease in absolute Gaussian curvature. If no such index can be found then np.nan is returned</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values : (N,) array</span>
<span class="sd">        1d array of values </span>
<span class="sd">    thresh : scalar</span>
<span class="sd">        the cutoff value threshold where we return the index where values &lt;= thresh. If None, the median of np.diff(values) is used. </span>
<span class="sd">    absval : bool </span>
<span class="sd">        determine whether the cut-off is on the absolute differences in value or differences in value </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ind : int</span>
<span class="sd">        if an index is found return an int otherwise return np.nan</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absval</span><span class="p">:</span>
        <span class="n">diff_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">))[</span><span class="n">diff_values</span><span class="o">&lt;=</span><span class="n">thresh</span><span class="p">]</span>
    <span class="c1"># print(ind, thresh)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># couldn&#39;t find one -&gt; means more runs of flow is required. </span>

    <span class="k">return</span> <span class="n">ind</span> </div>

<div class="viewcode-block" id="average_onto_barycenter"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.average_onto_barycenter">[docs]</a><span class="k">def</span> <span class="nf">average_onto_barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">vals</span><span class="p">,</span> <span class="n">return_barycenter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Convert vertex values to face values by barycentric averaging of multi-dimensional vertex-associated values. This function does not work for segmentation labels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array</span>
<span class="sd">        the vertices of the 3D mesh </span>
<span class="sd">    f : array</span>
<span class="sd">        the faces of the 3D mesh specified by vertex indices</span>
<span class="sd">    vals : (n_vertex, d) array</span>
<span class="sd">        the multi-dimensional values associated with each vertex to convert to face values</span>
<span class="sd">    return_barycenter : bool</span>
<span class="sd">        if True, return the barycenter coordinates</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    barycenter_vals_f : (n_faces,d) array</span>
<span class="sd">        the face-associated resampling of the input vertex-associated ``vals``</span>
<span class="sd">    barycenter : (n_faces,3) array</span>
<span class="sd">        the barycenter coordinates of the mesh</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vals_</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vals_</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">barycenter</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
    <span class="n">vals_f</span> <span class="o">=</span> <span class="n">vals_</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">barycenter_vals_f</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">vals_f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">vals_f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">vals_f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> 

    <span class="k">return</span> <span class="n">barycenter_vals_f</span><span class="p">,</span> <span class="n">barycenter</span> </div>


<div class="viewcode-block" id="find_principal_axes_surface_heterogeneity"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity">[docs]</a><span class="k">def</span> <span class="nf">find_principal_axes_surface_heterogeneity</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">pts_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">map_to_sphere</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ascending&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find the principal axes of a point cloud given individual weights for each point. If weights are not given, every point is weighted equally  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts : array</span>
<span class="sd">        the coordinates of a point cloud</span>
<span class="sd">    pts_weights : array</span>
<span class="sd">        the positive weights specifying the importance of each point in the principal axes computation </span>
<span class="sd">    map_to_sphere : bool</span>
<span class="sd">        if True, the unit sphere coordinate by projecting each point by distance normalization to compute principal axes. This enables geometry-independent computation useful for e.g. getting directional alignment based only on surface intensity</span>
<span class="sd">    sort : &#39;ascending&#39; or &#39;descending&#39;</span>
<span class="sd">        the sorting order of the eigenvectors in terms of the absolute value of the respective eigenvalues</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (d,) array</span>
<span class="sd">        the sorted eigenvalues of the principal eigenvectors of the d-dimensional point cloud</span>
<span class="sd">    v : (d,d) array</span>
<span class="sd">        the sorted eigenvectors of the corresponding eigenvalues</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface` : </span>
<span class="sd">        Equivalent for finding the principal eigenvectors when give a uv parametrized surface of xyz coordinates.</span>
<span class="sd">    :func:`unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh` : </span>
<span class="sd">        Equivalent for finding the principal eigenvectors when give a 3D triangle mesh.         </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    weights should be positive. map_to_sphere so as not to be affected by geometry / reduce this.  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="k">if</span> <span class="n">pts_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">pts_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
    <span class="n">pts_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># this shouldn&#39;t have weighting </span>
    <span class="c1"># # compute the weighted centroid. </span>
    <span class="c1"># pts_mean = np.nansum(pts * pts_weights[:,None]/ float(np.sum(pts_weights)), axis=0)</span>
    <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">-</span> <span class="n">pts_mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

    <span class="k">if</span> <span class="n">map_to_sphere</span><span class="p">:</span>
        <span class="c1"># r =  np.linalg.norm(pts_demean, axis=-1)</span>
        <span class="c1"># theta = np.arctan2(pts_demean[:,1], pts_demean[:,0])</span>
        <span class="c1"># phi = np.arccos(pts_demean[:,2] / r)</span>

        <span class="c1"># construct a new version with 0 magnitude? </span>
        <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts_demean</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts_demean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

    <span class="c1"># apply the weighting </span>
    <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts_demean</span> <span class="o">*</span> <span class="n">pts_weights</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pts_weights</span><span class="p">))</span>
    <span class="n">pts_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">pts_demean</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># 3x3 matrix #-&gt; expect symmetric. </span>

    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">pts_cov</span><span class="p">)</span>
    <span class="c1"># sort large to small. </span>
    <span class="k">if</span> <span class="n">sort</span><span class="o">==</span><span class="s1">&#39;descending&#39;</span><span class="p">:</span>
        <span class="n">w_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sort</span><span class="o">==</span><span class="s1">&#39;ascending&#39;</span><span class="p">:</span>
        <span class="n">w_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">w_sort</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="n">w_sort</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> </div>


<div class="viewcode-block" id="find_principal_axes_surface_heterogeneity_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh">[docs]</a><span class="k">def</span> <span class="nf">find_principal_axes_surface_heterogeneity_mesh</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">map_to_sphere</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="s1">&#39;ascending&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find the principal axes of a mesh given individual weights for each vertex. If weights are not given, every vertex is weighted equally  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array</span>
<span class="sd">        the vertex cordinates of the 3D mesh</span>
<span class="sd">    f : array</span>
<span class="sd">        the faces of the 3D mesh specified by vertex indices</span>
<span class="sd">    v_weights : array</span>
<span class="sd">        the positive weights specifying the importance of each vertex in the principal axes computation </span>
<span class="sd">    map_to_sphere : bool</span>
<span class="sd">        if True, the unit sphere coordinate by projecting each vertex by distance normalization to compute principal axes. This enables geometry-independent computation useful for e.g. getting directional alignment based only on surface intensity</span>
<span class="sd">    sort : &#39;ascending&#39; or &#39;descending&#39;</span>
<span class="sd">        the sorting order of the eigenvectors in terms of the absolute value of the respective eigenvalues</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (d,) array</span>
<span class="sd">        the sorted eigenvalues of the principal eigenvectors of the d-dimensional point cloud</span>
<span class="sd">    v : (d,d) array</span>
<span class="sd">        the sorted eigenvectors of the corresponding eigenvalues</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface` : </span>
<span class="sd">        Equivalent for finding the principal eigenvectors when give a uv parametrized surface of xyz coordinates.</span>
<span class="sd">    :func:`unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh` : </span>
<span class="sd">        Equivalent for finding the principal eigenvectors when give a 3D triangle mesh.         </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    weights should be positive. map_to_sphere so as not to be affected by geometry / reduce this.  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span> 

    <span class="c1"># pts = v.copy()</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
    <span class="c1"># pts_mean = np.mean(pts, axis=0) # use the barycenter? </span>
    <span class="n">pts_area_weights</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
    <span class="n">pts_area_weights</span> <span class="o">=</span> <span class="n">pts_area_weights</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">pts_area_weights</span><span class="p">))</span>
    <span class="n">pts_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pts</span><span class="o">*</span><span class="n">pts_area_weights</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">-</span> <span class="n">pts_mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

    <span class="k">if</span> <span class="n">map_to_sphere</span><span class="p">:</span>
        <span class="c1"># r =  np.linalg.norm(pts_demean, axis=-1)</span>
        <span class="c1"># theta = np.arctan2(pts_demean[:,1], pts_demean[:,0])</span>
        <span class="c1"># phi = np.arccos(pts_demean[:,2] / r)</span>

        <span class="c1"># construct a new version with 0 magnitude? </span>
        <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts_demean</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pts_demean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

    <span class="c1"># unweighted version. </span>
    <span class="n">v_weights_barycenter</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">average_onto_faces</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v_weights</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
    <span class="n">v_weights_</span> <span class="o">=</span> <span class="n">v_weights_barycenter</span><span class="o">*</span><span class="n">pts_area_weights</span>
    <span class="n">pts_demean</span> <span class="o">=</span> <span class="n">pts_demean</span> <span class="o">*</span> <span class="n">v_weights_</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v_weights_</span><span class="p">))</span>
    <span class="n">pts_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">pts_demean</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># 3x3 matrix #-&gt; expect symmetric. </span>

    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">pts_cov</span><span class="p">)</span>
    <span class="c1"># sort large to small. </span>
    <span class="k">if</span> <span class="n">sort</span><span class="o">==</span><span class="s1">&#39;descending&#39;</span><span class="p">:</span>
        <span class="n">w_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sort</span><span class="o">==</span><span class="s1">&#39;ascending&#39;</span><span class="p">:</span>
        <span class="n">w_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">w_sort</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="n">w_sort</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span> </div>


<div class="viewcode-block" id="rescale_mesh_points_to_grid_size"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.rescale_mesh_points_to_grid_size">[docs]</a><span class="k">def</span> <span class="nf">rescale_mesh_points_to_grid_size</span><span class="p">(</span><span class="n">rect_mesh</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Give a rectangular-like mesh where the last 2 coordinate axes is the 2D xy coordinates such as that from a rectangular conformal map, resize points coordinates along x- and y- axes onto a given image grid so that we can for example interpolate mesh values onto an image</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rect_mesh : trimesh.Trimesh</span>
<span class="sd">        input 2D mesh where the first 2 coordinate axes is the 2D xy coordinates </span>
<span class="sd">    grid : (M,N) or (M,N,d) single- or multi- channel image </span>
<span class="sd">        input image to get the (M,N) shape</span>
<span class="sd">    grid_shape : (M,N) tuple</span>
<span class="sd">        the shape of the grid, only used if grid is not specified. Only one of grid or grid_shape needs to be passed </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mesh_ref : trimesh.Trimesh</span>
<span class="sd">        output 2D mesh with resized vertex coordinates where like input the last 2 coordinate axes is the 2D xy coordinates </span>
<span class="sd">    grid_shape : (M,N) tuple</span>
<span class="sd">        the shape of the image grid, the output mesh indexes into </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># either give a predefined image grid coordinates or grid_shape. </span>
    <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="c1"># m x n x 2</span>

    <span class="c1"># grid_pts = grid.reshape(-1,grid.shape[-1]) # make flat. </span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">rect_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># take just the last two axes. </span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">rect_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">scale_v_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">scale_v_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_v_0</span>
    <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_v_1</span> 
    
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">v</span><span class="p">])</span>
    <span class="n">mesh_ref</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh_ref</span><span class="p">,</span> <span class="n">grid_shape</span></div>


<div class="viewcode-block" id="match_and_interpolate_img_surface_to_rect_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.match_and_interpolate_img_surface_to_rect_mesh">[docs]</a><span class="k">def</span> <span class="nf">match_and_interpolate_img_surface_to_rect_mesh</span><span class="p">(</span><span class="n">rect_mesh</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale_mesh_pts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="s1">&#39;cross&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Match the grid of an image to the faces of a reference rectangular-like triangle mesh where the last 2 coordinate axes is the 2D xy coordinates to allow mapping of mesh measurements to an image</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rect_mesh : trimesh.Trimesh</span>
<span class="sd">        input 2D mesh where the first 2 coordinate axes is the 2D xy coordinates </span>
<span class="sd">    grid : (M,N) or (M,N,d) single- or multi- channel image </span>
<span class="sd">        input image to get the (M,N) shape</span>
<span class="sd">    grid_shape : (M,N) tuple</span>
<span class="sd">        the shape of the grid, only used if grid is not specified. Only one of grid or grid_shape needs to be passed </span>
<span class="sd">    rescale_mesh_pts : bool</span>
<span class="sd">        if True, the rect_mesh vertices are first rescaled in order to maximally cover the size of the intended image</span>
<span class="sd">    match_method : str</span>
<span class="sd">        one of &#39;cross&#39; implementing https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf or &#39;cramer&#39; implementing http://blackpawn.com/texts/pointinpoly for computing the barycentric coordinate after matching each image pixel to the rect_mesh</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tri_id : (MxN,)</span>
<span class="sd">        1d array giving the face index each image pixel maps to in the rect_mesh </span>
<span class="sd">    mesh_ref_closest_pt_barycentric : (MxN,3)</span>
<span class="sd">        the barycentric weights giving the position inside the matched triangle face, each image pixel maps to  </span>
<span class="sd">    grid_shape : (M,N) tuple</span>
<span class="sd">        the shape of the image grid</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="c1"># import pylab as plt </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># either give a predefined image grid coordinates or grid_shape. </span>
    <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="c1"># m x n x 2</span>

    <span class="c1"># grid_pts = grid.reshape(-1,grid.shape[-1]) # make flat. </span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">rect_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># take just the last two axes. </span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">rect_mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># print(v.shape)</span>

    <span class="k">if</span> <span class="n">rescale_mesh_pts</span><span class="p">:</span>
        <span class="n">scale_v_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">scale_v_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_v_0</span>
        <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_v_1</span> 
        
        <span class="c1"># fig, ax = plt.subplots()</span>
        <span class="c1"># ax.triplot(v[:,1], v[:,0], f, lw=.1)</span>
        <span class="c1"># ax.set_aspect(1)</span>
        <span class="c1"># plt.show()</span>
    <span class="c1"># we have to force this to make it 3D to leverage the functions.</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">v</span><span class="p">])</span>
    <span class="n">mesh_ref</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># create nearest lookup object </span>
    <span class="n">prox_mesh_ref</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">proximity</span><span class="o">.</span><span class="n">ProximityQuery</span><span class="p">(</span><span class="n">mesh_ref</span><span class="p">)</span> <span class="c1"># this is the lookup object.</span>
    <span class="c1"># get the closest point on the mesh to the unwrap_params surface  </span>

    <span class="n">grid_query</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">grid_query</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_query</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">grid_query</span><span class="p">])</span>
    <span class="n">closest_pt</span><span class="p">,</span> <span class="n">dist_pt</span><span class="p">,</span> <span class="n">tri_id</span> <span class="o">=</span> <span class="n">prox_mesh_ref</span><span class="o">.</span><span class="n">on_surface</span><span class="p">(</span><span class="n">grid_query</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get the barycentric for interpolation. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># given then triangle id, we can retrieve the corresponding vertex point and the corresponding vertex values to interpolate. </span>
    <span class="c1"># fetch the barycentric. </span>
    <span class="n">mesh_ref_tri_id_vertices</span> <span class="o">=</span> <span class="n">mesh_ref</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">mesh_ref</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">tri_id</span><span class="p">]]</span> <span class="c1"># get the vertex points (N,3) </span>
    
    <span class="c1"># convert to barycentric for each triangle which gives the interpolating weights. </span>
    <span class="n">mesh_ref_closest_pt_barycentric</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">triangles</span><span class="o">.</span><span class="n">points_to_barycentric</span><span class="p">(</span><span class="n">mesh_ref_tri_id_vertices</span><span class="p">,</span> 
                                                                              <span class="n">closest_pt</span><span class="p">,</span> 
                                                                              <span class="n">method</span><span class="o">=</span><span class="n">match_method</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tri_id</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span><span class="p">,</span> <span class="n">grid_shape</span></div>



<div class="viewcode-block" id="match_and_interpolate_uv_surface_to_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.match_and_interpolate_uv_surface_to_mesh">[docs]</a><span class="k">def</span> <span class="nf">match_and_interpolate_uv_surface_to_mesh</span><span class="p">(</span><span class="n">unwrap_params</span><span class="p">,</span> <span class="n">mesh_ref</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="s1">&#39;cross&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Match the grid of an image given by the shape of the uv unwrapped surface to a reference 3D triangle mesh based on nearest distance for reinterpolation of mesh measurements to unwrapped surface  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_params : (UxVx3) array </span>
<span class="sd">        the input 2D image specifying the uv unwrapped (x,y,z) surface </span>
<span class="sd">    mesh_ref : trimesh.Trimesh</span>
<span class="sd">        input 3D mesh we wish to match the coordinates of unwrap_params to, to allow barycentric interpolation </span>
<span class="sd">    match_method : str</span>
<span class="sd">        one of &#39;cross&#39; implementing https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf or &#39;cramer&#39; implementing http://blackpawn.com/texts/pointinpoly for computing the barycentric coordinate after matching each image pixel to the rect_mesh</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tri_id : (UxV,)</span>
<span class="sd">        1d array giving the face index each (u,v) image pixel maps to in ``mesh_ref``</span>
<span class="sd">    mesh_ref_closest_pt_barycentric : (UxV,3)</span>
<span class="sd">        the barycentric weights giving the position inside the matched triangle face, each (u,v) image pixel maps to     </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    we use the mesh as a reference </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>

    <span class="c1"># create nearest lookup object </span>
    <span class="n">prox_mesh_ref</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">proximity</span><span class="o">.</span><span class="n">ProximityQuery</span><span class="p">(</span><span class="n">mesh_ref</span><span class="p">)</span> <span class="c1"># this is the lookup object.</span>
    <span class="c1"># get the closest point on the mesh to the unwrap_params surface  </span>
    <span class="n">closest_pt</span><span class="p">,</span> <span class="n">dist_pt</span><span class="p">,</span> <span class="n">tri_id</span> <span class="o">=</span> <span class="n">prox_mesh_ref</span><span class="o">.</span><span class="n">on_surface</span><span class="p">(</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># given then triangle id, we can retrieve the corresponding vertex point and the corresponding vertex values to interpolate. </span>
    <span class="c1"># fetch the barycentric. </span>
    <span class="n">mesh_ref_tri_id_vertices</span> <span class="o">=</span> <span class="n">mesh_ref</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">mesh_ref</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">tri_id</span><span class="p">]]</span> <span class="c1"># get the vertex points (N,3) </span>
    
    <span class="c1"># convert to barycentric for each triangle which gives the interpolating weights. </span>
    <span class="n">mesh_ref_closest_pt_barycentric</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">triangles</span><span class="o">.</span><span class="n">points_to_barycentric</span><span class="p">(</span><span class="n">mesh_ref_tri_id_vertices</span><span class="p">,</span> 
                                                                              <span class="n">closest_pt</span><span class="p">,</span> 
                                                                              <span class="n">method</span><span class="o">=</span><span class="n">match_method</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tri_id</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span></div>


<div class="viewcode-block" id="mesh_vertex_interpolate_scalar"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.mesh_vertex_interpolate_scalar">[docs]</a><span class="k">def</span> <span class="nf">mesh_vertex_interpolate_scalar</span><span class="p">(</span><span class="n">mesh_ref</span><span class="p">,</span> <span class="n">mesh_tri_id</span><span class="p">,</span> <span class="n">mesh_tri_barycentric</span><span class="p">,</span> <span class="n">scalar_vals</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Interpolate vertex associated values associated with the vertices of a reference mesh onto a different geometry specified implicitly by the face id and barycentric coordinates the new geometry maps to in the reference mesh  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh_ref : trimesh.Trimesh</span>
<span class="sd">        input 3D mesh we wish to match the coordinates of unwrap_params to, to allow barycentric interpolation </span>
<span class="sd">    mesh_tri_id : (N,)</span>
<span class="sd">        1d array of the triangle face index in ``mesh_ref`` we want to interpolate ``scalar_vals`` on </span>
<span class="sd">    mesh_tri_barycentric : (N,3)</span>
<span class="sd">        the barycentric weights specifying the linear weighting of the vertex scalar_vals associated with the vertices of ``mesh_ref`` to compute the new scalar values</span>
<span class="sd">    scalar_vals : (n_vertices,d) </span>
<span class="sd">        the vertex associated measurements on the mesh_ref which is used to compute the new scalar values at the coordinate locations on the mesh specified by ``mesh_tri_id`` and ``mesh_tri_barycentric``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar_vals_interp : (N,d)</span>
<span class="sd">        the reinterpolated ``scalar_vals`` at the coordinate locations on the mesh specified by ``mesh_tri_id`` and ``mesh_tri_barycentric``</span>
<span class="sd">       </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">scalar_vals_tri</span> <span class="o">=</span> <span class="n">scalar_vals</span><span class="p">[</span><span class="n">mesh_ref</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">mesh_tri_id</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># N_faces x 3 x d </span>
    <span class="c1"># print(scalar_vals_tri.shape)</span>
    <span class="n">scalar_vals_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh_tri_barycentric</span><span class="p">[:,</span><span class="n">ch</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">scalar_vals_tri</span><span class="p">[:,</span><span class="n">ch</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mesh_ref</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">scalar_vals_interp</span></div>


<div class="viewcode-block" id="uv_surface_pulldown_mesh_surface_coords"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.uv_surface_pulldown_mesh_surface_coords">[docs]</a><span class="k">def</span> <span class="nf">uv_surface_pulldown_mesh_surface_coords</span><span class="p">(</span> <span class="n">unwrap_params</span><span class="p">,</span> <span class="n">mesh_ref</span><span class="p">,</span> <span class="n">Varray</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="s1">&#39;cross&#39;</span><span class="p">,</span> <span class="n">return_interp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Main function to unwrap a list of 3D triangle meshes given by their vertices onto a 2D image grid based on matching the uv-unwrap of a joint 3D triangle mesh typically this is the uv-rectangle and the unit sphere.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_params : (M,N,3)</span>
<span class="sd">        (u,v) parameterization of the 3D triangle mesh given by `mesh_ref`</span>
<span class="sd">    mesh_ref : trimesh.Trimesh</span>
<span class="sd">        the 3D triangle mesh equivalent of the geometry specified ``unwrap_params`` e.g. the unit sphere when ``unwrap_params`` is the UV-map </span>
<span class="sd">    Varray : list of (n_vertices,3)</span>
<span class="sd">        a list of 3D meshes given only by their vertices whom are bijective to ``mesh_ref`` such that they share the same number of vertices and the same face connectivity</span>
<span class="sd">    match_method : str</span>
<span class="sd">        one of &#39;cross&#39; implementing https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf or &#39;cramer&#39; implementing http://blackpawn.com/texts/pointinpoly for computing the barycentric coordinate after matching each image pixel to the rect_mesh</span>
<span class="sd">    return_interp : bool</span>
<span class="sd">        if True, also return the matching parameters between ``unwrap_params`` and ``mesh_ref`` for reuse </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pulldown_Varray_coords : (len(Varray),M,N,3) array</span>
<span class="sd">        The UV-unwrapping of all 3D surface meshes bijective to ``mesh_ref``</span>
<span class="sd">    (mesh_tri_id, mesh_ref_closest_pt_barycentric) : ( (M*N,), (M*N,3) ) tuple of arrays</span>
<span class="sd">        These are the matching parameters that establish correspondence between ``unwrap_params`` and ``mesh_ref`` in order to map all other 3D meshes given by ``Varray`` bijective to ``mesh_ref`` into the 2D grid specified by ``unwrap_params``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">unwrap_params_shape</span> <span class="o">=</span> <span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">mesh_ref</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">mesh_tri_id</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span> <span class="o">=</span> <span class="n">match_and_interpolate_uv_surface_to_mesh</span><span class="p">(</span><span class="n">unwrap_params</span><span class="p">,</span> <span class="n">mesh_ref</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="n">match_method</span><span class="p">)</span>

    <span class="c1"># interpolate ...</span>
    <span class="n">pulldown_Varray_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Varray</span><span class="p">)):</span>
        <span class="n">Varray_tri_id_vertices_iii</span> <span class="o">=</span> <span class="n">Varray</span><span class="p">[</span><span class="n">iii</span><span class="p">][</span><span class="n">F</span><span class="p">[</span><span class="n">mesh_tri_id</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># interpolate using the barycentric coordinates. to build the depth lookup array. </span>
        <span class="c1"># Varray_interp_coords = closest_pt_barycentric[:,0][:,None] * tri_id_vertices_orig[:,0] + closest_pt_barycentric[:,1][:,None] * tri_id_vertices_orig[:,1] + closest_pt_barycentric[:,2][:,None] * tri_id_vertices_orig[:,2]</span>
        <span class="n">Varray_interp_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh_ref_closest_pt_barycentric</span><span class="p">[:,</span><span class="n">ch</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Varray_tri_id_vertices_iii</span><span class="p">[:,</span><span class="n">ch</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Varray_interp_coords</span> <span class="o">=</span> <span class="n">Varray_interp_coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unwrap_params_shape</span><span class="p">)</span>
        <span class="n">pulldown_Varray_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Varray_interp_coords</span><span class="p">)</span>

    <span class="n">pulldown_Varray_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pulldown_Varray_coords</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_interp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pulldown_Varray_coords</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh_tri_id</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pulldown_Varray_coords</span></div>


<div class="viewcode-block" id="xyz_surface_pulldown_mesh_surface_coords"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.xyz_surface_pulldown_mesh_surface_coords">[docs]</a><span class="k">def</span> <span class="nf">xyz_surface_pulldown_mesh_surface_coords</span><span class="p">(</span> <span class="n">unwrap_params</span><span class="p">,</span> <span class="n">mesh_ref</span><span class="p">,</span> <span class="n">Varray</span><span class="p">,</span> <span class="n">mesh_tri_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="s1">&#39;cross&#39;</span><span class="p">,</span> <span class="n">return_interp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Main function to unwrap a list of 3D triangle meshes given by their vertices bijective to a common 3D mesh onto another 3D surface through proximity-based matching </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unwrap_params : (N,3)</span>
<span class="sd">        3D triangle mesh to transfer coordinates to </span>
<span class="sd">    mesh_ref : trimesh.Trimesh</span>
<span class="sd">        the 3D triangle mesh equivalent or similar to the geometry of ``unwrap_params`` bijective to geometrices given by `Varray`</span>
<span class="sd">    Varray : list of (n_vertices,3)</span>
<span class="sd">        a list of 3D meshes given only by their vertices whom are bijective to ``mesh_ref`` such that they share the same number of vertices and the same face connectivity</span>
<span class="sd">    match_method : str</span>
<span class="sd">        one of &#39;cross&#39; implementing https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf or &#39;cramer&#39; implementing http://blackpawn.com/texts/pointinpoly for computing the barycentric coordinate after matching each image pixel to the rect_mesh</span>
<span class="sd">    return_interp : bool</span>
<span class="sd">        if True, also return the matching parameters between ``unwrap_params`` and ``mesh_ref`` for reuse </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pulldown_Varray_coords : (len(Varray),N,3) array</span>
<span class="sd">        The remapped coordinates of 3D surface meshes bijective to ``mesh_ref`` as vertex measurements on ``unwrap_params``</span>
<span class="sd">    (mesh_tri_id, mesh_ref_closest_pt_barycentric) : ( (M*N,), (M*N,3) ) tuple of arrays</span>
<span class="sd">        Returned if return_interp=True. These are the matching parameters that establish correspondence between ``unwrap_params`` and ``mesh_ref`` in order to map all other 3D meshes given by ``Varray`` bijective to ``mesh_ref`` into the 2D grid specified by ``unwrap_params``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># unwrap_params_shape = unwrap_params.shape</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">mesh_ref</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mesh_tri_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mesh_ref_closest_pt_barycentric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_tri_id</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span> <span class="o">=</span> <span class="n">match_and_interpolate_uv_surface_to_mesh</span><span class="p">(</span><span class="n">unwrap_params</span><span class="p">,</span> <span class="n">mesh_ref</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="n">match_method</span><span class="p">)</span>

    <span class="c1"># interpolate ...</span>
    <span class="n">pulldown_Varray_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Varray</span><span class="p">)):</span>
        <span class="n">Varray_tri_id_vertices_iii</span> <span class="o">=</span> <span class="n">Varray</span><span class="p">[</span><span class="n">iii</span><span class="p">][</span><span class="n">F</span><span class="p">[</span><span class="n">mesh_tri_id</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># interpolate using the barycentric coordinates. to build the depth lookup array. </span>
        <span class="c1"># Varray_interp_coords = closest_pt_barycentric[:,0][:,None] * tri_id_vertices_orig[:,0] + closest_pt_barycentric[:,1][:,None] * tri_id_vertices_orig[:,1] + closest_pt_barycentric[:,2][:,None] * tri_id_vertices_orig[:,2]</span>
        <span class="n">Varray_interp_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mesh_ref_closest_pt_barycentric</span><span class="p">[:,</span><span class="n">ch</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Varray_tri_id_vertices_iii</span><span class="p">[:,</span><span class="n">ch</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">unwrap_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Varray_interp_coords = Varray_interp_coords.reshape(unwrap_params_shape)</span>
        <span class="n">pulldown_Varray_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Varray_interp_coords</span><span class="p">)</span>
    <span class="n">pulldown_Varray_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pulldown_Varray_coords</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_interp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pulldown_Varray_coords</span><span class="p">,</span> <span class="p">(</span><span class="n">mesh_tri_id</span><span class="p">,</span> <span class="n">mesh_ref_closest_pt_barycentric</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pulldown_Varray_coords</span></div>



<div class="viewcode-block" id="grid2D_surface_pulldown_mesh_surface_coords"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.grid2D_surface_pulldown_mesh_surface_coords">[docs]</a><span class="k">def</span> <span class="nf">grid2D_surface_pulldown_mesh_surface_coords</span><span class="p">(</span> <span class="n">rect_mesh</span><span class="p">,</span> <span class="n">Varray</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale_mesh_pts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">match_method</span><span class="o">=</span><span class="s1">&#39;cross&#39;</span><span class="p">,</span> <span class="n">return_interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Main function to map a 2D rectangular mesh and list of 3D triangle meshes given by their vertices bijective to the 3D surface it describes to an image of a given grid_shape through proximity-based matching </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rect_mesh : trimesh.Trimesh</span>
<span class="sd">        A 2D triangle mesh specified as a 3D triangle mesh where the last 2 coordinate axes are taken to be the x-,y- coordinates of the output image. </span>
<span class="sd">    Varray : list of (n_vertices,3)</span>
<span class="sd">        a list of 3D meshes given only by their vertices whom are bijective to ``rect_mesh`` such that they share the same number of vertices and the same face connectivity. We assume the order of the vertices in ``rect_mesh`` and the meshes in ``Varray`` are aligned.</span>
<span class="sd">    grid : (M,N) or (M,N,d) single- or multi- channel image </span>
<span class="sd">        input image to get the (M,N) shape</span>
<span class="sd">    grid_shape : (M,N) tuple</span>
<span class="sd">        the shape of the grid, only used if grid is not specified. Only one of grid or grid_shape needs to be passed </span>
<span class="sd">    rescale_mesh_pts : bool</span>
<span class="sd">        if True, the rect_mesh vertices are first rescaled in order to maximally cover the size of the intended image</span>
<span class="sd">    match_method : str</span>
<span class="sd">        one of &#39;cross&#39; implementing https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf or &#39;cramer&#39; implementing http://blackpawn.com/texts/pointinpoly for computing the barycentric coordinate after matching each image pixel to the rect_mesh</span>
<span class="sd">    return_interp : bool</span>
<span class="sd">        if True, also return the matching parameters between the final image coordinates and ``rect_mesh`` for reuse </span>
<span class="sd">    interp_method : str</span>
<span class="sd">        One of &#39;linear&#39; for ``matplotlib.tri.LinearTriInterpolator`` interpolation, </span>
<span class="sd">        &#39;cubic_geom&#39; for ``matplotlib.tri.CubicTriInterpolator`` with kind=&#39;geom&#39; and &#39;cubic_min_E&#39; for mtri.CubicTriInterpolator with kind=&#39;min_E&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pulldown_Varray_coords : (len(Varray),N,3) array</span>
<span class="sd">        The remapped coordinates of 3D surface meshes bijective to ``mesh_ref`` as vertex measurements on ``unwrap_params``</span>
<span class="sd">    triang : matplotlib.tri.Triangulation instance</span>
<span class="sd">        Optional return if ``return_interp=True``. The Matlplotlib triangulation of the rescaled ``rect_mesh`` used for interpolation with ``matplotlib.tri.LinearTriInterpolator`` internally</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># since 2D we can directly exploit matplotlib. </span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">mtri</span> 

    <span class="k">if</span> <span class="n">rescale_mesh_pts</span><span class="p">:</span>
        <span class="n">rect_mesh_rescale</span><span class="p">,</span> <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">rescale_mesh_points_to_grid_size</span><span class="p">(</span><span class="n">rect_mesh</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_shape</span><span class="o">=</span><span class="n">grid_shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rect_mesh_rescale</span> <span class="o">=</span> <span class="n">rect_mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">grid_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># print(rect_mesh_rescale.shape)</span>
    <span class="n">triang</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">Triangulation</span><span class="p">(</span><span class="n">rect_mesh_rescale</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> 
                                <span class="n">rect_mesh_rescale</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> 
                                <span class="n">triangles</span><span class="o">=</span><span class="n">rect_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    
    <span class="c1"># specify the grid points </span>
    <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span> 

    <span class="c1"># interpolate ...</span>
    <span class="n">pulldown_Varray_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Varray</span><span class="p">)):</span>
        <span class="n">Varray_iii</span> <span class="o">=</span> <span class="n">Varray</span><span class="p">[</span><span class="n">iii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">interp_method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span> 
            <span class="c1"># define the interpolation object for the Varray. </span>
            <span class="n">interp_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mtri</span><span class="o">.</span><span class="n">LinearTriInterpolator</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">Varray_iii</span><span class="p">[:,</span><span class="n">ch</span><span class="p">])</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Varray_iii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="n">interp_method</span> <span class="o">==</span> <span class="s1">&#39;cubic_geom&#39;</span><span class="p">:</span>
            <span class="n">interp_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mtri</span><span class="o">.</span><span class="n">CubicTriInterpolator</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">Varray_iii</span><span class="p">[:,</span><span class="n">ch</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;geom&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Varray_iii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="n">interp_method</span> <span class="o">==</span> <span class="s1">&#39;cubic_min_E&#39;</span><span class="p">:</span>
            <span class="n">interp_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mtri</span><span class="o">.</span><span class="n">CubicTriInterpolator</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">Varray_iii</span><span class="p">[:,</span><span class="n">ch</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;min_E&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Varray_iii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">interp_objs_scalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">interp_objs</span><span class="p">[</span><span class="n">ch</span><span class="p">](</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Varray_iii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>

        <span class="n">pulldown_Varray_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp_objs_scalars</span><span class="p">)</span>

    <span class="n">pulldown_Varray_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pulldown_Varray_coords</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_interp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pulldown_Varray_coords</span><span class="p">,</span> <span class="n">triang</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pulldown_Varray_coords</span></div>

<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># include rectangular conformal map functions </span>
<span class="c1"># &quot;&quot;&quot;</span>
<div class="viewcode-block" id="angle_distortion"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.angle_distortion">[docs]</a><span class="k">def</span> <span class="nf">angle_distortion</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span> 
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the angle difference of triangles between two meshes of the same face connectivity </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of triangle mesh 1</span>
<span class="sd">    f : (n_faces, 3) array</span>
<span class="sd">        triangulations of both meshes given in terms of the vertex indices</span>
<span class="sd">    param : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of triangle mesh 2  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distortion : (n_faces, 3) array</span>
<span class="sd">        array of angle differences in degrees at each triangle face </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">nv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">nv2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nv</span><span class="o">!=</span><span class="n">nv2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: The two meshes are of different size.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># if input is not 3d coords... then make it 3D. </span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># if 1d not 3d. </span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="mi">1</span><span class="p">))]);</span>
        

        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">param</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="mi">1</span><span class="p">))])</span>

        <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>

        <span class="c1"># % calculate angles on v</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">vcos1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">a1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">a1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">b1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">vcos2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">a2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">a2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">b2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">vcos3</span> <span class="o">=</span> <span class="p">(</span><span class="n">a3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">a3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">a3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">b3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            
        <span class="c1"># % calculate angles on param</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">d3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">param</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">paramcos1</span> <span class="o">=</span> <span class="p">(</span><span class="n">c1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">d1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">d1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">d1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">paramcos2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">d2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">d2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">d2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">paramcos3</span> <span class="o">=</span> <span class="p">(</span><span class="n">c3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">d3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">d3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">d3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>


        <span class="c1"># % calculate the angle difference</span>
        <span class="c1"># distortion = (np.arccos(np.hstack([paramcos1, paramcos2, paramcos3])) - np.arccos(np.hstack([vcos1,vcos2,vcos3])))*180/np.pi;</span>
        <span class="n">distortion</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">paramcos1</span><span class="p">,</span> <span class="n">paramcos2</span><span class="p">,</span> <span class="n">paramcos3</span><span class="p">]))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vcos1</span><span class="p">,</span><span class="n">vcos2</span><span class="p">,</span><span class="n">vcos3</span><span class="p">])))</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span>
        <span class="n">distortion</span> <span class="o">=</span> <span class="n">distortion</span><span class="o">.</span><span class="n">T</span> 

        <span class="k">return</span> <span class="n">distortion</span> <span class="c1"># in terms of angles. ( the angles is the same number as triangles. )</span></div>
<span class="c1"># % histogram</span>
<span class="c1"># figure;</span>
<span class="c1"># hist(distortion,-180:1:180);</span>
<span class="c1"># xlim([-180 180])</span>
<span class="c1"># title(&#39;Angle Distortion&#39;);</span>
<span class="c1"># xlabel(&#39;Angle difference (degree)&#39;)</span>
<span class="c1"># ylabel(&#39;Number of angles&#39;)</span>
<span class="c1"># set(gca,&#39;FontSize&#39;,12);</span>


<span class="k">def</span> <span class="nf">_cotangent_laplacian</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">):</span>
    <span class="c1"># % Compute the cotagent Laplacian of a mesh used in the rectangular conformal unwrapping </span>
    <span class="c1"># </span>
    <span class="c1"># See: </span>
    <span class="c1"># % [1] T. W. Meng, G. P.-T. Choi and L. M. Lui, </span>
    <span class="c1"># %     &quot;TEMPO: Feature-Endowed Teichmller Extremal Mappings of Point Clouds.&quot;</span>
    <span class="c1"># %     SIAM Journal on Imaging Sciences, 9(4), pp. 1922-1962, 2016.</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
    
    <span class="n">nv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    
    <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span> 
    <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span> 
    <span class="n">f3</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">];</span>
    
    <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">f3</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">l3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">l1</span> <span class="o">+</span> <span class="n">l2</span> <span class="o">+</span> <span class="n">l3</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l3</span><span class="p">));</span>
     
    <span class="n">cot12</span> <span class="o">=</span> <span class="p">(</span><span class="n">l1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">l3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">area</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">;</span>
    <span class="n">cot23</span> <span class="o">=</span> <span class="p">(</span><span class="n">l2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">l1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">area</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">;</span> 
    <span class="n">cot31</span> <span class="o">=</span> <span class="p">(</span><span class="n">l1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">l2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">area</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">;</span> 
    <span class="n">diag1</span> <span class="o">=</span> <span class="o">-</span><span class="n">cot12</span><span class="o">-</span><span class="n">cot31</span><span class="p">;</span> 
    <span class="n">diag2</span> <span class="o">=</span> <span class="o">-</span><span class="n">cot12</span><span class="o">-</span><span class="n">cot23</span><span class="p">;</span> 
    <span class="n">diag3</span> <span class="o">=</span> <span class="o">-</span><span class="n">cot31</span><span class="o">-</span><span class="n">cot23</span><span class="p">;</span>
    
    <span class="c1"># II = [f1; f2; f2; f3; f3; f1; f1; f2; f3];</span>
    <span class="c1"># JJ = [f2; f1; f3; f2; f1; f3; f1; f2; f3];</span>
    <span class="c1"># V = [cot12; cot12; cot23; cot23; cot31; cot31; diag1; diag2; diag3];</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f3</span><span class="p">,</span><span class="n">f3</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f3</span><span class="p">])</span>
    <span class="n">JJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">f2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f3</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f3</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f3</span><span class="p">])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cot12</span><span class="p">,</span> <span class="n">cot12</span><span class="p">,</span> <span class="n">cot23</span><span class="p">,</span> <span class="n">cot23</span><span class="p">,</span> <span class="n">cot31</span><span class="p">,</span> <span class="n">cot31</span><span class="p">,</span> <span class="n">diag1</span><span class="p">,</span> <span class="n">diag2</span><span class="p">,</span> <span class="n">diag3</span><span class="p">])</span>
    
    <span class="n">L</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">V</span><span class="p">,</span> <span class="p">(</span><span class="n">II</span><span class="p">,</span><span class="n">JJ</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span><span class="n">nv</span><span class="p">));</span>
    
    <span class="k">return</span> <span class="n">L</span> 


<div class="viewcode-block" id="beltrami_coefficient"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.beltrami_coefficient">[docs]</a><span class="k">def</span> <span class="nf">beltrami_coefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Beltrami coefficient of a mapping between two triangle meshes. The lower the Beltrami coefficient the lower the metric distortion between the meshes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of triangle mesh 1</span>
<span class="sd">    f : (n_faces, 3) array</span>
<span class="sd">        triangulations of both meshes given in terms of the vertex indices</span>
<span class="sd">    map_ : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of triangle mesh 2  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mu : (n_faces, ) complex array</span>
<span class="sd">        array of the beltrami coefficient for each triangle face  </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] T. W. Meng, G. P.-T. Choi and L. M. Lui, &quot;TEMPO: Feature-Endowed Teichmller Extremal Mappings of Point Clouds.&quot; SIAM Journal on Imaging Sciences, 9(4), pp. 1922-1962, 2016.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>

    <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>    
    <span class="n">Mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf</span><span class="p">),</span> 
                               <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf</span><span class="p">),</span> 
                               <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf</span><span class="p">)]),</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">nf</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    <span class="n">Mj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">nf</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    
    <span class="n">e1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],:</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],:</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">e3</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],:</span><span class="mi">2</span><span class="p">];</span>
    
    <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">e2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">e1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">e2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">;</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">area</span><span class="p">,</span><span class="n">area</span><span class="p">,</span><span class="n">area</span><span class="p">])</span>

    <span class="c1"># should this be F or C?</span>
    <span class="c1"># Mx = np.reshape(np.vstack([e1[:,1],e2[:,1],e3[:,1]])/area /2. , ((1, 3*nf)), order=&#39;C&#39;);</span>
    <span class="c1"># My = -np.reshape(np.vstack([e1[:,0],e2[:,0],e3[:,0]])/area /2. , ((1, 3*nf)), order=&#39;C&#39;);</span>
    <span class="n">Mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">e1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">e2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">e3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">/</span><span class="n">area</span> <span class="o">/</span><span class="mf">2.</span> <span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nf</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">);</span>
    <span class="n">My</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">e1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">e2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">e3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]])</span><span class="o">/</span><span class="n">area</span> <span class="o">/</span><span class="mf">2.</span> <span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nf</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">);</span>
    
    <span class="n">Mi</span> <span class="o">=</span> <span class="n">Mi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">Mj</span> <span class="o">=</span> <span class="n">Mj</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">Mx</span> <span class="o">=</span> <span class="n">Mx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">My</span> <span class="o">=</span> <span class="n">My</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="c1"># Dx = sparse(Mi,Mj,Mx);</span>
    <span class="c1"># Dy = sparse(Mi,Mj,My);</span>
     <span class="c1"># S = sparse(i,j,s) where m = max(i) and n = max(j).</span>
    <span class="n">Dx</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">Mx</span><span class="p">,</span> <span class="p">(</span><span class="n">Mi</span><span class="p">,</span><span class="n">Mj</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Mj</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">Dy</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">My</span><span class="p">,</span> <span class="p">(</span><span class="n">Mi</span><span class="p">,</span><span class="n">Mj</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Mj</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="n">dXdu</span> <span class="o">=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">map_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">dXdv</span> <span class="o">=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">map_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">dYdu</span> <span class="o">=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">map_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">dYdv</span> <span class="o">=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">map_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">dZdu</span> <span class="o">=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">map_</span><span class="p">[:,</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">dZdv</span> <span class="o">=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">map_</span><span class="p">[:,</span><span class="mi">2</span><span class="p">];</span>
    
    <span class="n">E</span> <span class="o">=</span> <span class="n">dXdu</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dYdu</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dZdu</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">dXdv</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dYdv</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dZdv</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">dXdu</span><span class="o">*</span><span class="n">dXdv</span> <span class="o">+</span> <span class="n">dYdu</span><span class="o">*</span><span class="n">dYdv</span> <span class="o">+</span> <span class="n">dZdu</span><span class="o">*</span><span class="n">dZdv</span><span class="p">;</span>
    
    <span class="c1"># this line? </span>
    <span class="n">mu</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span> <span class="o">-</span> <span class="n">G</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">E</span> <span class="o">+</span> <span class="n">G</span> <span class="o">+</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">G</span> <span class="o">-</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mf">1e-12</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">mu</span></div>


<div class="viewcode-block" id="linear_beltrami_solver"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.linear_beltrami_solver">[docs]</a><span class="k">def</span> <span class="nf">linear_beltrami_solver</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">landmark</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Linear Beltrami solver to find the minimal quasiconformal distortion mapping for unwrapping an open 3D mesh to a 2D rectangular map  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of triangle mesh 1</span>
<span class="sd">    f : (n_faces, 3) array</span>
<span class="sd">        triangulations of both meshes given in terms of the vertex indices</span>
<span class="sd">    mu : (n_faces,) complex array</span>
<span class="sd">        the beltrami coefficient at each triangular face </span>
<span class="sd">    landmark : (n,) array</span>
<span class="sd">        the vertex indices in the triangle mesh to enforce mapping to ``target`` </span>
<span class="sd">    target : (n,) complex array</span>
<span class="sd">        the coordinates of ``landmark`` vertices in the 2D unwrapping </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    param : (n_vertices, 2) array</span>
<span class="sd">        the 2D coordinates of the now 2D parametrized vertex coordinates of the input mesh </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] P. T. Choi, K. C. Lam, and L. M. Lui, &quot;FLASH: Fast Landmark Aligned Spherical Harmonic Parameterization for Genus-0 Closed Brain Surfaces.&quot; SIAM Journal on Imaging Sciences, vol. 8, no. 1, pp. 67-94, 2015.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="n">af</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">gf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">f0</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>

    <span class="n">uxv0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">uyv0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">uxv1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">uyv1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> 
    <span class="n">uxv2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">uyv2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uxv0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uyv0</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uxv1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uyv1</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uxv2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uyv2</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
    <span class="c1"># l = np.vstack([np.sqrt(np.sum(uxv0**2 + uyv0**2, axis=-1)), np.sqrt(np.sum(uxv1**2 + uyv1**2,axis=-1)), np.sqrt(np.sum(uxv2**2 + uyv2**2,axis=-1))]).T; # this is just the lengths. </span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">;</span> <span class="c1"># heron&#39;s formula. </span>

    <span class="n">v00</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uxv0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">bf</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uyv0</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv0</span><span class="o">*</span><span class="n">uyv0</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v11</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uxv1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">bf</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uyv1</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv1</span><span class="o">*</span><span class="n">uyv1</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v22</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uxv2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">bf</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uyv2</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv2</span><span class="o">*</span><span class="n">uyv2</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v01</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uxv0</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uyv0</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uyv1</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv1</span><span class="o">*</span><span class="n">uyv0</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v12</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uxv1</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uyv1</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uyv2</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv2</span><span class="o">*</span><span class="n">uyv1</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v20</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uxv2</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uyv2</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uyv0</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv0</span><span class="o">*</span><span class="n">uyv2</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f0</span><span class="p">]);</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f0</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f0</span><span class="p">,</span><span class="n">f2</span><span class="p">]);</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v00</span><span class="p">,</span><span class="n">v11</span><span class="p">,</span><span class="n">v22</span><span class="p">,</span><span class="n">v01</span><span class="p">,</span><span class="n">v01</span><span class="p">,</span><span class="n">v12</span><span class="p">,</span><span class="n">v12</span><span class="p">,</span><span class="n">v20</span><span class="p">,</span><span class="n">v20</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">;</span>
    <span class="c1"># # A = sparse(I,J,-V);</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="o">-</span><span class="n">V</span><span class="p">,</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cfloat</span><span class="p">);</span> <span class="n">A</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cfloat</span><span class="p">)</span>
   
    <span class="n">targetc</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">target</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">[:,</span><span class="n">landmark</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">targetc</span><span class="p">);</span>
    
    <span class="n">b</span><span class="p">[</span><span class="n">landmark</span><span class="p">]</span> <span class="o">=</span> <span class="n">targetc</span><span class="p">;</span>
    <span class="n">A</span><span class="p">[</span><span class="n">landmark</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">A</span><span class="p">[:,</span><span class="n">landmark</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">landmark</span><span class="p">)),</span> <span class="p">(</span><span class="n">landmark</span><span class="p">,</span><span class="n">landmark</span><span class="p">)),</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span> <span class="c1"># size(A,1), size(A,2));</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">param</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># map = A\b;</span>
    <span class="c1"># map = [real(map),imag(map)];</span>
    <span class="k">return</span> <span class="n">param</span> </div>


<div class="viewcode-block" id="direct_spherical_conformal_map"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.direct_spherical_conformal_map">[docs]</a><span class="k">def</span> <span class="nf">direct_spherical_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A linear method for computing spherical conformal map of a genus-0 closed surface using quasiconformal mapping</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of a genus-0 triangle mesh</span>
<span class="sd">    f : (n_faces, 3) array</span>
<span class="sd">        triangulations of a genus-0 triangle mesh</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    param : (n_vertices, 3) array </span>
<span class="sd">        vertex coordinates of the spherical conformal parameterization which maps the input mesh to the unit sphere. </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] P. T. Choi, K. C. Lam, and L. M. Lui, &quot;FLASH: Fast Landmark Aligned Spherical Harmonic Parameterization for Genus-0 Closed Brain Surfaces.&quot; SIAM Journal on Imaging Sciences, vol. 8, no. 1, pp. 67-94, 2015.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">spalg</span>

    <span class="c1"># # # %% Check whether the input mesh is genus-0</span>
    <span class="c1"># # if len(v)-3*len(f)/2+len(f) != 2:</span>
    <span class="c1"># #     print(&#39;The mesh is not a genus-0 closed surface.\n&#39;);</span>
    <span class="c1"># #     return []</span>
    <span class="c1"># # else:</span>
    <span class="c1"># print(&#39;spherical param&#39;)</span>

    <span class="c1"># %% Find the most regular triangle as the &quot;big triangle&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> 
    <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">e3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">regularity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e1</span><span class="o">/</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="o">+</span><span class="n">e3</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e2</span><span class="o">/</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="o">+</span><span class="n">e3</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e3</span><span class="o">/</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="o">+</span><span class="n">e3</span><span class="p">)</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># this being the most equilateral. </span>
    <span class="n">bigtri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">regularity</span><span class="p">)</span> 


    <span class="c1"># % In case the spherical parameterization result is not evenly distributed,</span>
    <span class="c1"># % try to change bigtri to the id of some other triangles with good quality</span>

    <span class="c1"># %% North pole step: Compute spherical map by solving laplace equation on a big triangle</span>
    <span class="n">nv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> 
    <span class="n">M</span> <span class="o">=</span> <span class="n">_cotangent_laplacian</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>

    <span class="c1"># this becomes the fixed triangle.</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="c1">#.copy();</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="c1">#.copy();</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="c1">#.copy();</span>

    <span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">]);</span>
    <span class="c1"># [mrow,mcol,mval] = find(M(fixed,:));</span>
    <span class="p">(</span><span class="n">mrow</span><span class="p">,</span> <span class="n">mcol</span><span class="p">,</span> <span class="n">mval</span><span class="p">)</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">fixed</span><span class="p">])</span>
    <span class="c1"># print(mrow,mcol,mval)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">mval</span><span class="p">,</span> <span class="p">(</span><span class="n">fixed</span><span class="p">[</span><span class="n">mrow</span><span class="p">],</span><span class="n">mcol</span><span class="p">)),(</span><span class="n">nv</span><span class="p">,</span><span class="n">nv</span><span class="p">))</span> <span class="o">+</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="n">fixed</span><span class="p">,</span><span class="n">fixed</span><span class="p">)),(</span><span class="n">nv</span><span class="p">,</span><span class="n">nv</span><span class="p">));</span>
    
    <span class="c1"># % set the boundary condition for big triangle</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">#% arbitrarily set the two points</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">p1</span><span class="p">];</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">p1</span><span class="p">];</span>
    <span class="n">sin1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">));</span>
    <span class="n">ori_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sin1</span><span class="p">;</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">,</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">],</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="n">ori_h</span><span class="o">*</span><span class="n">ratio</span><span class="p">;</span> <span class="c1">#% compute the coordinates of the third vertex</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">ratio</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">y3</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>

    <span class="c1"># print(x3,y3)</span>
    <span class="c1"># % Solve the Laplace equation to obtain a harmonic map</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nv</span><span class="p">);</span> <span class="n">c</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span> <span class="n">c</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span> <span class="n">c</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">=</span> <span class="n">x3</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nv</span><span class="p">);</span> <span class="n">d</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">=</span> <span class="n">y3</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">spalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">M</span> <span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">);</span> <span class="c1"># o this.</span>

    <span class="c1"># print(np.mean(z))</span>
    <span class="c1"># print(&#39;z&#39;, z.shape)</span>

    <span class="c1"># % inverse stereographic projection</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># %% Find optimal big triangle size</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">S</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">S</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">S</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># % find the index of the southernmost triangle</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span> <span class="c1"># this is absolutely KEY!</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="n">inner</span> <span class="o">==</span> <span class="n">bigtri</span><span class="p">:</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1"># select the next one. # this is meant to be the northernmost.... </span>

    <span class="c1"># print(&#39;bigtri&#39;, bigtri)</span>
    <span class="c1"># print(&#39;inner&#39;, index[:20])</span>

    <span class="c1"># % Compute the size of the northern most and the southern most triangles </span>
    <span class="n">NorthTriSide</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">bigtri</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span><span class="o">/</span><span class="mf">3.</span><span class="p">;</span> <span class="c1"># this is a number. </span>
    <span class="n">SouthTriSide</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">inner</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">inner</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">inner</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">inner</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">inner</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">inner</span><span class="p">,</span><span class="mi">0</span><span class="p">]]))</span><span class="o">/</span><span class="mf">3.</span><span class="p">;</span>

    <span class="c1"># % rescale to get the best distribution</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">NorthTriSide</span><span class="o">*</span><span class="n">SouthTriSide</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">NorthTriSide</span><span class="p">);</span> 

    <span class="c1"># % inverse stereographic projection</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">S</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="c1"># if harmonic map fails due to very bad triangulations, use tutte map</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;implement tutte map&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># %% South pole step</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">S</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>

    <span class="c1"># % number of points near the south pole to be fixed  </span>
    <span class="c1"># % simply set it to be 1/10 of the total number of vertices (can be changed)</span>
    <span class="c1"># % In case the spherical parameterization is not good, change 10 to</span>
    <span class="c1"># % something smaller (e.g. 2)</span>
    <span class="n">fixnum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">fixnum</span><span class="p">)]</span>

    <span class="c1"># % south pole stereographic projection</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">S</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">S</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span>  <span class="n">S</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">S</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># % compute the Beltrami coefficient</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> 
    <span class="c1"># problem is here. </span>
    <span class="c1"># % compose the map with another quasi-conformal map to cancel the distortion</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">linear_beltrami_solver</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">fixed</span><span class="p">,</span><span class="n">P</span><span class="p">[</span><span class="n">fixed</span><span class="p">]);</span> <span class="c1"># fixed is index. </span>

    <span class="c1"># print(&#39;num_nan: &#39;, np.sum(np.isnan(param)))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">param</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># this is failing at the moment</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;recomputing fixed elements&#39;</span><span class="p">)</span>
        <span class="c1"># % if the result has NaN entries, then most probably the number of</span>
        <span class="c1"># % boundary constraints is not large enough  </span>
        <span class="c1"># % increase the number of boundary constrains and run again</span>
        <span class="n">fixnum</span> <span class="o">=</span> <span class="n">fixnum</span><span class="o">*</span><span class="mi">5</span><span class="p">;</span> <span class="c1">#% again, this number can be changed</span>
        <span class="n">fixed</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="n">fixnum</span><span class="p">)];</span> 
        <span class="n">param</span> <span class="o">=</span> <span class="n">linear_beltrami_solver</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">fixed</span><span class="p">,</span><span class="n">P</span><span class="p">[</span><span class="n">fixed</span><span class="p">]);</span> 
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">param</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="c1">#% use the old result</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">param</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">param</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># z = complex(map(:,1),map(:,2));</span>

    <span class="c1"># % inverse south pole stereographic projection</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># map = [2*real(z)./(1+abs(z).^2), 2*imag(z)./(1+abs(z).^2), -(abs(z).^2-1)./(1+abs(z).^2)];</span>

    <span class="k">return</span> <span class="n">param</span> </div>


<span class="c1"># implementation of extension functions to improve conformal mapping. </span>
<span class="k">def</span> <span class="nf">_face_area</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the area of every face of a triangle mesh.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] P. T. Choi, K. C. Lam, and L. M. Lui, &quot;FLASH: Fast Landmark Aligned Spherical Harmonic Parameterization for Genus-0 Closed Brain Surfaces.&quot; SIAM Journal on Imaging Sciences, vol. 8, no. 1, pp. 67-94, 2015.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># % Compute the area of every face of a triangle mesh.</span>
    <span class="c1"># %</span>
    <span class="c1"># % If you use this code in your own work, please cite the following paper:</span>
    <span class="c1"># % [1] P. T. Choi, K. C. Lam, and L. M. Lui, </span>
    <span class="c1"># %     &quot;FLASH: Fast Landmark Aligned Spherical Harmonic Parameterization for Genus-0 Closed Brain Surfaces.&quot;</span>
    <span class="c1"># %     SIAM Journal on Imaging Sciences, vol. 8, no. 1, pp. 67-94, 2015.</span>
    <span class="c1"># %</span>
    <span class="c1"># % Copyright (c) 2013-2018, Gary Pui-Tung Choi</span>
    <span class="c1"># % https://scholar.harvard.edu/choi</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">v12</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">v23</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">v31</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">v12</span> <span class="o">*</span> <span class="n">v12</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">v23</span> <span class="o">*</span> <span class="n">v23</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span> <span class="n">v31</span> <span class="o">*</span> <span class="n">v31</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">c</span><span class="p">));</span> <span class="c1"># heron&#39;s formula</span>

    <span class="k">return</span> <span class="n">fa</span> 

<span class="c1"># def area_distortion(v,f,param):</span>

<span class="c1">#     # % Calculate and visualize the area distortion log(area_map/area_v)</span>
<span class="c1">#     # % </span>
<span class="c1">#     # % Input:</span>
<span class="c1">#     # % v: nv x 3 vertex coordinates of a genus-0 triangle mesh</span>
<span class="c1">#     # % f: nf x 3 triangulations of a genus-0 triangle mesh</span>
<span class="c1">#     # % param: nv x 2 or 3 vertex coordinates of the mapping result</span>
<span class="c1">#     # %</span>
<span class="c1">#     # % Output:</span>
<span class="c1">#     # % distortion: 3*nf x 1 area differences</span>
<span class="c1">#     # % </span>
<span class="c1">#     # % If you use this code in your own work, please cite the following paper:</span>
<span class="c1">#     # % [1] G. P. T. Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, </span>
<span class="c1">#     # %     &quot;Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.&quot;</span>
<span class="c1">#     # %     SIAM Journal on Imaging Sciences, 2020.</span>
<span class="c1">#     # %</span>
<span class="c1">#     # % Copyright (c) 2018-2020, Gary Pui-Tung Choi</span>
<span class="c1">#     # % https://scholar.harvard.edu/choi</span>

<span class="c1">#     import numpy as np</span>
<span class="c1">#     nv = len(v);</span>
<span class="c1">#     nv2 = len(param);</span>

<span class="c1">#     if nv != nv2:</span>
<span class="c1">#         print(&#39;Error: The two meshes are of different size.&#39;);</span>
<span class="c1">#         return []</span>

<span class="c1">#     if v.shape[-1] == 1:</span>
<span class="c1">#         v = np.vstack([np.real(v), np.imag(v), np.zeros(len(v))]).T</span>
<span class="c1">#     if v.shape[-1] == 2:</span>
<span class="c1">#         v = np.hstack([v, np.zeros((len(v),1))])</span>

<span class="c1">#     if param.shape[-1] == 1:</span>
<span class="c1">#         param = np.vstack([np.real(param), np.imag(param), np.zeros(len(param))]).T</span>
<span class="c1">#     if param.shape[-1] == 2:</span>
<span class="c1">#         param = np.hstack([np.real(param), np.zeros((len(param),1))])</span>

<span class="c1">#     # % calculate area of v</span>
<span class="c1">#     area_v = _face_area(v,f);</span>
<span class="c1">#     # % calculate area of map</span>
<span class="c1">#     area_map = _face_area(param,f);</span>
<span class="c1">#     # % normalize the total area # have to normalize this.... </span>
<span class="c1">#     v = v*np.sqrt(np.nansum(area_map)/np.nansum(area_v));</span>
<span class="c1">#     area_v = _face_area(v,f);</span>
<span class="c1">#     # % calculate the area ratio</span>
<span class="c1">#     # distortion = np.log(area_map/area_v);</span>
<span class="c1">#     distortion = np.log(area_map) - np.log(area_v) # might be more stable. </span>

<span class="c1">#     return distortion </span>
<span class="c1">#     # % histogram</span>
<span class="c1">#     # figure;</span>
<span class="c1">#     # histogram(distortion,30);</span>
<span class="c1">#     # xlim([-5 5])</span>
<span class="c1">#     # title(&#39;Area Distortion&#39;);</span>

<span class="c1">#     # xlabel(&#39;log(final area/initial area)&#39;)</span>
<span class="c1">#     # ylabel(&#39;Number of faces&#39;)</span>
<span class="c1">#     # set(gca,&#39;FontSize&#39;,12);</span>

<div class="viewcode-block" id="area_distortion_measure"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.area_distortion_measure">[docs]</a><span class="k">def</span> <span class="nf">area_distortion_measure</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the normalised area scaling factor as measure of area distortion between two triangle meshes</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \lambda = \frac{A_1}{A_2}</span>

<span class="sd">    where :math:`A_1, A_2` are the areas of the mesh after rescaling the meshes by the square root of the respective total surface areas, :math:`S_1,S_2` respectively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v1 : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of a triangle mesh 1</span>
<span class="sd">    v2 : (n_vertices, 3) array</span>
<span class="sd">        vertex coordinates of a triangle mesh 2</span>
<span class="sd">    f : (n_faces, 3) array</span>
<span class="sd">        the triangulation of both the first and second mesh, given in terms of the vertex indices </span>

<span class="sd">    Returns</span>
<span class="sd">    -------  </span>
<span class="sd">    ratio : (n_faces, 3) array</span>
<span class="sd">        the area distortion factor per face between meshes ``v1`` and ``v2``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    
    <span class="n">v1_</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
    <span class="n">v2_</span> <span class="o">=</span> <span class="n">v2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>

    <span class="n">ratio</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v1_</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v2_</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ratio</span> </div>
    <span class="c1"># # % calculate area of v</span>
    <span class="c1"># area_v = face_area(v,f);</span>
    <span class="c1"># # % calculate area of map</span>
    <span class="c1"># area_map = face_area(param,f);</span>
    <span class="c1"># # % normalize the total area # have to normalize this.... </span>
    <span class="c1"># v = v*np.sqrt(np.nansum(area_map)/np.nansum(area_v));</span>
    <span class="c1"># area_v = face_area(v,f);</span>
    <span class="c1"># # % calculate the area ratio</span>
    <span class="c1"># # distortion = np.log(area_map/area_v);</span>
    <span class="c1"># distortion = np.log(area_map) - np.log(area_v) # might be more stable. </span>
    <span class="c1"># return distortion </span>

<span class="k">def</span> <span class="nf">_finitemean</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; for avoiding the Inf values caused by division by a very small area</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="c1"># % for avoiding the Inf values caused by division by a very small area</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># return mean of columns. </span>
    <span class="k">return</span> <span class="n">m</span> 

<span class="k">def</span> <span class="nf">_stereographic</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="c1"># % STEREOGRAPHIC  Stereographic projection.</span>
    <span class="c1"># %   v = STEREOGRAPHIC(u), for N-by-2 matrix, projects points in plane to sphere</span>
    <span class="c1"># %                       ; for N-by-3 matrix, projects points on sphere to plane</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">u</span><span class="p">)])</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> 
        <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">z</span><span class="p">),</span> <span class="n">y</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">z</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">v</span>

<div class="viewcode-block" id="mobius_area_correction_spherical"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.mobius_area_correction_spherical">[docs]</a><span class="k">def</span> <span class="nf">mobius_area_correction_spherical</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">param</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find an optimal Mobius transformation for reducing the area distortion of a spherical conformal parameterization using the method in [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,3) array</span>
<span class="sd">        vertex coordinates of a genus-0 closed triangle mesh</span>
<span class="sd">    f : (n_faces,3) array</span>
<span class="sd">        triangulations of the genus-0 closed triangle mesh</span>
<span class="sd">    param : (n_vertices,3) array</span>
<span class="sd">        vertex coordinates of the spherical conformal parameterization of the mesh given by ``v`` and ``f`` </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    map_mobius : (n_vertices,3) array</span>
<span class="sd">        vertex coordinates of the updated spherical conformal parameterization </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. P. T. Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, &quot;Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.&quot; SIAM Journal on Imaging Sciences, 2020.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># % Find an optimal Mobius transformation for reducing the area distortion of a spherical conformal parameterization using the method in [1].</span>
    <span class="c1"># %</span>
    <span class="c1"># % Input:</span>
    <span class="c1"># % v: nv x 3 vertex coordinates of a genus-0 closed triangle mesh</span>
    <span class="c1"># % f: nf x 3 triangulations of a genus-0 closed triangle mesh</span>
    <span class="c1"># % map: nv x 3 vertex coordinates of the spherical conformal parameterization</span>
    <span class="c1"># % </span>
    <span class="c1"># % Output:</span>
    <span class="c1"># % map_mobius: nv x 3 vertex coordinates of the updated spherical conformal parameterization</span>
    <span class="c1"># % x: the optimal parameters for the Mobius transformation, where</span>
    <span class="c1"># %    f(z) = \frac{az+b}{cz+d}</span>
    <span class="c1"># %         = ((x(1)+x(2)*1i)*z+(x(3)+x(4)*1i))./((x(5)+x(6)*1i)*z+(x(7)+x(8)*1i))</span>
    <span class="c1"># %</span>
    <span class="c1"># % If you use this code in your own work, please cite the following paper:</span>
    <span class="c1"># % [1] G. P. T. Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, </span>
    <span class="c1"># %     &quot;Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.&quot;</span>
    <span class="c1"># %     SIAM Journal on Imaging Sciences, 2020.</span>
    <span class="c1"># %</span>
    <span class="c1"># % Copyright (c) 2019-2020, Gary Pui-Tung Choi</span>
    <span class="c1"># % https://scholar.harvard.edu/choi</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">spotimize</span>
    <span class="c1"># %%</span>
    <span class="c1"># % Compute the area with normalization</span>
    <span class="n">area_v</span> <span class="o">=</span> <span class="n">_face_area</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">);</span> <span class="n">area_v</span> <span class="o">=</span> <span class="n">area_v</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_v</span><span class="p">);</span>

    <span class="c1"># % Project the sphere onto the plane</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_stereographic</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># make into complex. </span>

    <span class="c1"># % Function for calculating the area after the Mobius transformation </span>
    <span class="k">def</span> <span class="nf">area_map</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>

        <span class="n">mobius</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span><span class="o">/</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span> <span class="c1"># this is the mobius transform</span>
        <span class="n">area_mobius</span> <span class="o">=</span> <span class="n">_face_area</span><span class="p">(</span><span class="n">_stereographic</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mobius</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mobius</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">area_mobius</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_mobius</span><span class="p">)</span> <span class="c1"># normalised area.</span>

    <span class="k">def</span> <span class="nf">d_area</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_finitemean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">area_map</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">area_v</span><span class="p">)))</span>

    <span class="c1"># % Optimization setup</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">#% initial guess</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mi">100</span><span class="p">;</span> <span class="c1">#% lower bound for the parameters</span>
    <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mi">100</span><span class="p">;</span> <span class="c1">#% upper bound for the parameters</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">lb</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">ub</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lb</span><span class="p">)))</span>
    
    <span class="c1"># options = optimoptions(&#39;fmincon&#39;,&#39;Display&#39;,&#39;iter&#39;);</span>
    <span class="c1"># % Optimization (may further supply gradients for better result, not yet implemented)</span>
    <span class="c1"># x = fmincon(d_area,x0,[],[],[],[],lb,ub,[],options);</span>
    <span class="n">opt_res</span> <span class="o">=</span> <span class="n">spotimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">d_area</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">opt_res</span><span class="o">.</span><span class="n">x</span>

    <span class="c1"># % obtain the conformal parameterization with area distortion corrected</span>
    <span class="n">fz</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span>
    <span class="n">map_mobius</span> <span class="o">=</span> <span class="n">_stereographic</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">fz</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">map_mobius</span></div>


<div class="viewcode-block" id="mobius_area_correction_disk"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.mobius_area_correction_disk">[docs]</a><span class="k">def</span> <span class="nf">mobius_area_correction_disk</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">param</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find an optimal Mobius transformation for reducing the area distortion of a disk conformal parameterization using the method in [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,3) array</span>
<span class="sd">        vertex coordinates of a simply-connected open triangle mesh</span>
<span class="sd">    f : (n_faces,3) array</span>
<span class="sd">        triangulations of a simply-connected open triangle mesh</span>
<span class="sd">    param : (n_vertices,2) array</span>
<span class="sd">        vertex coordinates of the disk conformal parameterization of the mesh given by ``v`` and ``f`` </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    map_mobius_disk : (n_vertices,2) array</span>
<span class="sd">        vertex coordinates of the updated disk conformal parameterization </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. P. T. Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, &quot;Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.&quot; SIAM Journal on Imaging Sciences, 2020.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># % Find an optimal Mobius transformation for reducing the area distortion of a disk conformal parameterization using the method in [1].</span>
    <span class="c1"># %</span>
    <span class="c1"># % Input:</span>
    <span class="c1"># % v: nv x 3 vertex coordinates of a simply-connected open triangle mesh</span>
    <span class="c1"># % f: nf x 3 triangulations of a simply-connected open triangle mesh</span>
    <span class="c1"># % map: nv x 2 vertex coordinates of the disk conformal parameterization</span>
    <span class="c1"># % </span>
    <span class="c1"># % Output:</span>
    <span class="c1"># % map_mobius_disk: nv x 2 vertex coordinates of the updated disk conformal parameterization</span>
    <span class="c1"># % x: the optimal parameters for the Mobius transformation, where</span>
    <span class="c1"># %    f(z) = \frac{z-a}{1-\bar{a} z}</span>
    <span class="c1"># %    x(1): |a| (0 ~ 1)        magnitude of a</span>
    <span class="c1"># %    x(2): arg(a) (0 ~ 2pi)   argument of a</span>
    <span class="c1"># %</span>
    <span class="c1"># % If you use this code in your own work, please cite the following paper:</span>
    <span class="c1"># % [1] G. P. T. Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, </span>
    <span class="c1"># %     &quot;Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.&quot;</span>
    <span class="c1"># %     SIAM Journal on Imaging Sciences, 2020.</span>
    <span class="c1"># %</span>
    <span class="c1"># % Copyright (c) 2019-2020, Gary Pui-Tung Choi</span>
    <span class="c1"># % https://scholar.harvard.edu/choi</span>
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">spotimize</span>
    <span class="c1"># % Compute the area with normalization</span>
    <span class="n">area_v</span> <span class="o">=</span> <span class="n">_face_area</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">);</span> <span class="n">area_v</span> <span class="o">=</span> <span class="n">area_v</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_v</span><span class="p">));</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">param</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">param</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># % Function for calculating the area after the Mobius transformation </span>
    <span class="k">def</span> <span class="nf">area_map</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">v_mobius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">((</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="n">z</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">((</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="n">z</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">area_mobius</span> <span class="o">=</span> <span class="n">_face_area</span><span class="p">(</span> <span class="n">v_mobius</span><span class="p">,</span> <span class="n">f</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">area_mobius</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area_mobius</span><span class="p">)</span> <span class="c1"># normalised area.</span>

    <span class="c1"># % objective function: mean(abs(log(area_map./area_v)))</span>
    <span class="k">def</span> <span class="nf">d_area</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_finitemean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">area_map</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">area_v</span><span class="p">)))</span>

    <span class="c1"># % Optimization setup</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">#% initial guess, try something diferent if the result is not good</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">#% lower bound for the parameters</span>
    <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]);</span> <span class="c1">#% upper bound for the parameters</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">lb</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">ub</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lb</span><span class="p">)))</span>

    <span class="n">opt_res</span> <span class="o">=</span> <span class="n">spotimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">d_area</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">opt_res</span><span class="o">.</span><span class="n">x</span>
    
    <span class="c1"># % obtain the conformal parameterization with area distortion corrected</span>
    <span class="n">fz</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="n">z</span><span class="p">);</span>
    <span class="n">map_mobius_disk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">fz</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">map_mobius_disk</span></div>


<span class="k">def</span> <span class="nf">_generalized_laplacian</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">mu</span><span class="p">):</span>
    <span class="c1"># function A = generalized_laplacian(v,f,mu)</span>
    <span class="c1"># % Compute the generalized Laplacian.</span>
    <span class="c1"># % </span>
    <span class="c1"># % If you use this code in your own work, please cite the following paper:</span>
    <span class="c1"># % [1] T. W. Meng, G. P.-T. Choi and L. M. Lui, </span>
    <span class="c1"># %     &quot;TEMPO: Feature-Endowed Teichmller Extremal Mappings of Point Clouds.&quot;</span>
    <span class="c1"># %     SIAM Journal on Imaging Sciences, 9(4), pp. 1922-1962, 2016.</span>
    <span class="c1"># %</span>
    <span class="c1"># % Copyright (c) 2015-2018, Gary Pui-Tung Choi</span>
    <span class="c1"># % https://scholar.harvard.edu/choi</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
    
    <span class="n">af</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">.</span><span class="n">real</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">bf</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="n">mu</span><span class="o">.</span><span class="n">imag</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">gf</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">mu</span><span class="o">.</span><span class="n">real</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">f0</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> 
    <span class="n">f1</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> 
    <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>

    <span class="n">uxv0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">uyv0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">uxv1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">uyv1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f2</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span> 
    <span class="n">uxv2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">uyv2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">f0</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uxv0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uyv0</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> 
                   <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uxv1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uyv1</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> 
                   <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uxv2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uyv2</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">l</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="c1">#+ 1e-12;</span>
    
    <span class="n">v00</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uxv0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">bf</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uyv0</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv0</span><span class="o">*</span><span class="n">uyv0</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v11</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uxv1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">bf</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uyv1</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv1</span><span class="o">*</span><span class="n">uyv1</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v22</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uxv2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">bf</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uyv2</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv2</span><span class="o">*</span><span class="n">uyv2</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v01</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uxv0</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uyv0</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uyv1</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv1</span><span class="o">*</span><span class="n">uyv0</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v12</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uxv1</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uyv1</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv1</span><span class="o">*</span><span class="n">uyv2</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv2</span><span class="o">*</span><span class="n">uyv1</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    <span class="n">v20</span> <span class="o">=</span> <span class="p">(</span><span class="n">af</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uxv2</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv0</span><span class="o">*</span><span class="n">uyv2</span> <span class="o">+</span> <span class="n">bf</span><span class="o">*</span><span class="n">uxv2</span><span class="o">*</span><span class="n">uyv0</span> <span class="o">+</span> <span class="n">gf</span><span class="o">*</span><span class="n">uyv0</span><span class="o">*</span><span class="n">uyv2</span><span class="p">)</span><span class="o">/</span><span class="n">area</span><span class="p">;</span>
    
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f0</span><span class="p">])</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f0</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f1</span><span class="p">,</span><span class="n">f0</span><span class="p">,</span><span class="n">f2</span><span class="p">])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v00</span><span class="p">,</span><span class="n">v11</span><span class="p">,</span><span class="n">v22</span><span class="p">,</span><span class="n">v01</span><span class="p">,</span><span class="n">v01</span><span class="p">,</span><span class="n">v12</span><span class="p">,</span><span class="n">v12</span><span class="p">,</span><span class="n">v20</span><span class="p">,</span><span class="n">v20</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="o">-</span><span class="n">V</span><span class="p">,</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
        
    <span class="k">return</span> <span class="n">A</span> 


<div class="viewcode-block" id="rectangular_conformal_map"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.rectangular_conformal_map">[docs]</a><span class="k">def</span> <span class="nf">rectangular_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">corner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">map2square</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_bdy_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the rectangular conformal mapping using the fast method in [1]_. This first maps the open mesh to a disk then from a disk to the rectangle. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices, 3) array </span>
<span class="sd">        vertex coordinates of a simply-connected open triangle mesh</span>
<span class="sd">    f : (n_faces, 3) array </span>
<span class="sd">        triangulations of a simply-connected open triangle mesh</span>
<span class="sd">    corner : (4,) array</span>
<span class="sd">        optional input for specifying the exact 4 vertex indices for the four corners of the final rectangle, with anti-clockwise orientation</span>
<span class="sd">    map2square : bool </span>
<span class="sd">        if True, do the rectangular conformal map, else if False, return the intermediate Harmonic disk parametrization which is much faster. </span>
<span class="sd">    random_state : int</span>
<span class="sd">        if corner is None, this is a random seed that randomly picks the 4 corners of the final rectangle from the input vertices. </span>
<span class="sd">    return_bdy_index : bool</span>
<span class="sd">        if True, returns additionally the indices of the vertex that form the boundary of the input triangle mesh </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    map_ : (n_vertices,2) array</span>
<span class="sd">        vertex coordinates of the rectangular conformal parameterization if map2square=True of the harmonic disk conformal parametrization if map2square=False. </span>
<span class="sd">    h_opt : scalar </span>
<span class="sd">        if map2square=True, return the optimal y-coordinate scaling factor to have the lowest Beltrami coefficient in the rectangular conformal map </span>
<span class="sd">    bdy_index : </span>
<span class="sd">        if return_bdy_index=True, return as the last output the vertex indices that form the boundary of the input triangle mesh </span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] T. W. Meng, G. P.-T. Choi and L. M. Lui, &quot;TEMPO: Feature-Endowed Teichmller Extremal Mappings of Point Clouds.&quot; SIAM Journal on Imaging Sciences, 9(4), pp. 1922-1962, 2016.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. Please make sure that the input mesh does not contain any unreferenced vertices/non-manifold vertices/non-manifold edges.</span>
<span class="sd">    2. Please remove all valence 1 boundary vertices (i.e. vertices with only 1 face attached to them) before running the program.</span>
<span class="sd">    3. Please make sure that the input triangulations f are with anti-clockwise orientation.</span>
<span class="sd">    4. The output rectangular domain will always have width = 1, while the height depends on the choice of the corners and may not be 1. (The Riemann mapping theorem guarantees that there exists a conformal map from any simple-connected open surface to the unit square, but if four vertices on the surface boundary are specified to be the four corners of the planar domain, the theorem is no longer applicable.)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># corner is given as an index of the original boundary. </span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fminbound</span>
    <span class="c1"># import time </span>
    
    <span class="n">nv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">bdy_index</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">corner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="c1"># just pick 4 regularly sampled indices on the boundary </span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">corner</span> <span class="o">=</span> <span class="n">bdy_index</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)[:</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span>
    
    <span class="c1"># % rearrange the boundary indices to be correct anticlockwise. </span>
    <span class="n">id1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">id1</span> <span class="o">=</span> <span class="n">id1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># re-index. </span>
    <span class="n">bdy_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="n">id1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[:</span><span class="n">id1</span><span class="p">]]);</span>
    <span class="c1"># relabel </span>
    <span class="n">id1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">id2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">id3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">id4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
    
    <span class="n">id2</span> <span class="o">=</span> <span class="n">id2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">id3</span> <span class="o">=</span> <span class="n">id3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">id4</span> <span class="o">=</span> <span class="n">id4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># print(id1,id2,id3,id4)</span>
    <span class="c1"># print(&#39;=====&#39;)</span>
    <span class="c1"># %% Step 1: Mapping the input mesh onto the unit disk</span>
    <span class="n">bdy_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                         <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                         <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1"># partial_edge_sum = np.zeros(len(bdy_length));</span>
    <span class="n">partial_edge_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">bdy_length</span><span class="p">)</span>
    
    <span class="c1"># # % arc-length parameterization boundary constraint</span>
    <span class="c1"># theta = 2*np.pi*partial_edge_sum/np.sum(bdy_length); # theta. </span>
    <span class="c1"># bdy = np.exp(theta*1j); # r</span>
    
    <span class="c1">## Map the boundary to a circle, preserving edge proportions</span>
    <span class="n">bnd_uv</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">map_vertices_to_circle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">bdy_index</span><span class="p">)</span>

    <span class="c1"># % 1. disk harmonic map</span>
    <span class="n">disk</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                              <span class="n">f</span><span class="p">,</span> 
                              <span class="n">bdy_index</span><span class="p">,</span> 
                              <span class="n">bnd_uv</span><span class="p">,</span> 
                              <span class="mi">1</span><span class="p">);</span> <span class="c1"># if 2 then biharmonic  </span>

    <span class="k">if</span> <span class="n">map2square</span><span class="p">:</span>
        <span class="c1"># then do conformal mapping to square</span>
        <span class="c1"># return disk, [id1,id2,id3,id4], bdy_index</span>
        <span class="c1"># if sum(sum(isnan(disk))) ~= 0</span>
        <span class="c1">#     % use tutte embedding instead</span>
        <span class="c1">#     disk = tutte_map(v,f,bdy_index,bdy); </span>
        <span class="c1"># end</span>
        
        <span class="c1"># the below is super slow -&gt; try to find a faster way. </span>

        <span class="c1"># %% Step 2: Mapping the unit disk to the unit square [ super slow ... construction...]</span>
        <span class="c1"># % compute the generalized Laplacian</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># mu = beltrami_coefficient(disk,f,v);</span>
        <span class="n">Ax</span> <span class="o">=</span> <span class="n">_generalized_laplacian</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">mu</span><span class="p">);</span> <span class="c1"># ok....-&gt; this does look like just the degree matrix? </span>
        <span class="n">Ay</span> <span class="o">=</span> <span class="n">Ax</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
        
        <span class="c1"># % set the boundary constraints</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">bdy_index</span><span class="p">[</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">bdy_index</span><span class="p">[</span><span class="n">id2</span><span class="p">:</span><span class="n">id3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">bdy_index</span><span class="p">[</span><span class="n">id3</span><span class="p">:</span><span class="n">id4</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="n">id4</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="c1"># print(bottom, right, top, left)</span>
        
        <span class="n">Ax</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">Ax</span><span class="p">);</span> <span class="c1"># convert to this first... </span>
        <span class="n">Ay</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">Ay</span><span class="p">);</span>
        
        <span class="n">bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nv</span><span class="p">);</span> <span class="n">by</span> <span class="o">=</span> <span class="n">bx</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
        <span class="n">Ax</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">]),:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">Ax</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">]))));</span>
        <span class="c1"># this diag sounds like just putting ones... </span>
        <span class="c1"># Ax[np.hstack([left,right]), np.hstack([left,right])] = 1</span>
        
        <span class="n">bx</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">Ay</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">top</span><span class="p">,</span><span class="n">bottom</span><span class="p">]),:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">Ay</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">top</span><span class="p">,</span><span class="n">bottom</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">top</span><span class="p">,</span><span class="n">bottom</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">top</span><span class="p">,</span><span class="n">bottom</span><span class="p">]))));</span>
        <span class="c1"># Ay[np.hstack([top,bottom]), np.hstack([top,bottom])] = 1</span>
        <span class="n">by</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="n">Ax</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">Ax</span><span class="p">);</span>
        <span class="n">Ay</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">Ay</span><span class="p">);</span>
        
        <span class="c1"># % solve the generalized Laplace equation</span>
        <span class="n">square_x</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Ax</span><span class="p">,</span> <span class="n">bx</span><span class="p">);</span>
        <span class="n">square_y</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Ay</span><span class="p">,</span> <span class="n">by</span><span class="p">);</span>
        <span class="c1"># square_x = sparse.linalg.cg(Ax, bx)[0]; # no solve? </span>
        <span class="c1"># square_y = sparse.linalg.cg(Ay, by)[0];</span>
        <span class="c1"># print(square_x.max())</span>
        <span class="c1"># print(square_y.max())</span>

        <span class="c1"># %% Step 3: Optimize the height of the square to achieve a conformal map</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
            <span class="c1"># here. </span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">square_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">h</span><span class="o">*</span><span class="n">square_y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]]),</span><span class="n">f</span><span class="p">,</span><span class="n">v</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">h_opt</span> <span class="o">=</span> <span class="n">fminbound</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
        
        <span class="n">map_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">square_x</span><span class="p">,</span> <span class="n">h_opt</span><span class="o">*</span><span class="n">square_y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
        <span class="c1"># map_ = np.vstack([square_x, square_y]).T;</span>
        
        <span class="k">if</span> <span class="n">return_bdy_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">map_</span><span class="p">,</span> <span class="n">h_opt</span><span class="p">,</span> <span class="n">bdy_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">map_</span><span class="p">,</span> <span class="n">h_opt</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">map_</span> <span class="o">=</span> <span class="n">disk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_bdy_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">map_</span><span class="p">,</span> <span class="n">bdy_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just return disk </span>
            <span class="k">return</span> <span class="n">map_</span>    </div>


<div class="viewcode-block" id="f2v"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.f2v">[docs]</a><span class="k">def</span> <span class="nf">f2v</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the face to vertex interpolation matrix taking into account unequal lengths. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,3) array</span>
<span class="sd">        vertex coordinates of a triangle mesh</span>
<span class="sd">    f : (n_faces, 3) array </span>
<span class="sd">        triangulations of a triangle mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : (n_vertices, n_faces) sparse array</span>
<span class="sd">        the face to vertex matrix such that S.dot(face_values), gives the interpolated vertex values equivalent </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the face to vertex interpolation matrix. of </span>
<span class="sd">    % [1] P. T. Choi and L. M. Lui, </span>
<span class="sd">    %     &quot;Fast Disk Conformal Parameterization of Simply-Connected Open Surfaces.&quot;</span>
<span class="sd">    %     Journal of Scientific Computing, 65(3), pp. 1065-1090, 2015.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                           <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> 
                           <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">S</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces_sparse</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#.dot(rgba.astype(np.float64))</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_degree</span>
    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">degree</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">degree</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">normalizer</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">degree</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">normalizer</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">normalizer</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">normalizer</span><span class="p">))</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S</span> </div>

<div class="viewcode-block" id="disk_conformal_map"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.disk_conformal_map">[docs]</a><span class="k">def</span> <span class="nf">disk_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">corner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">north</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">south</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the disk conformal mapping using the method in [1].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,3) array </span>
<span class="sd">        vertex coordinates of a simply-connected open triangle mesh</span>
<span class="sd">    f : (n_faces,3) array</span>
<span class="sd">        triangulations of a simply-connected open triangle mesh</span>
<span class="sd">    corner : (4,) array</span>
<span class="sd">        optional input for specifying the exact 4 vertex indices for rearranging the boundary index, with anti-clockwise orientation</span>
<span class="sd">    random_state : int</span>
<span class="sd">        if corner is None, this is a random seed that randomly picks the 4 corners for rearranging the boundary index. </span>
<span class="sd">    north : int</span>
<span class="sd">        scalar for fixing the north pole iterations</span>
<span class="sd">    south : </span>
<span class="sd">        scalar for fixing the south pole iterations</span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        convergence threshold between the old and new energy cost per iteration in the Beltrami coefficient optimization. </span>
<span class="sd">    max_iter : int</span>
<span class="sd">        the maximum number of Beltrami coefficient optimization </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    disk_new : (n_vertices,2) array</span>
<span class="sd">        vertex coordinates of the updated disk conformal parameterization starting from an initial harmonic disk parametrization </span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] P. T. Choi and L. M. Lui, &quot;Fast Disk Conformal Parameterization of Simply-Connected Open Surfaces.&quot; Journal of Scientific Computing, 65(3), pp. 1065-1090, 2015.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. Please make sure that the input mesh does not contain any unreferenced vertices/non-manifold vertices/non-manifold edges.</span>
<span class="sd">    2. Please remove all valence 1 boundary vertices (i.e. vertices with only 1 face attached to them) before running the program.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># % Compute the disk conformal mapping using the method in [1].</span>
    <span class="c1"># %</span>
    <span class="c1"># % Input:</span>
    <span class="c1"># % v: nv x 3 vertex coordinates of a simply-connected open triangle mesh</span>
    <span class="c1"># % f: nf x 3 triangulations of a simply-connected open triangle mesh</span>
    <span class="c1"># % </span>
    <span class="c1"># % Output:</span>
    <span class="c1"># % map: nv x 2 vertex coordinates of the disk conformal parameterization</span>
    <span class="c1"># % </span>
    <span class="c1"># % Remark:</span>
    <span class="c1"># % 1. Please make sure that the input mesh does not contain any </span>
    <span class="c1"># %    unreferenced vertices/non-manifold vertices/non-manifold edges.</span>
    <span class="c1"># % 2. Please remove all valence 1 boundary vertices (i.e. vertices with </span>
    <span class="c1"># %    only 1 face attached to them) before running the program.</span>
    <span class="c1"># % </span>
    <span class="c1"># % If you use this code in your own work, please cite the following paper:</span>
    <span class="c1"># % [1] P. T. Choi and L. M. Lui, </span>
    <span class="c1"># %     &quot;Fast Disk Conformal Parameterization of Simply-Connected Open Surfaces.&quot;</span>
    <span class="c1"># %     Journal of Scientific Computing, 65(3), pp. 1065-1090, 2015.</span>
    <span class="c1"># %</span>
    <span class="c1"># % Copyright (c) 2014-2018, Gary Pui-Tung Choi</span>
    <span class="c1"># % https://scholar.harvard.edu/choi</span>

    <span class="c1"># corner is given as an index of the original boundary. </span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fminbound</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 
    <span class="c1"># import time </span>
    

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stage 1: obtain a harmonic map initialization. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">bdy_index</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">corner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="c1"># just pick 4 regularly sampled indices on the boundary </span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">corner</span> <span class="o">=</span> <span class="n">bdy_index</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)[:</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span>
    
    <span class="c1"># % rearrange the boundary indices to be correct anticlockwise. </span>
    <span class="n">id1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">id1</span> <span class="o">=</span> <span class="n">id1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># re-index. </span>
    <span class="n">bdy_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="n">id1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[:</span><span class="n">id1</span><span class="p">]]);</span>
    <span class="c1"># relabel </span>
    <span class="n">id1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">id2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">id3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">id4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))[</span><span class="n">bdy_index</span><span class="o">==</span><span class="n">corner</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
    
    <span class="n">id2</span> <span class="o">=</span> <span class="n">id2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">id3</span> <span class="o">=</span> <span class="n">id3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">id4</span> <span class="o">=</span> <span class="n">id4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># print(id1,id2,id3,id4)</span>
    <span class="c1"># print(&#39;=====&#39;)</span>
    <span class="c1"># %% Step 1: Mapping the input mesh onto the unit disk</span>
    <span class="n">bdy_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                         <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                         <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1"># partial_edge_sum = np.zeros(len(bdy_length));</span>
    <span class="n">partial_edge_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">bdy_length</span><span class="p">)</span>
    
    <span class="c1"># # % arc-length parameterization boundary constraint</span>
    <span class="c1"># theta = 2*np.pi*partial_edge_sum/np.sum(bdy_length); # theta. </span>
    <span class="c1"># bdy = np.exp(theta*1j); # r</span>
    
    <span class="c1">## Map the boundary to a circle, preserving edge proportions</span>
    <span class="n">bnd_uv</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">map_vertices_to_circle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">bdy_index</span><span class="p">)</span>

    <span class="c1"># % 1. disk harmonic map</span>
    <span class="n">disk</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                              <span class="n">f</span><span class="p">,</span> 
                              <span class="n">bdy_index</span><span class="p">,</span> 
                              <span class="n">bnd_uv</span><span class="p">,</span> 
                              <span class="mi">1</span><span class="p">);</span> <span class="c1"># if 2 then biharmonic  </span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">disk</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">disk</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    <span class="c1">### the remainder is optimization. </span>
    <span class="c1"># %% North Pole iteration</span>
    <span class="c1"># % Use the Cayley transform to map the disk to the upper half plane</span>
    <span class="c1"># % All boundary points will be mapped to the real line</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> 
    <span class="n">mu_v</span> <span class="o">=</span> <span class="n">f2v</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span> <span class="c1"># map this from face to vertex. </span>
    <span class="n">bdy_index_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bdy_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bdy_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span> 
    <span class="n">least</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_v</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">])</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_v</span><span class="p">[</span><span class="n">bdy_index_temp</span><span class="p">]))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">[</span><span class="n">least</span><span class="p">]])</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">least</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))]])</span><span class="o">/</span><span class="mf">2.</span><span class="p">));</span> <span class="c1"># this is not giving the same as matlab? </span>
    <span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">z</span><span class="p">);</span> 

    <span class="c1">#fix the points near the puncture, i.e. near z = 1</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">ind</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">/</span><span class="n">north</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])])],</span> <span class="n">bdy_index</span><span class="p">);</span>
    <span class="c1"># fixed = [fixed; find(real(g) == max(real(g))); find(real(g) == min(real(g)))];</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">fixed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">g</span><span class="p">))])</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> 
                   <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> 
                   <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> 
    
    <span class="c1">#compute the updated x coordinates</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">fixed</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">_generalized_laplacian</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">mu</span><span class="p">);</span> <span class="c1"># is this more efficient by changing to a column structure. </span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Ax</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> <span class="n">Ay</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>

    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">Ax</span><span class="p">[:,</span><span class="n">fixed</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="n">b</span><span class="p">[</span><span class="n">fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
    <span class="n">Ax</span><span class="p">[</span><span class="n">fixed</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Ax</span><span class="p">[:,</span><span class="n">fixed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Ax</span> <span class="o">=</span> <span class="n">Ax</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="n">Ax</span> <span class="o">=</span> <span class="n">Ax</span> <span class="o">+</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fixed</span><span class="p">)),</span> <span class="p">(</span><span class="n">fixed</span><span class="p">,</span><span class="n">fixed</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Ax</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

    <span class="c1">#compute the updated y coordinates</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">fixed</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">fixed</span><span class="p">,</span> <span class="n">bdy_index</span><span class="p">])</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bdy_index</span><span class="p">))]);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">Ay</span><span class="p">[:,</span><span class="n">fixed</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="n">b</span><span class="p">[</span><span class="n">fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
    <span class="n">Ay</span><span class="p">[</span><span class="n">fixed</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Ay</span><span class="p">[:,</span><span class="n">fixed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Ay</span> <span class="o">=</span> <span class="n">Ay</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="n">Ay</span> <span class="o">=</span> <span class="n">Ay</span> <span class="o">+</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fixed</span><span class="p">)),</span> <span class="p">(</span><span class="n">fixed</span><span class="p">,</span><span class="n">fixed</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Ay</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

    <span class="n">g_new</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    <span class="n">z_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">g_new</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">g_new</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">);</span>
    <span class="n">disk_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_new</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">disk_new</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="c1">#% use the old result in case of getting NaN entries</span>
        <span class="n">disk_new</span> <span class="o">=</span> <span class="n">disk</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
        <span class="n">z_new</span> <span class="o">=</span> <span class="n">disk_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">disk_new</span><span class="p">[:,</span><span class="mi">2</span><span class="p">];</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;North pole step completed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reflection in the unit disk to a triangle. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_temp</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">bdy_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">));</span> <span class="c1"># this is an actual sort!!! </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">f_temp</span><span class="p">[</span><span class="n">f_temp</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">f_temp</span> <span class="o">=</span> <span class="n">f_temp</span> <span class="o">-</span> <span class="p">(</span><span class="n">f_temp</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">f_filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">f_temp</span><span class="p">)]);</span>

    <span class="n">z_filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">z_new</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">)]);</span>
    <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_filled</span><span class="p">)),</span> <span class="n">bdy_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="n">z_filled</span> <span class="o">=</span> <span class="n">z_filled</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="c1"># = [];</span>

    <span class="n">energy_old</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_new</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>

    <span class="n">iteration_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="n">map_opt</span> <span class="o">=</span> <span class="n">disk_new</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reflection completed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energy_old</span><span class="o">-</span><span class="n">energy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>

        <span class="n">energy_old</span> <span class="o">=</span> <span class="n">energy</span><span class="p">;</span>

        <span class="n">mu</span> <span class="o">=</span> <span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_new</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="c1"># vector.         </span>
        <span class="n">mu_filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">mu</span><span class="p">,</span> 
                               <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">((</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]])))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                                     <span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                                     <span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]])))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(((</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]])))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                                                                                                       <span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                                                                                                       <span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">[</span><span class="n">f</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]])))</span><span class="o">**</span><span class="mi">2</span><span class="p">))]);</span> <span class="c1"># doubles in length. </span>
        
        <span class="c1"># % fix the points near infinity</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_filled</span><span class="p">))</span>
        <span class="n">fixed2</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">/</span><span class="n">south</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])])];</span>
        <span class="n">map_filled</span> <span class="o">=</span> <span class="n">linear_beltrami_solver</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_filled</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_filled</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_filled</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                                            <span class="n">f_filled</span><span class="p">,</span> <span class="n">mu_filled</span><span class="p">,</span>
                                            <span class="n">fixed2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_filled</span><span class="p">[</span><span class="n">fixed2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_filled</span><span class="p">[</span><span class="n">fixed2</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span><span class="p">);</span>

        <span class="n">z_big</span> <span class="o">=</span> <span class="n">map_filled</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">map_filled</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z_final</span> <span class="o">=</span> <span class="n">z_big</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
        
        <span class="c1"># % normalization</span>
        <span class="n">z_final</span> <span class="o">=</span> <span class="n">z_final</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z_final</span><span class="p">);</span> <span class="c1">#% move centroid to zero</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_final</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">z_final</span> <span class="o">=</span> <span class="n">z_final</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_final</span><span class="p">)));</span> <span class="c1">#% map it into unit circle</span>

        <span class="n">mu_temp</span> <span class="o">=</span> <span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_final</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_final</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_final</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">f</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
        <span class="n">map_temp</span> <span class="o">=</span> <span class="n">linear_beltrami_solver</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_final</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_final</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_final</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                                          <span class="n">f</span><span class="p">,</span> 
                                          <span class="n">mu_temp</span><span class="p">,</span>     
                                          <span class="n">bdy_index</span><span class="p">,</span> 
                                          <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_final</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_final</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">])),</span> 
                                                    <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_final</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_final</span><span class="p">[</span><span class="n">bdy_index</span><span class="p">]))])</span><span class="o">.</span><span class="n">T</span><span class="p">);</span>

        <span class="n">z_new</span> <span class="o">=</span> <span class="n">map_temp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">map_temp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">];</span>

        <span class="n">z_filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">z_new</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">z_new</span><span class="p">)]);</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_filled</span><span class="p">)),</span> <span class="n">bdy_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">z_filled</span> <span class="o">=</span> <span class="n">z_filled</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="c1"># = [];</span>


        <span class="n">disk_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_new</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_new</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
        
        <span class="c1"># # return disk_new</span>
        <span class="c1"># # return disk_new</span>
        <span class="c1"># plt.figure(figsize=(10,10))</span>
        <span class="c1"># plt.title(&#39;iter disk&#39;)</span>
        <span class="c1"># plt.plot(disk[:,0], disk[:,1], &#39;r.&#39;, ms=.1)</span>
        <span class="c1"># plt.plot(disk_new[:,0], disk_new[:,1], &#39;g.&#39;, ms=.1)</span>
        <span class="c1"># plt.show()</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">disk_iter</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="c1"># % use the previous result in case of getting NaN entries</span>
            <span class="n">disk_iter</span> <span class="o">=</span> <span class="n">map_opt</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span> 
            <span class="c1"># disk_iter[:,0] = -disk_iter[:,0].copy(); # don&#39;t get this </span>

        <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">disk_iter</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
        <span class="n">map_opt</span> <span class="o">=</span> <span class="n">disk_iter</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
      
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Iteration </span><span class="si">%d</span><span class="s1">: mean(|mu|) = </span><span class="si">%.4f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iteration_count</span><span class="p">,</span> <span class="n">energy</span><span class="p">));</span>
        <span class="n">iteration_count</span> <span class="o">=</span> <span class="n">iteration_count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="n">iteration_count</span> <span class="o">&gt;</span> <span class="n">max_iter</span><span class="p">:</span>
            <span class="c1"># % it usually converges within 5 iterations so we set 5 here</span>
            <span class="k">break</span><span class="p">;</span>


    <span class="n">disk_new</span> <span class="o">=</span> <span class="n">map_opt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># disk_new[:,0] = -disk_new[:,0].copy()</span>

    <span class="c1"># # return disk_new</span>
    <span class="c1"># plt.figure(figsize=(10,10))</span>
    <span class="c1"># plt.title(&#39;final disk&#39;)</span>
    <span class="c1"># plt.plot(disk[:,0], disk[:,1], &#39;r.&#39;, ms=.1)</span>
    <span class="c1"># plt.plot(disk_new[:,0], disk_new[:,1], &#39;g.&#39;, ms=.1)</span>
    <span class="c1"># plt.show()</span>

    <span class="k">return</span> <span class="n">disk_new</span></div>


<span class="k">def</span> <span class="nf">_squicircle</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">_epsilon</span> <span class="o">=</span> <span class="mf">0.0000000001</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="c1">#_fgs_disc_to_square</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">u</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">v</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">u2</span> <span class="o">+</span> <span class="n">v2</span>

    <span class="n">uv</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span>
    <span class="n">fouru2v2</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">uv</span> <span class="o">*</span> <span class="n">uv</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">*</span> <span class="p">(</span><span class="n">r2</span> <span class="o">-</span> <span class="n">fouru2v2</span><span class="p">)</span>
    <span class="n">sgnuv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
    <span class="n">sgnuv</span><span class="p">[</span><span class="n">uv</span><span class="o">==</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sqrto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">r2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rad</span><span class="p">)))</span>

    <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_epsilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgnuv</span> <span class="o">/</span> <span class="n">u</span> <span class="o">*</span> <span class="n">sqrto</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_epsilon</span><span class="p">]</span>
    <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_epsilon</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgnuv</span> <span class="o">/</span> <span class="n">v</span> <span class="o">*</span> <span class="n">sqrto</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_epsilon</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_elliptical_nowell</span><span class="p">(</span><span class="n">uv</span><span class="p">):</span>

    <span class="c1">#https://squircular.blogspot.com/2015/09/mapping-circle-to-square.html</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">u</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">x</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mf">.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># there is one nan. </span>
    <span class="n">nan_select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># check the nan in the original </span>
    <span class="n">x</span><span class="p">[</span><span class="n">nan_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">nan_select</span><span class="p">])</span> <span class="c1"># map to 1 or -1</span>
    <span class="n">y</span><span class="p">[</span><span class="n">nan_select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">nan_select</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="find_and_loc_corner_rect_open_surface"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.find_and_loc_corner_rect_open_surface">[docs]</a><span class="k">def</span> <span class="nf">find_and_loc_corner_rect_open_surface</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">vol_shape</span><span class="p">,</span> <span class="n">ref_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;cc&#39;</span><span class="p">,</span> <span class="n">curvature_flow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delta_flow</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">flow_iters</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find and locate the 4 corners of a rectangular topography mesh. Curvature flow of the boundary is used to identify the corners fast and accurately</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        a simply-connected open triangle topography mesh</span>
<span class="sd">    vol_shape : (D,U,V) tuple</span>
<span class="sd">        the shape of the topography volume space the topography mesh comes from         </span>
<span class="sd">    ref_depth : int </span>
<span class="sd">        if curvature_flow=False, this is the depth coordinate of the topography mesh used to locate corners (implicitly assuming all corners are of equal depth) </span>
<span class="sd">    order : &#39;cc&#39; or &#39;acc&#39;    </span>
<span class="sd">        specifies whether the input mesh has faces oriented &#39;cc&#39;-clockwise or &#39;acc&#39;-anticlockwise</span>
<span class="sd">    curvature_flow : bool</span>
<span class="sd">        if True, uses curvature flow of the boundary to help locate the corners of the topography mesh. This is most accurate. If False, the corners will attempt to be found by idealistic matching to 4 corners constructed by ref_depth and the 4 corners of the image grid spanned by vertices of the input mesh</span>
<span class="sd">    delta_flow : scalar </span>
<span class="sd">        specifies the speed of flow if curvature_flow=True. Higher flow gives faster convergence. </span>
<span class="sd">    flow_iters : int</span>
<span class="sd">        specifies the number of iterations of curvature flow. Higher will give more flow </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bnd : (n,) array</span>
<span class="sd">        the vertex indices of the boundary of the topography mesh </span>
<span class="sd">    corner_bnd_ind : (4,) array</span>
<span class="sd">        the indices of ``bnd`` specifying the 4 corners in anti-clockwise order</span>
<span class="sd">    corner_v_ind : (4,) array</span>
<span class="sd">        the vertex indices of the input mesh specifying the 4 corners in anti-clockwise order</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span> 
    
    <span class="c1"># make copy of the input mesh. </span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    

    <span class="c1"># =============================================================================</span>
    <span class="c1">#   3) Fix the boundary of the surface unwrapping </span>
    <span class="c1"># =============================================================================</span>

    <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vol_shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">order</span><span class="o">==</span><span class="s1">&#39;cc&#39;</span><span class="p">:</span>
        <span class="c1"># the 4 corners of the image. </span>
        <span class="n">corner1yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">corner2yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">corner3yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">corner4yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span><span class="s1">&#39;acc&#39;</span><span class="p">:</span>
        <span class="c1"># the 4 corners of the image. </span>
        <span class="n">corner1yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">corner2yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">corner3yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">corner4yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    

    <span class="c1">## convert the coordinates to the indices of the open boundary</span>
    <span class="n">bnd</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># vertex index. </span>
    <span class="n">bnd_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">bnd</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">bnd_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bnd</span><span class="p">))</span>

    <span class="c1"># initial algorithm which fails to properly constrain the x-y plane </span>
    <span class="c1"># the problem here is because of the curvature of the curve... -&gt; to be fully accurate we should do curvature flow of the bounary edge line!.</span>
    <span class="k">if</span> <span class="n">curvature_flow</span><span class="p">:</span>
        <span class="n">bnd_vertex_evolve</span> <span class="o">=</span> <span class="n">conformalized_mean_line_flow</span><span class="p">(</span> <span class="n">bnd_vertex</span><span class="p">,</span> 
                                                             <span class="n">E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                                             <span class="n">close_contour</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                             <span class="n">fixed_boundary</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                                             <span class="n">lambda_flow</span><span class="o">=</span><span class="n">delta_flow</span><span class="p">,</span> 
                                                             <span class="n">niters</span><span class="o">=</span><span class="n">flow_iters</span><span class="p">,</span> 
                                                             <span class="n">topography_edge_fix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                             <span class="n">conformalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># we then solve for the index on the evolved boundary!. </span>
        <span class="n">min1_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex_evolve</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner1yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">min2_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex_evolve</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner2yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">min3_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex_evolve</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner3yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">min4_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex_evolve</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner4yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">min1_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner1yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">min2_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner2yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">min3_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner3yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">min4_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bnd_vertex</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ref_depth</span><span class="p">,</span> <span class="n">corner4yx</span><span class="p">])[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">pts1_ind_bnd</span> <span class="o">=</span> <span class="n">bnd_index</span><span class="p">[</span><span class="n">min1_ind</span><span class="p">]</span>
    <span class="n">pts2_ind_bnd</span> <span class="o">=</span> <span class="n">bnd_index</span><span class="p">[</span><span class="n">min2_ind</span><span class="p">]</span>
    <span class="n">pts3_ind_bnd</span> <span class="o">=</span> <span class="n">bnd_index</span><span class="p">[</span><span class="n">min3_ind</span><span class="p">]</span>
    <span class="n">pts4_ind_bnd</span> <span class="o">=</span> <span class="n">bnd_index</span><span class="p">[</span><span class="n">min4_ind</span><span class="p">]</span>

    <span class="n">pts1_ind_v</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="n">min1_ind</span><span class="p">]</span>
    <span class="n">pts2_ind_v</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="n">min2_ind</span><span class="p">]</span>
    <span class="n">pts3_ind_v</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="n">min3_ind</span><span class="p">]</span>
    <span class="n">pts4_ind_v</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="n">min4_ind</span><span class="p">]</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#    3) rectangular conformal map -&gt; first maps to the disk  </span>
<span class="c1"># =============================================================================</span>
    <span class="c1"># stack the corners. </span>
    <span class="n">corner_bnd_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pts1_ind_bnd</span><span class="p">,</span> <span class="n">pts2_ind_bnd</span><span class="p">,</span> <span class="n">pts3_ind_bnd</span><span class="p">,</span> <span class="n">pts4_ind_bnd</span><span class="p">])</span>
    <span class="n">corner_v_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pts1_ind_v</span><span class="p">,</span> <span class="n">pts2_ind_v</span><span class="p">,</span> <span class="n">pts3_ind_v</span><span class="p">,</span> <span class="n">pts4_ind_v</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">bnd</span><span class="p">,</span> <span class="n">corner_bnd_ind</span><span class="p">,</span> <span class="n">corner_v_ind</span></div>


<div class="viewcode-block" id="reconstruct_border_inds"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.reconstruct_border_inds">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_border_inds</span><span class="p">(</span><span class="n">all_border_inds</span><span class="p">,</span> <span class="n">corner_inds</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given an ordered list of corner indices within an array of boundary indices specifying a closed loop, construct the continuous line segments linking the corner points     </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_border_inds : (N,) array</span>
<span class="sd">        array of vertex indices specifying the boundary of a mesh</span>
<span class="sd">    corner_inds : (n_corners,) array</span>
<span class="sd">        array specifying which indices of ``all_border_inds`` are &#39;corners&#39;. This should be ordered such that corner_inds[0]:corner_inds[1] constitute a continuous segment.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    segs : list of n_corners+1 arrays </span>
<span class="sd">        a list of all the continuous boundary segments between consecutive corners </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">corner_inds_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">corner_inds</span><span class="p">,</span> <span class="n">corner_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="c1"># print(corner_inds_)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corner_inds_</span><span class="p">)</span>
    <span class="n">segs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">corner_inds_</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> 
        <span class="n">end</span> <span class="o">=</span> <span class="n">corner_inds_</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print(start,end)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_border_inds</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> 
                              <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">)])</span>
        <span class="n">segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">segs</span></div>


<div class="viewcode-block" id="flat_open_surface"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.flat_open_surface">[docs]</a><span class="k">def</span> <span class="nf">flat_open_surface</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">vol_shape</span><span class="p">,</span> <span class="n">map2square</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">square_method</span><span class="o">=</span><span class="s1">&#39;elliptical&#39;</span><span class="p">,</span> 
                        <span class="n">ref_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                        <span class="n">order</span><span class="o">=</span><span class="s1">&#39;cc&#39;</span><span class="p">,</span> 
                        <span class="n">curvature_flow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                        <span class="n">delta_flow</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> 
                        <span class="n">flow_iters</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                        <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Main wrapping function to unwrap an open 3D mesh, primarily a topography into 2D disk, or 2D rectangle (continuing from the 2D disk)   </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh : trimesh.Trimesh</span>
<span class="sd">        a simply-connected open triangle topography mesh</span>
<span class="sd">    vol_shape : (M,N,L) tuple</span>
<span class="sd">        the shape of the volume space the topography mesh comes from </span>
<span class="sd">    map2square : bool</span>
<span class="sd">        If True, continue to map the disk to the square or conformal rectangle with options specified by ``square_method``. If False or if square_method=None, the intermediate disk parameterization is returned </span>
<span class="sd">    square_method : str</span>
<span class="sd">        One of &#39;Teichmuller&#39; for conformal rectangular mapping, &#39;squicircle&#39; for squicircle squaring of disk to square, &#39;elliptical&#39; for elliptical mapping of Nowell of disk to square. &#39;Teichmuller&#39; is slow but conformal minimizing.   </span>
<span class="sd">    ref_depth : int</span>
<span class="sd">        if curvature_flow=False, this is the depth coordinate of the topography mesh used to locate corners (implicitly assuming all corners are of equal depth) </span>
<span class="sd">    order : &#39;cc&#39; or &#39;acc&#39;</span>
<span class="sd">        specifies whether the input mesh has faces oriented &#39;cc&#39;-clockwise or &#39;acc&#39;-anticlockwise</span>
<span class="sd">    optimize : bool</span>
<span class="sd">        if True, applies Beltrami coefficient optimization to compute the rectangular aspect ratio to minimize distortion given the square_method=&#39;squicircle&#39; and square_method=&#39;elliptical&#39; options. Teichmuller by default will have this option enabled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    square : (n_vertices, 2)</span>
<span class="sd">        the disk or square parametrization of the input mesh </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fminbound</span>

    <span class="c1"># make copy of the input mesh. </span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    

    <span class="c1"># =============================================================================</span>
    <span class="c1">#   3) Fix the boundary of the surface unwrapping </span>
    <span class="c1"># =============================================================================</span>
    <span class="c1"># d, m, n = vol_shape[:3]</span>
    
    <span class="c1"># if order==&#39;cc&#39;:</span>
    <span class="c1">#     # the 4 corners of the image. </span>
    <span class="c1">#     corner1yx = np.hstack([0,0]) </span>
    <span class="c1">#     corner2yx = np.hstack([m-1,0])</span>
    <span class="c1">#     corner3yx = np.hstack([m-1,n-1])</span>
    <span class="c1">#     corner4yx = np.hstack([0,n-1])</span>

    <span class="c1"># if order ==&#39;acc&#39;:</span>
    <span class="c1">#     # the 4 corners of the image. </span>
    <span class="c1">#     corner1yx = np.hstack([0,0]) </span>
    <span class="c1">#     corner2yx = np.hstack([0,n-1])</span>
    <span class="c1">#     corner3yx = np.hstack([m-1,n-1])</span>
    <span class="c1">#     corner4yx = np.hstack([m-1,0])</span>
    

    <span class="c1"># ## convert the coordinates to the indices of the open boundary</span>
    <span class="c1"># bnd = igl.boundary_loop(f) # vertex index. </span>
    <span class="c1"># bnd_vertex = v[bnd].copy()</span>

    <span class="c1"># &quot;&quot;&quot;</span>
    <span class="c1"># to do: replace this with the actual boundary.... </span>
    <span class="c1"># &quot;&quot;&quot;</span>
    <span class="c1"># # match by distance rather than exact match. </span>
    <span class="c1"># pts1_ind = bnd[np.argmin(np.linalg.norm(bnd_vertex - np.hstack([ref_depth, corner1yx])[None,:], axis=-1))]</span>
    <span class="c1"># pts2_ind = bnd[np.argmin(np.linalg.norm(bnd_vertex - np.hstack([ref_depth, corner2yx])[None,:], axis=-1))]</span>
    <span class="c1"># pts3_ind = bnd[np.argmin(np.linalg.norm(bnd_vertex - np.hstack([ref_depth, corner3yx])[None,:], axis=-1))]</span>
    <span class="c1"># pts4_ind = bnd[np.argmin(np.linalg.norm(bnd_vertex - np.hstack([ref_depth, corner4yx])[None,:], axis=-1))]</span>
    <span class="n">bnd</span><span class="p">,</span> <span class="n">corner_bnd_ind</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_and_loc_corner_rect_open_surface</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> 
                                                                   <span class="n">vol_shape</span><span class="p">,</span> 
                                                                   <span class="n">ref_depth</span><span class="o">=</span><span class="n">ref_depth</span><span class="p">,</span> 
                                                                   <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> 
                                                                   <span class="n">curvature_flow</span><span class="o">=</span><span class="n">curvature_flow</span><span class="p">,</span> 
                                                                   <span class="n">delta_flow</span><span class="o">=</span><span class="n">delta_flow</span><span class="p">,</span> 
                                                                   <span class="n">flow_iters</span><span class="o">=</span><span class="n">flow_iters</span><span class="p">)</span>
    <span class="n">bnd_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">bnd</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">pts1_ind</span><span class="p">,</span> <span class="n">pts2_ind</span><span class="p">,</span> <span class="n">pts3_ind</span><span class="p">,</span> <span class="n">pts4_ind</span> <span class="o">=</span> <span class="n">corner_bnd_ind</span>

    <span class="c1"># # this needs proper sorting... </span>
    <span class="c1"># print(pts1_ind, pts2_ind, pts3_ind, pts4_ind)</span>
    
    <span class="c1"># import pylab as plt </span>
    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot([corner1yx[0], corner2yx[0], corner3yx[0], corner4yx[0]],</span>
    <span class="c1">#          [corner1yx[1], corner2yx[1], corner3yx[1], corner4yx[1]], &#39;r.-&#39;)</span>
    <span class="c1"># plt.show()</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#    3) rectangular conformal map -&gt; first maps to the disk  </span>
<span class="c1"># =============================================================================</span>
    <span class="c1"># stack the corners. </span>
    <span class="n">corner</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pts1_ind</span><span class="p">,</span> <span class="n">pts2_ind</span><span class="p">,</span> <span class="n">pts3_ind</span><span class="p">,</span> <span class="n">pts4_ind</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">map2square</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">square_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">square_method</span> <span class="o">==</span> <span class="s1">&#39;Teichmuller&#39;</span><span class="p">:</span>
                <span class="n">square</span><span class="p">,</span> <span class="n">h_opt</span> <span class="o">=</span> <span class="n">rectangular_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">corner</span><span class="p">,</span> <span class="n">map2square</span><span class="o">=</span><span class="n">map2square</span><span class="p">)</span>
                <span class="c1"># return square </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># then the disk = the remesh. </span>
                <span class="n">disk</span> <span class="o">=</span> <span class="n">rectangular_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">corner</span><span class="p">,</span> <span class="n">map2square</span><span class="o">=</span><span class="n">map2square</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">square_method</span> <span class="o">==</span> <span class="s1">&#39;squicircle&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;squicircle&#39;</span><span class="p">)</span>
                    <span class="n">square</span> <span class="o">=</span> <span class="n">_squicircle</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">square_method</span> <span class="o">==</span> <span class="s1">&#39;elliptical&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;elliptical&#39;</span><span class="p">)</span>
                    <span class="n">square</span> <span class="o">=</span> <span class="n">_elliptical_nowell</span><span class="p">(</span><span class="n">disk</span><span class="p">)</span>

                <span class="c1"># then we try to optimize aspect ratio to get conformality. </span>
                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beltrami_coefficient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">square</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span><span class="n">h</span><span class="o">*</span><span class="n">square</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]]),</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
                    <span class="n">h_opt</span> <span class="o">=</span> <span class="n">fminbound</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
                    <span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">square</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">h_opt</span><span class="o">*</span><span class="n">square</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span><span class="p">;</span>
                <span class="c1"># return square     </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">disk</span> <span class="o">=</span> <span class="n">rectangular_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">corner</span><span class="p">,</span> <span class="n">map2square</span><span class="o">=</span><span class="n">map2square</span><span class="p">)</span>
            <span class="c1"># print(&#39;direct return&#39;)</span>
            <span class="n">square</span> <span class="o">=</span> <span class="n">disk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># return square</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># print(&#39;Teichmuller&#39;)</span>
        <span class="c1"># then the disk = the remesh.</span>
        <span class="c1"># default to disk!.  </span>
        <span class="n">disk</span> <span class="o">=</span> <span class="n">rectangular_conformal_map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">corner</span><span class="p">,</span> <span class="n">map2square</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">square</span> <span class="o">=</span> <span class="n">disk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">square</span></div>
    


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">mesh quality metrics. </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># not used. </span>
<span class="c1"># def conformal_distortion_factor_trimesh(pts2D, pts3D, triangles, eps=1e-20):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # this metric is implemented from http://hhoppe.com/tmpm.pdf and which seems to be mainly used by all the graphical community.</span>
<span class="c1">#     # 1 = conformal, this is also just the stretch factor.</span>
<span class="c1">#     # measuring  the  quasi-conformal  error,  computed  as  the  area-weighted  average of  the  ratios  of  the  largest  to  smallest  singular  values  of the maps Jacobian </span>
<span class="c1">#     import igl </span>
<span class="c1">#     import numpy as np </span>

<span class="c1">#     tri2D = pts2D[triangles].copy() # N x 3 x 2</span>
<span class="c1">#     tri3D = pts3D[triangles].copy() # N x 3 x 3 </span>

<span class="c1">#     q1 = tri3D[:,0].copy()</span>
<span class="c1">#     q2 = tri3D[:,1].copy()</span>
<span class="c1">#     q3 = tri3D[:,2].copy()</span>

<span class="c1">#     # 2D coordinates.</span>
<span class="c1">#     s1 = tri2D[:,0,0].copy()</span>
<span class="c1">#     s2 = tri2D[:,1,0].copy()</span>
<span class="c1">#     s3 = tri2D[:,2,0].copy()</span>

<span class="c1">#     t1 = tri2D[:,0,1].copy()</span>
<span class="c1">#     t2 = tri2D[:,1,1].copy()</span>
<span class="c1">#     t3 = tri2D[:,2,1].copy()</span>


<span class="c1">#     # A = ((tri2D[:,1,0] - tri2D[:,0,0]) * (tri2D[:,2,1] - tri2D[:,0,1]) - (tri2D[:,2,0] - tri2D[:,0,0]) * (tri2D[:,1,1] - tri2D[:,0,1])) / 2. # area 2D triangles </span>
<span class="c1">#     A = ((s2 - s1)*(t3-t1) - (s3 - s1)*(t2-t1)) / 2.</span>
<span class="c1">#     Ss = (q1*(t2-t3)[:,None] + q2*(t3-t1)[:,None] + q3*(t1-t2)[:,None]) / (2*A[:,None] + eps) # dS / ds</span>
<span class="c1">#     St = (q1*(s3-s2)[:,None] + q2*(s1-s3)[:,None] + q3*(s2-s1)[:,None]) / (2*A[:,None] + eps) # dS / dt</span>

<span class="c1">#     # get the largest and smaller single values of the Jacobian for each element... </span>
<span class="c1">#     a = Ss.dot(Ss)</span>
<span class="c1">#     b = Ss.dot(St)</span>
<span class="c1">#     c = St.dot(St)</span>

<span class="c1">#     Gamma = np.sqrt((a+c + np.sqrt((a-c)**2 + 4*b**2))/2.)</span>
<span class="c1">#     gamma = np.sqrt((a+c - np.sqrt((a-c)**2 + 4*b**2))/2.)</span>

<span class="c1">#     stretch_ratios = Gamma/gamma </span>

<span class="c1">#     area = igl.doublearea(pts3D,triangles) #total area. </span>
<span class="c1">#     mean_stretch_ratio = np.nansum(area * stretch_ratios) / (np.nansum(area))</span>

<span class="c1">#     return mean_stretch_ratio, stretch_ratios</span>


<span class="c1"># # compute the 3D to 3D deformation analysis. </span>
<span class="c1"># # def statistical_strain_rate_mesh(grid_squares_time, unwrap_params_3D):</span>
<span class="c1"># def statistical_strain_mesh3D(pts1, pts2, triangles):</span>
    
<span class="c1">#     # we do this in (x,y,z) coordinates. for polygonal mesh. </span>
<span class="c1">#     # see, http://graner.net/francois/publis/graner_tools.pdf for an introduction of the mathematics. </span>
<span class="c1">#     # both pts1 and pts2 are 3D ! </span>

<span class="c1">#     import numpy as np </span>

<span class="c1">#     # compute the differential change in links. </span>
<span class="c1">#     triangles1 = pts1[triangles].copy() # N_tri x 3 x 3 </span>
<span class="c1">#     triangles2 = pts2[triangles].copy() </span>

<span class="c1">#     # form the displacements -&gt; i.e the edge vectors !. </span>
<span class="c1">#     links_3D = triangles1 - triangles2 # displacements (x,y,z)</span>


<span class="c1">#     # build the covariance matrices. </span>
<span class="c1">#     M_matrix_00 = np.mean( links_3D[...,0] ** 2, axis=1)</span>
<span class="c1">#     M_matrix_01 = np.mean( links_3D[...,0] * links_3D[...,1], axis=1)</span>
<span class="c1">#     M_matrix_02 = np.mean( links_3D[...,0] * links_3D[...,2], axis=1)</span>
<span class="c1">#     M_matrix_10 = np.mean( links_3D[...,1] * links_3D[...,0], axis=1)</span>
<span class="c1">#     M_matrix_11 = np.mean( links_3D[...,1] **2, axis=1)</span>
<span class="c1">#     M_matrix_12 = np.mean( links_3D[...,1] * links_3D[...,2], axis=1)</span>
<span class="c1">#     M_matrix_20 = np.mean( links_3D[...,2] * links_3D[...,0], axis=1)</span>
<span class="c1">#     M_matrix_21 = np.mean( links_3D[...,2] * links_3D[...,1], axis=1)</span>
<span class="c1">#     M_matrix_22 = np.mean( links_3D[...,2] **2, axis=-1)</span>
    
<span class="c1">#     # compute the inverse 3 x 3 matrix using fomulae.</span>
<span class="c1">#     M_matrix = np.array([[M_matrix_00, M_matrix_01, M_matrix_02], </span>
<span class="c1">#                          [M_matrix_10, M_matrix_11, M_matrix_12], </span>
<span class="c1">#                          [M_matrix_20, M_matrix_21, M_matrix_22]])</span>
    
<span class="c1">#     M_matrix = M_matrix.transpose(2,0,1) </span>

<span class="c1">#     # from this we should be able to go ahead and extract the principal strains. </span>
    
<span class="c1">#     return M_matrix</span>



<span class="c1">### need to check the following. </span>
<span class="c1"># def mesh_strain_polygon(pts1, pts2, triangles):</span>
<span class="c1">#     r&quot;&quot;&quot; Compute the temporal polygonal mesh strain 3D deformation as described in reference [1]_</span>
    
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     pts1 : (n_time, n_vertices, 3) array</span>
<span class="c1">#         vertices of mesh 1 for all timepoints </span>
<span class="c1">#     pts2 : (n_time, n_vertices, 3) array </span>
<span class="c1">#         vertices of mesh 2 for all timepoints </span>
<span class="c1">#     triangles : (n_time, n_faces, 3) array</span>
<span class="c1">#         triangulations of the mesh at all timepoints</span>
        
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     V : </span>
<span class="c1">#         strain matrix     (symmetric component)</span>
<span class="c1">#     Omega : </span>
<span class="c1">#         rotational strain matrix (antisymmetric component)</span>
        
<span class="c1">#     References</span>
<span class="c1">#     ----------</span>
<span class="c1">#     .. [1] Graner, Franois, et al. &quot;Discrete rearranging disordered patterns, part I: Robust statistical tools in two or three dimensions.&quot; The European Physical Journal E 25.4 (2008): 349-369.</span>
    
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # we can do this in (x,y,z) coordinates.</span>
<span class="c1">#     # see, http://graner.net/francois/publis/graner_tools.pdf</span>
<span class="c1">#     import numpy as np </span>

<span class="c1">#     # get the triangles and combine.  </span>
<span class="c1">#     triangles12 = np.array([pts1[triangles], </span>
<span class="c1">#                             pts2[triangles]]) # combine to 2 x N_tri x 3 x 3</span>
<span class="c1">#     triangles12 = np.concatenate([triangles12, </span>
<span class="c1">#                                   triangles12[:,:,0,:][:,:,None,:]], axis=2)</span>

<span class="c1">#     links_squares_time_3D = triangles12[:,:,1:] - triangles12[:,:,:-1] # compute the edge vectors. </span>
<span class="c1">#     # links_squares_time_3D = unwrap_params_3D[grid_squares_time[:,:,1:,1].astype(np.int), </span>
<span class="c1">#     #                                           grid_squares_time[:,:,1:,0].astype(np.int)] - unwrap_params_3D[grid_squares_time[:,:,:-1,1].astype(np.int), </span>
<span class="c1">#     #                                           grid_squares_time[:,:,:-1,0].astype(np.int)]</span>
    
<span class="c1">#     # time differential. =&gt; here this is the evolution.   </span>
<span class="c1">#     d_links_squares_time_3D = links_squares_time_3D[1:] - links_squares_time_3D[:-1] # this is the stretch ...    </span>
<span class="c1">#     # links_squares_time_3D = links_squares_time_3D[1:] - links_squares_time_3D[:-1] # this is the stretch ...    </span>

<span class="c1">#     M_matrix_00 = np.mean( links_squares_time_3D[...,0] ** 2, axis=-1) # take the 2nd last to get the average of the polygons.</span>
<span class="c1">#     M_matrix_01 = np.mean( links_squares_time_3D[...,0] * links_squares_time_3D[...,1], axis=-1)</span>
<span class="c1">#     M_matrix_02 = np.mean( links_squares_time_3D[...,0] * links_squares_time_3D[...,2], axis=-1)</span>
<span class="c1">#     M_matrix_10 = np.mean( links_squares_time_3D[...,1] * links_squares_time_3D[...,0], axis=-1)</span>
<span class="c1">#     M_matrix_11 = np.mean( links_squares_time_3D[...,1] **2, axis=-1)</span>
<span class="c1">#     M_matrix_12 = np.mean( links_squares_time_3D[...,1] * links_squares_time_3D[...,2], axis=-1)</span>
<span class="c1">#     M_matrix_20 = np.mean( links_squares_time_3D[...,2] * links_squares_time_3D[...,0], axis=-1)</span>
<span class="c1">#     M_matrix_21 = np.mean( links_squares_time_3D[...,2] * links_squares_time_3D[...,1], axis=-1)</span>
<span class="c1">#     M_matrix_22 = np.mean( links_squares_time_3D[...,2] **2, axis=-1)</span>
    
<span class="c1">#     # compute the inverse 3 x 3 matrix using fomulae.</span>
<span class="c1">#     M_matrix = np.array([[M_matrix_00, M_matrix_01, M_matrix_02], </span>
<span class="c1">#                          [M_matrix_10, M_matrix_11, M_matrix_12], </span>
<span class="c1">#                          [M_matrix_20, M_matrix_21, M_matrix_22]])</span>
    
<span class="c1">#     M_matrix = M_matrix.transpose(2,3,0,1)</span>
<span class="c1">#     M_inv = np.linalg.pinv(M_matrix.reshape(-1,3,3)).reshape(M_matrix.shape)</span>
    
<span class="c1">#     # print(np.allclose(M_matrix[0,0], np.dot(M_matrix[0,0], np.dot(M_inv[0,0], M_matrix[0,0]))))</span>
<span class="c1"># # #    print(M_inv[0,0])</span>
<span class="c1"># # #    print(np.linalg.inv(M_matrix[0,0]))</span>
<span class="c1"># # #    print(np.dot(M_matrix[0,0], np.linalg.inv(M_matrix[0,0])))</span>
    
<span class="c1">#     C_matrix_00 = np.mean( links_squares_time_3D[:-1,...,0] * d_links_squares_time_3D[...,0], axis=-1) # this one is inner product.... </span>
<span class="c1">#     C_matrix_01 = np.mean( links_squares_time_3D[:-1,...,0] * d_links_squares_time_3D[...,1], axis=-1)</span>
<span class="c1">#     C_matrix_02 = np.mean( links_squares_time_3D[:-1,...,0] * d_links_squares_time_3D[...,2], axis=-1)</span>
<span class="c1">#     C_matrix_10 = np.mean( links_squares_time_3D[:-1,...,1] * d_links_squares_time_3D[...,0], axis=-1)</span>
<span class="c1">#     C_matrix_11 = np.mean( links_squares_time_3D[:-1,...,1] * d_links_squares_time_3D[...,1], axis=-1)</span>
<span class="c1">#     C_matrix_12 = np.mean( links_squares_time_3D[:-1,...,1] * d_links_squares_time_3D[...,2], axis=-1)</span>
<span class="c1">#     C_matrix_20 = np.mean( links_squares_time_3D[:-1,...,2] * d_links_squares_time_3D[...,0], axis=-1)</span>
<span class="c1">#     C_matrix_21 = np.mean( links_squares_time_3D[:-1,...,2] * d_links_squares_time_3D[...,1], axis=-1)</span>
<span class="c1">#     C_matrix_22 = np.mean( links_squares_time_3D[:-1,...,2] * d_links_squares_time_3D[...,2], axis=-1)</span>

<span class="c1">#     C_matrix = np.array([[C_matrix_00, C_matrix_01, C_matrix_02], </span>
<span class="c1">#                          [C_matrix_10, C_matrix_11, C_matrix_12], </span>
<span class="c1">#                          [C_matrix_20, C_matrix_21, C_matrix_22]])</span>
<span class="c1">#     C_matrix = C_matrix.transpose(2,3,0,1)</span>
<span class="c1">#     C_matrix_T = C_matrix.transpose(0,1,3,2) # obtain the matrix transpose.</span>
    
<span class="c1"># #    V = 1./2 *( np.matmul(M_inv.reshape(-1,3,3), C_matrix.reshape()) + np.matmul(C_matrix_T, M_inv))</span>
    
<span class="c1"># #    MM = M_inv.reshape(-1,3,3)</span>
<span class="c1"># #    CC = C_matrix.reshape(-1,3,3)</span>
<span class="c1"># #    CC_T = C_matrix_T.reshape(-1,3,3)</span>
<span class="c1">#     V = 1./2 *( np.matmul(M_inv[:-1], C_matrix) + </span>
<span class="c1">#                 np.matmul(C_matrix_T, M_inv[:-1]))</span>

<span class="c1">#     Omega = 1./2 * ( np.matmul(M_inv[:-1], C_matrix) - </span>
<span class="c1">#                      np.matmul(C_matrix_T, M_inv[:-1]))</span>
    
<span class="c1">#     return V, Omega</span>
<span class="c1">#     # return M_matrix</span>


<div class="viewcode-block" id="map_3D_to_2D_triangles"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.map_3D_to_2D_triangles">[docs]</a><span class="k">def</span> <span class="nf">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Isometric projection of 3D triangles to 2D coordinates This function implements the solution of [1]_. This function is similar to igl.project_isometrically_to_plane</span>

<span class="sd">    Given the vertices :math:`v_1, v_2, v_3` of a triangle in 3D, a 2D isometric projection can be constructed that preserves length and area with new vertex coordinate defined by </span>

<span class="sd">    .. math::</span>
<span class="sd">        v^{2D}_1 &amp;= (0, 0) \\</span>
<span class="sd">        v^{2D}_2 &amp;= (|A|, 0) \\</span>
<span class="sd">        v^{2D}_3 &amp;= (A.B/ |A|, |A \times B|/|A|)</span>

<span class="sd">    where :math:`A=v_2-v_1`, :math:`B=v_3-v_1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts3D : (n_vertices,3) array</span>
<span class="sd">        the 3D vertices of the mesh </span>
<span class="sd">    triangles : (n_faces,3) array</span>
<span class="sd">        the triangulation of pts3D given by vertex indices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pts_2D : (n_faces,2) array</span>
<span class="sd">        the vertices of the triangle in 2D </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://stackoverflow.com/questions/8051220/flattening-a-3d-triangle</span>
<span class="sd">    .. [2] https://scicomp.stackexchange.com/questions/25327/finding-shape-functions-for-a-triangle-in-3d-coordinate-space</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">pts_tri</span> <span class="o">=</span> <span class="n">pts3D</span><span class="p">[</span><span class="n">triangles</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">pts_tri</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts_tri</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">pts_tri</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pts_tri</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> 

    <span class="c1"># set the first point to (0,0)</span>
    <span class="n">pts_2D_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">pts_tri</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>  
    <span class="n">pts_2D_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts_tri</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]])</span>
    <span class="n">pts_2D_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span> 
    <span class="n">pts_2D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts_2D_0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:],</span> 
                             <span class="n">pts_2D_1</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:],</span> 
                             <span class="n">pts_2D_2</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pts_2D</span></div>



<div class="viewcode-block" id="quasi_conformal_error"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.quasi_conformal_error">[docs]</a><span class="k">def</span> <span class="nf">quasi_conformal_error</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">pts2_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Computes the quasi-conformal error between two 3D triangle meshes as defined in [1]_ </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts1_3D : (n_vertices,3) array</span>
<span class="sd">        vertices of mesh 1 </span>
<span class="sd">    pts2_3D : (n_vertices,3) array</span>
<span class="sd">        vertices of mesh 2 </span>
<span class="sd">    triangles : (n_faces,3) array</span>
<span class="sd">        the triangulation of pts1_3D and pts2_3D in terms of the vertex indices</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    Jac_eigvals : (n_faces,)</span>
<span class="sd">        eigenvalues of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</span>
<span class="sd">    stretch_factor : (n_faces,)</span>
<span class="sd">        the ratio of the square root of maximum singular value over square root of of the minimum singular value of the square form of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</span>
<span class="sd">    mean_stretch_factor : scalar</span>
<span class="sd">        the area weighted mean stretch factor or quasi-conformal error  </span>
<span class="sd">    (areas3D, areas3D_2) : ((n_faces,), (n_faces,)) list of arrays </span>
<span class="sd">        the triangle areas of the first and second mesh respectively</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Hormann, K. &amp; Greiner, G. MIPS: An efficient global parametrization method. (Erlangen-Nuernberg Univ (Germany) Computer Graphics Group, 2000)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    maps R^3 to R^2 triangle. Describes the transformation by linear means -&gt; equivalent to the jacobian matrix.</span>
<span class="sd">        # we also take the opportunity to compute the area.          </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="c1"># map the 3D triangle to 2D triangle coordinates. </span>
    <span class="n">pts1_2D</span> <span class="o">=</span> <span class="n">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
    <span class="n">pts2_2D</span> <span class="o">=</span> <span class="n">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts2_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>

    <span class="c1"># convert 2D coordinates to homogeneous coordinates in order to solve uniquely.</span>
    <span class="c1"># having converted we can now get the jacobian by specifying Y = AX (homogeneous coordinates.)</span>
    <span class="n">pts1_2D_hom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts1_2D</span><span class="p">,</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">pts1_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts1_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pts2_2D_hom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts2_2D</span><span class="p">,</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">pts2_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts2_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pts1_2D_hom</span> <span class="o">=</span> <span class="n">pts1_2D_hom</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">pts2_2D_hom</span> <span class="o">=</span> <span class="n">pts2_2D_hom</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># solve exactly. </span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pts2_2D_hom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">pts1_2D_hom</span><span class="p">))</span> <span class="c1"># this really is just solving registration problem ? </span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pts2_2D_hom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">pts1_2D_hom</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">))</span> <span class="c1"># if fails we need a small eps to stabilise. </span>
    <span class="n">JacMatrix</span> <span class="o">=</span> <span class="n">Tmatrix</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># take the non jacobian component? </span>
    

    <span class="c1"># The error is given as the ratio of the largest to smallest eigenvalue. -&gt; since SVD, hence the singular values are squared. </span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">JacMatrix</span><span class="p">)</span>
    
    <span class="c1"># see http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/13_Parameterization2.pdf to better understand. </span>
    <span class="n">Jac_eigvals</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># stretch_factor is gotten from eigenvalues of J^T J</span>
    <span class="n">JacMatrix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">JacMatrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">JacMatrix</span><span class="p">)</span>
    <span class="n">stretch_eigenvalues</span><span class="p">,</span> <span class="n">stretch_eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">JacMatrix2</span><span class="p">)</span> <span class="c1"># this should be square root.! </span>
    <span class="c1"># stretch_eigenvalues = np.sqrt(stretch_eigenvalues) # we should do this !!!! since we squared the matrix form!. </span>

    <span class="c1"># stretch_factor = np.sqrt(np.max(np.abs(s), axis=1) / np.min(np.abs(s), axis=1)) # since this was SVD decomposition. </span>
    <span class="n">stretch_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># since this was SVD decomposition. </span>

    <span class="n">areas3D</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">mean_stretch_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas3D</span><span class="o">*</span><span class="n">stretch_factor</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areas3D</span><span class="p">))))</span> <span class="c1"># area weighted average.</span>

    <span class="c1"># we also compute the final areas to derive an area change factor. </span>
    <span class="n">areas3D_2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">pts2_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> 

    <span class="k">return</span> <span class="n">Jac_eigvals</span><span class="p">,</span> <span class="n">stretch_factor</span><span class="p">,</span> <span class="n">mean_stretch_factor</span><span class="p">,</span> <span class="p">(</span><span class="n">areas3D</span><span class="p">,</span> <span class="n">areas3D_2</span><span class="p">)</span></div>


<div class="viewcode-block" id="MIPS_cost"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.MIPS_cost">[docs]</a><span class="k">def</span> <span class="nf">MIPS_cost</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">pts2_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">area_mips_theta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm_pts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Most isometric parametrization (MIPs) and the Area-preserving MIPs cost defined in [1]_ and [2]_ respectively</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts1_3D : (n_vertices,3) array </span>
<span class="sd">        vertices of mesh 1 </span>
<span class="sd">    pts2_3D : (n_vertices,3) array </span>
<span class="sd">        vertices of mesh 2</span>
<span class="sd">    triangles : (n_faces,3) array</span>
<span class="sd">        the triangulation of pts1_3D and pts2_3D in terms of the vertex indices</span>
<span class="sd">    area_mips_theta : scalar</span>
<span class="sd">        the exponent of the area-preserving MIPs cost in [2]_. If area_mips_theta=1, the area-preserving MIPs measures the area uniformity of stretch distortion of the surface</span>
<span class="sd">    norm_pts : True</span>
<span class="sd">        normalize vertex points by the respective surface areas of the mesh before computing the cost</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (MIPS, area_MIPS, MIPS_plus) : ((n_faces,), (n_faces,), (n_faces,)) list of array</span>
<span class="sd">        the MIPs, area preserving MIPs and the direct sum of stretch + area distortion  </span>
<span class="sd">    (mean_MIPS, mean_area_MIPS, mean_MIPS_plus) : (3,) tuple</span>
<span class="sd">        tuple of the mean MIPs, area preserving MIPs and the sum of stretch + area distortion </span>
<span class="sd">    (sigma1,sigma2) : ((n_faces,), (n_faces,)) tuple </span>
<span class="sd">        the square root of the maximum singular and square root of the minimum singular value of the square form of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</span>
<span class="sd">    (stretch_eigenvalues, stretch_eigenvectors) : ((n_faces,), (n_faces,)) tuple </span>
<span class="sd">        the singular value eigenvalue matrix and corresponding eigenvector matrix of the square form of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Hormann, K. &amp; Greiner, G. MIPS: An efficient global parametrization method. (Erlangen-Nuernberg Univ (Germany) Computer Graphics Group, 2000)</span>
<span class="sd">    .. [2] Degener, P., Meseth, J. &amp; Klein, R. An Adaptable Surface Parameterization Method. IMR 3, 201-213 (2003).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    maps R^3 to R^2 triangle. Describes the transformation by linear means -&gt; equivalent to the jacobian matrix.</span>
<span class="sd">        # we also take the opportunity to compute the area.          </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    use the Most isometric parametrization cost. </span>
<span class="sd">    https://arxiv.org/pdf/1810.09031.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="k">if</span> <span class="n">norm_pts</span><span class="p">:</span>
        <span class="n">pts1_3D_</span> <span class="o">=</span> <span class="n">pts1_3D</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">((</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="n">pts2_3D_</span> <span class="o">=</span> <span class="n">pts2_3D</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">pts2_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">pts1_2D</span> <span class="o">=</span> <span class="n">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts1_3D_</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
        <span class="n">pts2_2D</span> <span class="o">=</span> <span class="n">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts2_3D_</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># map the 3D triangle to 2D triangle coordinates. </span>
        <span class="n">pts1_2D</span> <span class="o">=</span> <span class="n">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
        <span class="n">pts2_2D</span> <span class="o">=</span> <span class="n">map_3D_to_2D_triangles</span><span class="p">(</span><span class="n">pts2_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>

    <span class="c1"># convert 2D coordinates to homogeneous coordinates in order to solve uniquely.</span>
    <span class="c1"># having converted we can now get the jacobian by specifying Y = AX (homogeneous coordinates.)</span>
    <span class="n">pts1_2D_hom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts1_2D</span><span class="p">,</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">pts1_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts1_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pts2_2D_hom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pts2_2D</span><span class="p">,</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">pts2_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts2_2D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pts1_2D_hom</span> <span class="o">=</span> <span class="n">pts1_2D_hom</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">pts2_2D_hom</span> <span class="o">=</span> <span class="n">pts2_2D_hom</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># solve exactly. </span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pts2_2D_hom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">pts1_2D_hom</span><span class="p">))</span> <span class="c1"># this really is just solving registration problem ? </span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pts2_2D_hom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">pts1_2D_hom</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">))</span> <span class="c1"># if fails we need a small eps to stabilise. </span>
    <span class="c1"># Tmatrix = np.matmul(pts2_2D_hom, np.linalg.inv(pts1_2D_hom)) # this really is just solving registration problem ? </span>
    <span class="n">JacMatrix</span> <span class="o">=</span> <span class="n">Tmatrix</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># take the non jacobian component? </span>
    

    <span class="c1"># The error is given as the ratio of the largest to smallest eigenvalue. -&gt; since SVD, hence the singular values are squared. </span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">JacMatrix</span><span class="p">)</span>
    
    <span class="c1"># see http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/13_Parameterization2.pdf to better understand. </span>
    <span class="c1"># Jac_eigvals = s.copy()</span>

    <span class="c1"># stretch_factor is gotten from eigenvalues of J^T J</span>
    <span class="n">JacMatrix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">JacMatrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">JacMatrix</span><span class="p">)</span>
    <span class="n">stretch_eigenvalues</span><span class="p">,</span> <span class="n">stretch_eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">JacMatrix2</span><span class="p">)</span>
    
    <span class="n">sigma1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># this is the ones. </span>
    <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># sigma1 = np.max(np.abs(s), axis=1)</span>
    <span class="c1"># sigma2 = np.min(np.abs(s), axis=1)</span>
    
    <span class="n">MIPS</span> <span class="o">=</span> <span class="n">sigma1</span><span class="o">/</span><span class="n">sigma2</span> <span class="o">+</span> <span class="n">sigma2</span><span class="o">/</span><span class="n">sigma1</span>
    <span class="n">area_MIPS</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma1</span><span class="o">/</span><span class="n">sigma2</span> <span class="o">+</span> <span class="n">sigma2</span><span class="o">/</span><span class="n">sigma1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sigma1</span><span class="o">*</span><span class="n">sigma2</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">sigma1</span><span class="o">*</span><span class="n">sigma2</span><span class="p">))</span><span class="o">**</span><span class="n">area_mips_theta</span>
    <span class="n">MIPS_plus</span> <span class="o">=</span> <span class="n">sigma1</span><span class="o">/</span><span class="n">sigma2</span> <span class="o">+</span> <span class="n">sigma1</span><span class="o">*</span><span class="n">sigma2</span>
    
    <span class="n">areas3D</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">pts1_3D</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">mean_MIPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas3D</span><span class="o">*</span><span class="n">MIPS</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areas3D</span><span class="p">))))</span> <span class="c1"># area weighted average.</span>
    <span class="n">mean_area_MIPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas3D</span><span class="o">*</span><span class="n">area_MIPS</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areas3D</span><span class="p">))))</span> 
    <span class="n">mean_MIPS_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">areas3D</span><span class="o">*</span><span class="n">MIPS_plus</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areas3D</span><span class="p">))))</span> 
    
    <span class="k">return</span> <span class="p">(</span><span class="n">MIPS</span><span class="p">,</span> <span class="n">area_MIPS</span><span class="p">,</span> <span class="n">MIPS_plus</span><span class="p">),</span> <span class="p">(</span><span class="n">mean_MIPS</span><span class="p">,</span> <span class="n">mean_area_MIPS</span><span class="p">,</span> <span class="n">mean_MIPS_plus</span><span class="p">),</span> <span class="p">(</span><span class="n">sigma1</span><span class="p">,</span><span class="n">sigma2</span><span class="p">),</span> <span class="p">(</span><span class="n">stretch_eigenvalues</span><span class="p">,</span> <span class="n">stretch_eigenvectors</span><span class="p">)</span></div>
    
    
    

<span class="c1"># def MIPS_cost(pts1_3D, pts2_3D, triangles):</span>
    
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     use the Most isometric parametrization cost. </span>
<span class="c1">#     https://arxiv.org/pdf/1810.09031.pdf</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     import igl </span>
<span class="c1">#     import numpy as np </span>

<span class="c1">#     # normalize the pts </span>
<span class="c1">#     pts1_3D_ =  pts1_3D / np.sqrt( np.sum(igl.doublearea(pts1_3D, triangles)/2.) )</span>
<span class="c1">#     pts2_3D_ =  pts2_3D / np.sqrt( np.sum(igl.doublearea(pts2_3D, triangles)/2.) )</span>
<span class="c1">#     # pts1_3D_ = pts1_3D.copy()</span>
<span class="c1">#     # pts2_3D_ = pts2_3D.copy()</span>

<span class="c1">#     # map the 3D triangle to 2D triangle coordinates. </span>
<span class="c1">#     [U1,UF1,I1] = igl.project_isometrically_to_plane(pts1_3D_, triangles) # V to U.    </span>
<span class="c1">#     [U2,UF2,I2] = igl.project_isometrically_to_plane(pts2_3D_, triangles)</span>

<span class="c1">#     pts1_2D = U1[UF1]</span>
<span class="c1">#     pts2_2D = U2[UF2]</span>

<span class="c1">#     # convert 2D coordinates to homogeneous coordinates in order to solve uniquely.</span>
<span class="c1">#     # having converted we can now get the jacobian by specifying Y = AX (homogeneous coordinates.)</span>
<span class="c1">#     pts1_2D_hom = np.concatenate([pts1_2D, </span>
<span class="c1">#                                   np.ones((pts1_2D.shape[0], pts1_2D.shape[1]))[...,None]], axis=-1)</span>
<span class="c1">#     pts2_2D_hom = np.concatenate([pts2_2D, </span>
<span class="c1">#                                   np.ones((pts2_2D.shape[0], pts2_2D.shape[1]))[...,None]], axis=-1)</span>
<span class="c1">#     pts1_2D_hom = pts1_2D_hom.transpose(0,2,1).copy()</span>
<span class="c1">#     pts2_2D_hom = pts2_2D_hom.transpose(0,2,1).copy()</span>
    
<span class="c1">#     # solve exactly. </span>
<span class="c1">#     Tmatrix = np.matmul(pts2_2D_hom, np.linalg.inv(pts1_2D_hom)) # this really is just solving registration problem ? </span>
<span class="c1">#     JacMatrix = Tmatrix[:,:2,:2].copy() # take the non jacobian component? </span>
    
<span class="c1">#     # The error is given as the ratio of the largest to smallest eigenvalue. -&gt; since SVD, hence the singular values are squared. </span>
<span class="c1">#     u, s, v = np.linalg.svd(JacMatrix)</span>

<span class="c1">#     Jac_eigvals = s.copy()</span>

<span class="c1">#     # stretch_factor is gotten from eigenvalues of J^T J</span>
<span class="c1">#     JacMatrix2 = np.matmul(JacMatrix.transpose(0,2,1), JacMatrix)</span>
<span class="c1">#     stretch_eigenvalues, stretch_eigenvectors = np.linalg.eigh(JacMatrix2)</span>

<span class="c1">#     print(stretch_eigenvalues.shape)</span>
<span class="c1">#     # sigma1 = np.sqrt(np.max(stretch_eigenvalues, axis=1))</span>
<span class="c1">#     # sigma2 = np.sqrt(np.min(stretch_eigenvalues, axis=1))</span>
<span class="c1">#     sigma1 = np.max(np.abs(s), axis=1)</span>
<span class="c1">#     sigma2 = np.min(np.abs(s), axis=1)</span>

<span class="c1">#     # stretch_factor = np.sqrt(np.max(np.abs(s), axis=1) / np.min(np.abs(s), axis=1)) # since this was SVD decomposition. </span>
<span class="c1">#     stretch_factor = np.sqrt(np.max(np.abs(stretch_eigenvalues), axis=1) / np.min(np.abs(stretch_eigenvalues), axis=1)) # since this was SVD decomposition. </span>

<span class="c1">#     return sigma1/sigma2 + sigma2/sigma1, stretch_factor # this is the MIPS cost... as a balanced cost. </span>
<span class="c1">#     # return sigma1/sigma2 + sigma2*sigma1, stretch_factor</span>
<span class="c1">#     # return sigma1*sigma2 + 1./(sigma2*sigma1), stretch_factor</span>


<span class="c1"># #### functions for mesh-based morphological operations.</span>
<div class="viewcode-block" id="remove_small_mesh_components_binary"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.remove_small_mesh_components_binary">[docs]</a><span class="k">def</span> <span class="nf">remove_small_mesh_components_binary</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span> <span class="n">vertex_labels_bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">physical_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minsize</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span> <span class="c1"># assume by default vertex labels.</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Remove small connected components of a binary labelled mesh. Connected components is run and regions with number of vertices/faces or covering an area less than the specified threshold is removed by returning a new binary label array where they have been set to 0 </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,) array</span>
<span class="sd">        vertices of the triangle mesh </span>
<span class="sd">    f : (n_faces,) array</span>
<span class="sd">        faces of the triangle mesh </span>
<span class="sd">    labels : (n_vertices,) or (n_faces,) array</span>
<span class="sd">        the binary labels either specified for the vertex or face. Which is which is set by the parameter ``vertex_labels_bool``. </span>
<span class="sd">    vertex_labels_bool : bool</span>
<span class="sd">        if True, process the ``labels`` as associated with vertices or if False, process the ``labels`` as associated with faces. </span>
<span class="sd">    physical_size : bool</span>
<span class="sd">        if True, interpret ``minsize`` as the minimum surface area of each connected component. If False, interpret ``minsize`` as the minimum number of vertex/face elements within the connected component</span>
<span class="sd">    minsize : scalar </span>
<span class="sd">        if physical_size=True, the minimum surface area of a connected component or if physical_size=False, the minimum number of vertex/face elements within the connected component</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labels_clean : (n_vertices,) or (n_faces,) array</span>
<span class="sd">        The updated vertex (if vertex_labels_bool=True) or face (if vertex_labels_bool=False) binary label array</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">spstats</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">igl</span>

    <span class="k">if</span> <span class="n">vertex_labels_bool</span><span class="p">:</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">spstats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">face_labels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="n">connected_components_mesh</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> 
                                                             <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">face_labels</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> 
                                                             <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                                             <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                                             <span class="n">original_face_indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="n">face_labels</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">physical_size</span><span class="p">:</span>
        <span class="n">mesh_cc_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">]</span> <span class="c1"># we need to double check this </span>
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_area</span><span class="p">))</span> <span class="k">if</span> <span class="n">mesh_cc_area</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minsize</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">minsize</span><span class="p">]</span> <span class="c1"># just by number of faces.!</span>
    
    <span class="c1"># rebuild the output vertex/face labels</span>
    <span class="n">labels_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertex_labels_bool</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">:</span>
            <span class="n">faces_cc</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> 
            <span class="n">unique_verts_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces_cc</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="n">labels_clean</span><span class="p">[</span><span class="n">unique_verts_cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">:</span>
            <span class="n">labels_clean</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">labels_clean</span></div>


<div class="viewcode-block" id="remove_small_mesh_components_labels"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.remove_small_mesh_components_labels">[docs]</a><span class="k">def</span> <span class="nf">remove_small_mesh_components_labels</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span> 
                                        <span class="n">bg_label</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                        <span class="n">vertex_labels_bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                        <span class="n">physical_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                        <span class="n">minsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                        <span class="n">keep_largest_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1"># assume by default vertex labels.</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Remove small connected components of a multi-labelled integer mesh. Connected components is run on each labelled region and disconnected regions with number of vertices/faces or covering an area less than the specified threshold is removed by returning a new multi label array where they have been set to the specified background label </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,) array</span>
<span class="sd">        vertices of the triangle mesh </span>
<span class="sd">    f : (n_faces,) array</span>
<span class="sd">        faces of the triangle mesh </span>
<span class="sd">    labels : (n_vertices,) or (n_faces,) array</span>
<span class="sd">        the integer labels specified for the vertex or face as determined by the boolean parameter ``vertex_labels_bool``.</span>
<span class="sd">    bg_label : int </span>
<span class="sd">        the integer label of background regions </span>
<span class="sd">    vertex_labels_bool : bool</span>
<span class="sd">        if True, process the ``labels`` as associated with vertices or if False, process the ``labels`` as associated with faces. </span>
<span class="sd">    physical_size : bool</span>
<span class="sd">        if True, interpret ``minsize`` as the minimum surface area of each connected component. If False, interpret ``minsize`` as the minimum number of vertex/face elements within the connected component</span>
<span class="sd">    minsize : scalar </span>
<span class="sd">        if physical_size=True, the minimum surface area of a connected component or if physical_size=False, the minimum number of vertex/face elements within the connected component</span>
<span class="sd">    keep_largest_only : bool </span>
<span class="sd">        if True, keep only the largest connected region per label of size &gt; minsize. if False, all connected regions per label of size &gt; minsize is kept    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labels_clean : (n_vertices,) or (n_faces,) array</span>
<span class="sd">        The updated vertex (if vertex_labels_bool=True) or face (if vertex_labels_bool=False) multi label array</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">spstats</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">igl</span>

    <span class="k">if</span> <span class="n">vertex_labels_bool</span><span class="p">:</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">spstats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">face_labels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># create a vector to stick output to. </span>
    <span class="n">labels_clean</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">face_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">*</span> <span class="n">bg_label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">uniq_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">bg_label</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">uniq_labels</span><span class="p">:</span>
        <span class="c1"># return a binary selector to place the labels. </span>
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="n">connected_components_mesh</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> 
                                                                 <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">face_labels</span><span class="o">==</span><span class="n">lab</span><span class="p">],</span> 
                                                                 <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                                                 <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                                                 <span class="n">original_face_indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="n">face_labels</span><span class="o">==</span><span class="n">lab</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">physical_size</span><span class="p">:</span>
            <span class="n">mesh_cc_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">]</span> <span class="c1"># we need to double check this </span>
            <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_area</span><span class="p">))</span> <span class="k">if</span> <span class="n">mesh_cc_area</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minsize</span><span class="p">]</span>
            <span class="n">mesh_cc_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_area</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_area</span><span class="p">))</span> <span class="k">if</span> <span class="n">mesh_cc_area</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minsize</span><span class="p">]</span> <span class="c1"># also update this. </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">minsize</span><span class="p">]</span> <span class="c1"># just by number of faces.!</span>
            <span class="n">mesh_cc_area</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_area</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">keep_largest_only</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># print(&#39;Region label &#39;, lab, len(mesh_cc_label), len(mesh_cc_area))</span>
                <span class="n">labels_clean</span><span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">mesh_cc_area</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">lab</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">:</span> <span class="c1"># set all of them!. </span>
                <span class="n">labels_clean</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span> 

    <span class="k">if</span> <span class="n">vertex_labels_bool</span><span class="p">:</span>
        <span class="c1"># case to vertex labels </span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                            <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
                            <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vertex_triangle_adj</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">vertex_face_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> 
                                                                   <span class="n">f</span><span class="p">,</span>
                                                                   <span class="n">mesh</span><span class="o">.</span><span class="n">faces_sparse</span><span class="p">)</span>

        <span class="n">vertex_triangle_labels</span> <span class="o">=</span> <span class="n">labels_clean</span><span class="p">[</span><span class="n">vertex_triangle_adj</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span> <span class="c1"># cast to a float</span>
        <span class="n">vertex_triangle_labels</span><span class="p">[</span><span class="n">vertex_triangle_adj</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># cast to nan. </span>
        <span class="n">vertex_triangle_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">spstats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">vertex_triangle_labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span> <span class="c1"># recast to int.</span>
        <span class="n">labels_clean</span> <span class="o">=</span> <span class="n">vertex_triangle_labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">labels_clean</span></div>


<div class="viewcode-block" id="remove_small_mesh_label_holes_binary"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.remove_small_mesh_label_holes_binary">[docs]</a><span class="k">def</span> <span class="nf">remove_small_mesh_label_holes_binary</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">vertex_labels_bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">physical_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minsize</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span> 
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Remove small binary holes i.e. small islands of zeros within a region of 1s in a binary-labelled mesh. Connected components is run on 0&#39;s and regions with number of vertices/faces or covering an area less than the specified threshold is removed by returning a new binary label array where they have been set to 1 </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,) array</span>
<span class="sd">        vertices of the triangle mesh </span>
<span class="sd">    f : (n_faces,) array</span>
<span class="sd">        faces of the triangle mesh </span>
<span class="sd">    labels : (n_vertices,) or (n_faces,) array</span>
<span class="sd">        the binary labels specified for the vertex or face as determined by the boolean parameter ``vertex_labels_bool``.</span>
<span class="sd">    vertex_labels_bool : bool</span>
<span class="sd">        if True, process the ``labels`` as associated with vertices or if False, process the ``labels`` as associated with faces. </span>
<span class="sd">    physical_size : bool</span>
<span class="sd">        if True, interpret ``minsize`` as the minimum surface area of each connected component. If False, interpret ``minsize`` as the minimum number of vertex/face elements within the connected component</span>
<span class="sd">    minsize : scalar </span>
<span class="sd">        if physical_size=True, the minimum surface area of a connected component or if physical_size=False, the minimum number of vertex/face elements within the connected component</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labels_clean : (n_vertices,) or (n_faces,) array</span>
<span class="sd">        The updated vertex (if vertex_labels_bool=True) or face (if vertex_labels_bool=False) binary array</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">spstats</span>
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">igl</span>

    <span class="k">if</span> <span class="n">vertex_labels_bool</span><span class="p">:</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">spstats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">face_labels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="n">connected_components_mesh</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> 
                                                             <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">face_labels</span><span class="o">==</span><span class="mi">0</span><span class="p">],</span> <span class="c1"># note the inverse!</span>
                                                             <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                                             <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                                             <span class="n">original_face_indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="n">face_labels</span><span class="o">==</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">physical_size</span><span class="p">:</span>
        <span class="n">mesh_cc_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">cc</span><span class="p">]))</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">]</span>
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_area</span><span class="p">))</span> <span class="k">if</span> <span class="n">mesh_cc_area</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minsize</span> <span class="ow">and</span> <span class="n">mesh_cc_area</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">minsize</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_cc_label</span><span class="p">[</span><span class="n">cc</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># just by number of faces.!</span>
    
    <span class="c1"># rebuild the output vertex/face labels</span>
    <span class="n">labels_clean</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">labels_clean</span> <span class="o">=</span> <span class="n">labels_clean</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="c1">#copy the previous labels. </span>
    <span class="k">if</span> <span class="n">vertex_labels_bool</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">:</span>
            <span class="n">faces_cc</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> 
            <span class="n">unique_verts_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">faces_cc</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="n">labels_clean</span><span class="p">[</span><span class="n">unique_verts_cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># flip 0 -&gt; 1 </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">:</span>
            <span class="n">labels_clean</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">labels_clean</span></div>


<span class="c1">#### functions for label spreading</span>
<div class="viewcode-block" id="labelspreading_mesh_binary"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.labelspreading_mesh_binary">[docs]</a><span class="k">def</span> <span class="nf">labelspreading_mesh_binary</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">return_proba</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Applies Laplacian &#39;local weighted&#39; smoothing with a default or specified affinity matrix to diffuse vertex-based binary labels on a 3D triangular mesh  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,) array</span>
<span class="sd">        vertices of the triangle mesh </span>
<span class="sd">    f : (n_faces,) array</span>
<span class="sd">        faces of the triangle mesh </span>
<span class="sd">    y : (n_vertices,) array</span>
<span class="sd">        the initial binary labels to diffuse</span>
<span class="sd">    W : (n_vertex, n_vertex) sparse array</span>
<span class="sd">        if specified, the Laplacian-like affinity matrix used to diffuse binary labels. Defaults to the cotan Laplacian matrix </span>
<span class="sd">    niters : int</span>
<span class="sd">        the number of iterations     </span>
<span class="sd">    return_proba : (n_vertices,) </span>
<span class="sd">        if True, return the diffused probability matrix</span>
<span class="sd">    thresh : 0-1 scalar</span>
<span class="sd">        if less than 1, the probability matrix per iteration is binarised by thresholding &gt; thresh. This allows faster diffusion of positive labels, equivalent of an inflation factor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labels_clean : (n_vertices,) array</span>
<span class="sd">        The updated vertex binary label array </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">import</span> <span class="nn">igl</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">W_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W_</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># normalize. </span>
    <span class="c1"># DD = 1./W_.sum(axis=-1)</span>
    <span class="n">sumW_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">W_</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sumW_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sumW_</span><span class="p">)</span>
    <span class="n">DD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sumW_</span><span class="p">))</span>
    <span class="n">DD</span><span class="p">[</span><span class="n">sumW_</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumW_</span><span class="p">[</span><span class="n">sumW_</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">DD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">DD</span><span class="p">)</span> <span class="c1"># avoid infs.</span>
    <span class="n">DD</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">DD</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DD</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">W_</span> <span class="o">=</span> <span class="n">DD</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_</span><span class="p">)</span> <span class="c1"># this is perfect normalization. </span>

    <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">niters</span><span class="p">):</span>
        <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">W_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">init_matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">thresh</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">prob_matrix</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">init_matrix</span> <span class="o">&gt;</span> <span class="n">thresh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prob_matrix</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">return_proba</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">init_matrix</span><span class="p">,</span> <span class="n">prob_matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">init_matrix</span></div>


<div class="viewcode-block" id="labelspreading_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.labelspreading_mesh">[docs]</a><span class="k">def</span> <span class="nf">labelspreading_mesh</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha_prop</span><span class="o">=</span><span class="mf">.1</span><span class="p">,</span> <span class="n">return_proba</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">renorm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">convergence_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Applies Label propagation of [1]_ with a default or specified affinity matrix, W to competitively diffuse vertex-based multi-labels on a 3D triangular mesh. Background labels are assumed to be 0  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,) array</span>
<span class="sd">        vertices of the triangle mesh </span>
<span class="sd">    f : (n_faces,) array</span>
<span class="sd">        faces of the triangle mesh</span>
<span class="sd">    x : (N,) array</span>
<span class="sd">        the vertex indices that have been assigned integer labels &gt; 0 </span>
<span class="sd">    y : (N,) array</span>
<span class="sd">        the matching assumed sequential integer labels from 1 to n_labels of the specified vertex indices in ``x``</span>
<span class="sd">    W : (n_vertex, n_vertex) sparse array</span>
<span class="sd">        if specified, the Laplacian-like affinity matrix used to diffuse binary labels. Defaults to the cotan Laplacian matrix </span>
<span class="sd">    niters : int</span>
<span class="sd">        the number of iterations     </span>
<span class="sd">    alpha_prop : 0-1 scalar</span>
<span class="sd">        clamping factor. A value in (0, 1) that specifies the relative amount that a vertex should adopt the information from its neighbors as opposed to its initial label. alpha=0 means keeping the initial label information; alpha=1 means replacing all initial information.</span>
<span class="sd">    return_proba : (n_vertices,) </span>
<span class="sd">        if True, return the diffused probability matrix</span>
<span class="sd">    renorm : bool</span>
<span class="sd">        if True, at each iteration assign each vertex to the most probable label with probability = 1. </span>
<span class="sd">    convergence_iter : int</span>
<span class="sd">        the number of iterations for which the diffused labels do not change for. After this number of iterations the function will early stop before ``n_iters``, otherwise the propagation occurs for at least ``n_iters``. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z_label : (n_vertices,) array</span>
<span class="sd">        The updated vertex multi label array </span>
<span class="sd">    z : (n_vertices, n_labels+1)</span>
<span class="sd">        The probabilistic vertex multi label assignment where rowsums = 1 </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston, Bernhard Schoelkopf. Learning with local and global consistency (2004)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we do it on vertex. </span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">n_classes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span><span class="n">n_classes</span><span class="p">))</span> <span class="c1"># one hot encode. </span>
    <span class="c1"># print(init_matrix.shape)</span>

    <span class="c1"># this is the prior - labelled. </span>
    <span class="n">base_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">));</span> 
    <span class="n">base_matrix</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="n">base_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">alpha_prop</span><span class="p">)</span><span class="o">*</span><span class="n">base_matrix</span> <span class="c1"># this is the moving average.     </span>
    
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">W_</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W_</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">sumW_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">W_</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sumW_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sumW_</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sumW_</span><span class="p">))</span>
    <span class="n">D</span><span class="p">[</span><span class="n">sumW_</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumW_</span><span class="p">[</span><span class="n">sumW_</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="c1"># avoid infs.</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="n">W_</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">))</span> <span class="c1"># apply the normalization!. </span>
    <span class="c1"># print(W_[0].data)</span>
    <span class="c1"># print(W_[0].data)</span>
    <span class="n">W_</span> <span class="o">=</span> <span class="n">alpha_prop</span> <span class="o">*</span> <span class="n">W_</span>
    <span class="c1"># init_matrix = base_matrix.copy()</span>

    <span class="n">convergence_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_comps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">base_matrix</span><span class="p">)</span>
    <span class="c1"># propagate this version is better diffusion with laplacian matrix. </span>
    <span class="k">for</span> <span class="n">iter_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">niters</span><span class="p">):</span> <span class="c1"># no convergence... </span>
        <span class="c1"># base_matrix should act as a clamp!. why is this getting smaller and smaller?  </span>
        <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">W_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">init_matrix</span><span class="p">)</span> <span class="o">+</span> <span class="n">base_matrix</span> <span class="c1"># this is just moving average # why is this not changing? # we should renormalize... # this is weird. </span>
        <span class="c1"># init_matrix = spsparse.linalg.spsolve(spsparse.identity(base_matrix.shape[0])-W_, init_matrix)</span>
        <span class="c1"># init_matrix = init_matrix/init_matrix.max() # renormalize. </span>
        <span class="c1"># init_matrix = (init_matrix-init_matrix.min())/ (init_matrix.max()-init_matrix.min())</span>

        <span class="c1"># convert to proba</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">init_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="n">z</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Avoid division by 0</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">((</span><span class="n">init_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">z_label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">n_comps2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z_label</span><span class="p">)</span>
        <span class="c1"># print(n_comps2)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_comps2</span> <span class="o">-</span> <span class="n">n_comps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">convergence_count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">convergence_count</span> <span class="o">==</span> <span class="n">convergence_iter</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_comps</span> <span class="o">=</span> <span class="n">n_comps2</span>

        <span class="k">if</span> <span class="n">renorm</span><span class="p">:</span>
            <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># need to renormalize</span>
            <span class="c1"># # print(init_matrix.min(), init_matrix.max())</span>
            <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">init_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">init_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">init_matrix</span><span class="p">)),</span> <span class="n">z_label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">return_proba</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z_label</span><span class="p">,</span> <span class="n">z</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z_label</span> <span class="c1"># this is the new. </span></div>


<span class="c1"># assumes vertex labels</span>
<div class="viewcode-block" id="labelspreading_fill_mesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.labelspreading_fill_mesh">[docs]</a><span class="k">def</span> <span class="nf">labelspreading_fill_mesh</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">f</span><span class="p">,</span> <span class="n">vertex_labels</span><span class="p">,</span> <span class="n">niters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha_prop</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">minsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bg_label</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Applies Constrained Label propagation of [1]_ with the uniform Laplacian matrix to diffuse vertex-based multi-labels on a 3D triangular mesh to infill small non-labelled background areas within the boundary of individual labelled regions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : (n_vertices,) array</span>
<span class="sd">        vertices of the triangle mesh </span>
<span class="sd">    f : (n_faces,) array</span>
<span class="sd">        faces of the triangle mesh</span>
<span class="sd">    vertex_labels : (n_vertices,) array</span>
<span class="sd">        the integer vertex-based multi labels  </span>
<span class="sd">    niters : int</span>
<span class="sd">        the number of iterations of infilling     </span>
<span class="sd">    alpha_prop : 0-1 scalar</span>
<span class="sd">        clamping factor. A value in (0, 1) that specifies the relative amount that a vertex should adopt the information from its neighbors as opposed to its initial label. alpha=0 means keeping the initial label information; alpha=1 means replacing all initial information.</span>
<span class="sd">    minsize : int</span>
<span class="sd">        the minimum size of a labelled region to infill. Small labelled regions are not infilled as they themselves are assumed to be unstable</span>
<span class="sd">    bg_label : int</span>
<span class="sd">        the integer label denoting the background regions  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertex_labels_final : (n_vertices,) array</span>
<span class="sd">        The updated vertex multi label array </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston, Bernhard Schoelkopf. Learning with local and global consistency (2004)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;restricts diffusion to the external boundary by disconnecting the boundary loop. from the rest of the mesh with optional designation of size.  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">spstats</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">),</span> <span class="n">bg_label</span><span class="p">)</span>

    <span class="c1"># precompute the adjacency lists. </span>
    <span class="n">adj_mesh</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># get the master list. </span>
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># transfer vertex to face labels. </span>
    <span class="n">face_labels</span> <span class="o">=</span> <span class="n">spstats</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># this could be more efficient using one hot encoding. to do.  </span>
    <span class="n">face_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">face_labels</span><span class="p">)</span>
    
    <span class="c1"># compute separately for each unique label</span>
    <span class="n">vertex_labels_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">)</span> <span class="o">*</span> <span class="n">bg_label</span> <span class="c1"># initialise all to background label!. </span>

    <span class="k">for</span> <span class="n">unique_lab</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">:</span> 
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="n">connected_components_mesh</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> 
                                                                  <span class="n">faces</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">face_labels</span><span class="o">==</span><span class="n">unique_lab</span><span class="p">],</span> <span class="c1"># connecting only the current lab</span>
                                                                  <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                                                <span class="n">original_face_indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">face_labels</span><span class="p">))[</span><span class="n">face_labels</span><span class="o">==</span><span class="n">unique_lab</span><span class="p">])</span>
        <span class="c1"># only process a component of minsize</span>
        <span class="n">mesh_cc_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">cc</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">minsize</span><span class="p">]</span>
        <span class="n">adj_matrix_label</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        
        <span class="c1"># now we diffuse the labels inside here... ( we need to form the laplacian matrix. )</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">mesh_cc_label</span><span class="p">[:]:</span> 
            <span class="c1"># get the unique verts</span>
            <span class="n">unique_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">cc</span><span class="p">)])</span>
            <span class="n">boundary_verts</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">cc</span><span class="p">)])</span>
            
            <span class="c1">#### for the unique_verts # maybe we can&#39;t diffuse in parallel? </span>
            <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">boundary_verts</span><span class="p">:</span> <span class="c1"># iterate over the boundary only! and disconnect. </span>
                <span class="n">adj_v</span> <span class="o">=</span> <span class="n">adj_mesh</span><span class="p">[</span><span class="n">vv</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">adj_vv</span> <span class="ow">in</span> <span class="n">adj_v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">adj_vv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_verts</span><span class="p">:</span>
                        <span class="n">adj_matrix_label</span><span class="p">[</span><span class="n">vv</span><span class="p">,</span><span class="n">adj_vv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c1"># set to 0 </span>
                        <span class="n">adj_matrix_label</span><span class="p">[</span><span class="n">adj_vv</span><span class="p">,</span><span class="n">vv</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="n">adj_matrix_label</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

        <span class="c1"># produce the propagation matrix. </span>
        <span class="n">Laplacian_adj_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span> <span class="o">-</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">adj_matrix_label</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">,</span><span class="n">l</span><span class="p">)</span>
        <span class="n">Laplacian_adj_matrix</span> <span class="o">=</span> <span class="n">Laplacian_adj_matrix</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            
        <span class="c1"># print(Laplacian_adj_matrix[0].data)</span>
        <span class="c1"># # create the label_indices and labels of unique_lab </span>
        <span class="n">labels_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertex_labels</span><span class="p">))[</span><span class="n">vertex_labels</span><span class="o">==</span><span class="n">unique_lab</span><span class="p">]</span>
        <span class="n">labels_labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_ind</span><span class="p">))</span> <span class="o">*</span> <span class="n">unique_lab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># diffusion has to occur now diffuse...</span>
        <span class="n">prop_label</span> <span class="o">=</span> <span class="n">labelspreading_mesh</span><span class="p">(</span><span class="n">v</span><span class="p">,</span>
                                         <span class="n">f</span><span class="p">,</span> 
                                         <span class="n">x</span><span class="o">=</span><span class="n">labels_ind</span><span class="p">,</span> 
                                         <span class="n">y</span><span class="o">=</span><span class="n">labels_labels</span><span class="p">,</span> 
                                         <span class="n">W</span><span class="o">=</span><span class="n">Laplacian_adj_matrix</span><span class="p">,</span> 
                                         <span class="n">niters</span><span class="o">=</span><span class="n">niters</span><span class="p">,</span> 
                                          <span class="n">alpha_prop</span><span class="o">=</span><span class="n">alpha_prop</span><span class="p">,</span> 
                                         <span class="n">return_proba</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vertex_labels_final</span><span class="p">[</span><span class="n">prop_label</span><span class="o">==</span><span class="n">unique_lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_lab</span>

    <span class="k">return</span> <span class="n">vertex_labels_final</span></div>



<span class="c1"># implementing some measures of discrepancy between two meshes.</span>
<div class="viewcode-block" id="chamfer_distance_point_cloud"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.chamfer_distance_point_cloud">[docs]</a><span class="k">def</span> <span class="nf">chamfer_distance_point_cloud</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the standard L2 chamfer distance (CD) between two points clouds. For each point in each cloud, CD finds the nearest point in the other point set, and finds the mean L2 distance.</span>

<span class="sd">    Given two point clouds, :math:`S_1, S_2`, the chamfer distance is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \text{CD}(S_1,S_2)=\frac{1}{|S_1|}\sum_{x\in S_1} {\min_{y\in S_2} ||x-y||_2} + \frac{1}{|S_2|}\sum_{x\in S_2} {\min_{y\in S_1} ||x-y||_2}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts1 : (n_vertices_1,3) array</span>
<span class="sd">        the vertices of point cloud 1. The number of vertices can be different to that of ``pts2``</span>
<span class="sd">    pts2 : (n_vertices_2,3) array</span>
<span class="sd">        the vertices of point cloud 2. The number of vertices can be different to that of ``pts1``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chamfer_dist : scalar</span>
<span class="sd">        the chamfer distance between the two point clouds</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">point_cloud_utils</span> <span class="k">as</span> <span class="nn">pcu</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">pts1_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">pts2_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">chamfer_dist</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">chamfer_distance</span><span class="p">(</span><span class="n">pts1_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">pts2_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">chamfer_dist</span></div>


<div class="viewcode-block" id="hausdorff_distance_point_cloud"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.hausdorff_distance_point_cloud">[docs]</a><span class="k">def</span> <span class="nf">hausdorff_distance_point_cloud</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;two-sided&#39;</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Hausdorff distance (H) between two points clouds. The Hausdorff distance is the it is the greatest of all the distances from a point in one point cloud to the closest point in the other point cloud.</span>
<span class="sd">    </span>
<span class="sd">    The &#39;two-sided&#39; Hausdorff distance takes the maximum of comparing the 1st point cloud to the 2nd point cloud and the 2nd point cloud to the 1st point cloud</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts1 : (n_vertices_1, 3) array</span>
<span class="sd">        the vertices of point cloud 1. The number of vertices can be different to that of ``pts2``</span>
<span class="sd">    pts2 : (n_vertices_2, 3) array</span>
<span class="sd">        the vertices of point cloud 2. The number of vertices can be different to that of ``pts1``</span>
<span class="sd">    mode : &#39;one-sided&#39; or &#39;two-sided&#39;</span>
<span class="sd">        compute either the one sided with the specified order of pts1 to pts2 or the &#39;two-sided&#39; which compares both orders and returns the maximum </span>
<span class="sd">    return_index : bool</span>
<span class="sd">        if True, return two additional optional outputs that specify the index of a point cloud and the index of its closest neighbor in the other point cloud</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hausdorff_dist : scalar</span>
<span class="sd">        the chamfer distance between the two point clouds</span>
<span class="sd">    id_a : (N,) array</span>
<span class="sd">        the vertex id of the points in pts1 matched with maximum shortest distance to vertex ids ``id_b`` in pts2     </span>
<span class="sd">    id_b : (N,) </span>
<span class="sd">        the vertex id of the points in pts2 matched with maximum shortest distance to vertex ids ``id_b`` in pts1     </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">point_cloud_utils</span> <span class="k">as</span> <span class="nn">pcu</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;one-sided&#39;</span><span class="p">:</span>
        <span class="c1"># Compute one-sided squared Hausdorff distances</span>
        <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
            <span class="n">hausdorff_dist</span><span class="p">,</span> <span class="n">id_a</span><span class="p">,</span> <span class="n">id_b</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">one_sided_hausdorff_distance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hausdorff_dist</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">one_sided_hausdorff_distance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">))</span>
        <span class="c1"># hausdorff_b_to_a = pcu.one_sided_hausdorff_distance(b, a)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;two-sided&#39;</span><span class="p">:</span>
        <span class="c1"># Take a max of the one sided squared distances to get the two sided Hausdorff distance</span>
        <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
            <span class="n">hausdorff_dist</span><span class="p">,</span> <span class="n">id_a</span><span class="p">,</span> <span class="n">id_b</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hausdorff_dist</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hausdorff_dist</span><span class="p">,</span> <span class="n">id_a</span><span class="p">,</span> <span class="n">id_b</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hausdorff_dist</span></div>


<div class="viewcode-block" id="wasserstein_distance_trimesh_trimesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.wasserstein_distance_trimesh_trimesh">[docs]</a><span class="k">def</span> <span class="nf">wasserstein_distance_trimesh_trimesh</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span><span class="n">trimesh2</span><span class="p">,</span><span class="n">n_samples_1</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">n_samples_2</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Wasserstein distance between two triangle meshes using the Sinkhorn approximation and point cloud subsampling</span>
<span class="sd">    </span>
<span class="sd">    The triangle meshes are converted into a weighted point cloud or measure using the normalised triangle area</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trimesh1 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    trimesh2 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    n_samples_1 : int</span>
<span class="sd">        the number of uniformly sampled random vertices from trimesh1</span>
<span class="sd">    n_samples_2 : int </span>
<span class="sd">        the number of uniformly sampled random vertices from trimesh2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sinkhorn_dist : scalar</span>
<span class="sd">        the approximated wasserstein distance between the two meshes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    https://github.com/fwilliams/point-cloud-utils for sinkhorn computation </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use sampling to bring this down. random sampling. </span>
    <span class="c1"># https://www.kernel-operations.io/geomloss/_auto_examples/optimal_transport/plot_interpolation_3D.html#sphx-glr-auto-examples-optimal-transport-plot-interpolation-3d-py</span>
    <span class="c1"># we need to turn the mesh into a measure. i.e. load it with dirac atoms. </span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">point_cloud_utils</span> <span class="k">as</span> <span class="nn">pcu</span>
    
    <span class="n">area1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">area1</span> <span class="o">=</span> <span class="n">area1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area1</span><span class="p">)</span>
    <span class="n">pts1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

    <span class="n">area2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh2</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area2</span><span class="p">)</span> <span class="c1"># so it sums up to 1. </span>
    <span class="n">pts2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

    <span class="c1"># subsample.</span>
    <span class="k">if</span> <span class="n">n_samples_1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">select1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">area1</span><span class="p">),</span> <span class="n">n_samples_1</span><span class="p">)</span>
        <span class="n">area1</span> <span class="o">=</span> <span class="n">area1</span><span class="p">[</span><span class="n">select1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># this is also the weights. </span>
        <span class="c1"># area1 = area1 / float(np.nansum(area1)) # renormalize. to be a measure. </span>
        <span class="n">pts1</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">[</span><span class="n">select1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n_samples_2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">select2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">area2</span><span class="p">),</span> <span class="n">n_samples_2</span><span class="p">)</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="p">[</span><span class="n">select2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># this is also the weights. </span>
        <span class="c1"># area2 = area2 / float(np.nansum(area2)) # renormalize. to be a measure. </span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">pts2</span><span class="p">[</span><span class="n">select2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span><span class="n">pts2</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">sinkhorn</span><span class="p">(</span><span class="n">area1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
                     <span class="n">area2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
                     <span class="n">M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> 
                     <span class="n">max_iters</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>

    <span class="c1"># to get distance we compute the frobenius inner product &lt;M, P&gt;</span>
    <span class="n">sinkhorn_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">P</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sinkhorn_dist</span></div>

<div class="viewcode-block" id="wasserstein_distance_trimesh_uv"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.wasserstein_distance_trimesh_uv">[docs]</a><span class="k">def</span> <span class="nf">wasserstein_distance_trimesh_uv</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span><span class="n">uv2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">uv_to_trimesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_samples_1</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">n_samples_2</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the Wasserstein distance between a triangle 3D mesh and a (u,v) image parameterized 3D mesh using the Sinkhorn approximation and point cloud subsampling</span>
<span class="sd">    </span>
<span class="sd">    The meshes are converted into a weighted point cloud or measure using the normalised areas</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trimesh1 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    uv2 : (U,V,3) array </span>
<span class="sd">        a (u,v) image parameterized 3D surface</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small constant for numerical stability </span>
<span class="sd">    pad : bool</span>
<span class="sd">        if True, uses edge padding to compute the finite differences for evaluating the differential areas of ``uv2``</span>
<span class="sd">    uv_to_trimesh : bool</span>
<span class="sd">        if True, convert the (u,v) image parameterized 3D triangle mesh into a 3D triangle mesh before evaluating the difference. </span>
<span class="sd">    n_samples_1 : int</span>
<span class="sd">        the number of uniformly sampled random vertices from trimesh1</span>
<span class="sd">    n_samples_2 : int </span>
<span class="sd">        the number of uniformly sampled random vertices from trimesh2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sinkhorn_dist : scalar</span>
<span class="sd">        the approximated wasserstein distance between the two meshes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    https://github.com/fwilliams/point-cloud-utils for sinkhorn computation </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># https://www.kernel-operations.io/geomloss/_auto_examples/optimal_transport/plot_interpolation_3D.html#sphx-glr-auto-examples-optimal-transport-plot-interpolation-3d-py</span>
    <span class="c1"># we need to turn the mesh into a measure. i.e. load it with dirac atoms. </span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">point_cloud_utils</span> <span class="k">as</span> <span class="nn">pcu</span>

    <span class="k">if</span> <span class="n">uv_to_trimesh</span><span class="p">:</span>
        <span class="n">uv_vertex_indices_all</span><span class="p">,</span> <span class="n">uv_triangles</span> <span class="o">=</span> <span class="n">get_uv_grid_tri_connectivity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">uv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">uv_pos_3D_v</span> <span class="o">=</span> <span class="n">uv2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)[</span><span class="n">uv_vertex_indices_all</span><span class="p">]</span>
        <span class="n">trimesh2</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">uv_pos_3D_v</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">uv_triangles</span><span class="p">,</span> 
                                    <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># reduces to the triangle case. </span>
        <span class="n">sinkhorn_dist</span> <span class="o">=</span> <span class="n">wasserstein_distance_trimesh_trimesh</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span> <span class="n">trimesh2</span><span class="p">,</span>
                                                            <span class="n">n_samples_1</span><span class="o">=</span><span class="n">n_samples_1</span><span class="p">,</span> 
                                                            <span class="n">n_samples_2</span><span class="o">=</span><span class="n">n_samples_2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">area1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">area1</span> <span class="o">=</span> <span class="n">area1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area1</span><span class="p">)</span>
        <span class="n">pts1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

        <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">uzip</span><span class="o">.</span><span class="n">gradient_uv</span><span class="p">(</span><span class="n">uv2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span> <span class="c1"># might be more accurate to convert ...</span>
        <span class="c1"># area of the original surface.</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dS_du</span><span class="p">,</span> 
                                        <span class="n">dS_dv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># # use the cross product</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area2</span><span class="p">)</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">uv2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">uv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># just make this a point cloud.</span>

        <span class="c1"># print(pts1.shape, area1.shape)</span>
        <span class="c1"># print(pts2.shape, area2.shape)</span>
        <span class="c1"># # subsample.</span>
        <span class="k">if</span> <span class="n">n_samples_1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">select1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">area1</span><span class="p">),</span> <span class="n">n_samples_1</span><span class="p">)</span>
            <span class="n">area1</span> <span class="o">=</span> <span class="n">area1</span><span class="p">[</span><span class="n">select1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># this is also the weights. </span>
            <span class="c1"># area1 = area1 / float(np.nansum(area1)) # renormalize. to be a measure. </span>
            <span class="n">pts1</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">[</span><span class="n">select1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">n_samples_2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">select2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">area2</span><span class="p">),</span> <span class="n">n_samples_2</span><span class="p">)</span>
            <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="p">[</span><span class="n">select2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># this is also the weights. </span>
            <span class="c1"># area2 = area2 / float(np.nansum(area2)) # renormalize. to be a measure. </span>
            <span class="n">pts2</span> <span class="o">=</span> <span class="n">pts2</span><span class="p">[</span><span class="n">select2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">M</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span><span class="n">pts2</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">pcu</span><span class="o">.</span><span class="n">sinkhorn</span><span class="p">(</span><span class="n">area1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
                         <span class="n">area2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
                         <span class="n">M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

        <span class="c1"># to get distance we compute the frobenius inner product &lt;M, P&gt;</span>
        <span class="n">sinkhorn_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">P</span><span class="p">)</span>
        <span class="c1"># print(area1.sum(), area2.sum())</span>

    <span class="k">return</span> <span class="n">sinkhorn_dist</span></div>


<div class="viewcode-block" id="sliced_wasserstein_distance_trimesh_trimesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.sliced_wasserstein_distance_trimesh_trimesh">[docs]</a><span class="k">def</span> <span class="nf">sliced_wasserstein_distance_trimesh_trimesh</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span><span class="n">trimesh2</span><span class="p">,</span>
                                                <span class="n">n_seeds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                <span class="n">n_projections</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                                                <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
                                                <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the sliced Wasserstein distance approximation between two triangle meshes which gives a proxy of the Wasserstein distance using summed 1D random projections. </span>
<span class="sd">    This method is advantageous in terms of speed and computational resources for very large meshes. </span>
<span class="sd">    </span>
<span class="sd">    The triangle meshes are converted into a weighted point cloud or measure using the normalised triangle area</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trimesh1 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    trimesh2 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    n_seeds : int</span>
<span class="sd">        the number of trials to average the distance over. Larger numbers give greater stability </span>
<span class="sd">    n_projections : int </span>
<span class="sd">        the number of 1D sliced random projections to sum over</span>
<span class="sd">    p : int</span>
<span class="sd">        the order of the Wasserstein distance. 1 is equivalent to the Earth Mover&#39;s distance</span>
<span class="sd">    mode : &#39;max&#39; or any other string</span>
<span class="sd">        if mode=&#39;max&#39; compute the maximum sliced wasserstein distance see ``ot.max_sliced_wasserstein_distance`` in the Python Optimal Transport library  </span>
<span class="sd">    seed : int </span>
<span class="sd">        if specified, fix the random seed for reproducibility runs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sliced_W_dist : scalar</span>
<span class="sd">        the mean sliced wasserstein distance between the two meshes over `n_seeds` iterations</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    https://pythonot.github.io/ for sliced wassersten distance computation </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">ot</span>
    
    <span class="n">area1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">area1</span> <span class="o">=</span> <span class="n">area1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area1</span><span class="p">)</span>
    <span class="n">pts1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

    <span class="n">area2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh2</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area2</span><span class="p">)</span> <span class="c1"># so it sums up to 1. </span>
    <span class="n">pts2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

    <span class="c1"># subsample.</span>
    <span class="n">sliced_W_dist_iters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iter_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_seeds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">max_sliced_wasserstein_distance</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> 
                                                           <span class="n">pts2</span><span class="p">,</span> 
                                                           <span class="n">a</span><span class="o">=</span><span class="n">area1</span><span class="p">,</span> 
                                                           <span class="n">b</span><span class="o">=</span><span class="n">area2</span><span class="p">,</span> 
                                                           <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                                           <span class="n">n_projections</span><span class="o">=</span><span class="n">n_projections</span><span class="p">,</span> 
                                                           <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span> <span class="c1"># hm...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">sliced_wasserstein_distance</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> 
                                                           <span class="n">pts2</span><span class="p">,</span> 
                                                           <span class="n">a</span><span class="o">=</span><span class="n">area1</span><span class="p">,</span> 
                                                           <span class="n">b</span><span class="o">=</span><span class="n">area2</span><span class="p">,</span> 
                                                           <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                                           <span class="n">n_projections</span><span class="o">=</span><span class="n">n_projections</span><span class="p">,</span> 
                                                           <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span> <span class="c1"># hm...</span>
        <span class="n">sliced_W_dist_iters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced_W_dist</span><span class="p">)</span>
    <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">sliced_W_dist_iters</span><span class="p">)</span> 

    <span class="k">return</span> <span class="n">sliced_W_dist</span></div>

<div class="viewcode-block" id="sliced_wasserstein_distance_trimesh_uv"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.sliced_wasserstein_distance_trimesh_uv">[docs]</a><span class="k">def</span> <span class="nf">sliced_wasserstein_distance_trimesh_uv</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span> 
                                            <span class="n">uv2</span><span class="p">,</span> 
                                            <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> 
                                            <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                            <span class="n">uv_to_trimesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">n_seeds</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                            <span class="n">n_projections</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                                            <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
                                            <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the sliced Wasserstein distance approximation between a triangle mesh and a (u,v) image parameterized 3D mesh which gives a proxy of the Wasserstein distance using summed 1D random projections. </span>
<span class="sd">    This method is advantageous in terms of speed and computational resources for very large meshes. </span>
<span class="sd">    </span>
<span class="sd">    The triangle meshes are converted into a weighted point cloud or measure using the normalised triangle area</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trimesh1 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    uv2 : (U,V,3) array</span>
<span class="sd">        a (u,v) image parameterized 3D surface</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small constant for numerical stability </span>
<span class="sd">    pad : bool</span>
<span class="sd">        if True, uses edge padding to compute the finite differences for evaluating the differential areas of ``uv2``</span>
<span class="sd">    uv_to_trimesh : bool</span>
<span class="sd">        if True, convert the (u,v) image parameterized 3D triangle mesh into a 3D triangle mesh before evaluating the difference. </span>
<span class="sd">    n_seeds : int</span>
<span class="sd">        the number of trials to average the distance over. Larger numbers give greater stability </span>
<span class="sd">    n_projections : int </span>
<span class="sd">        the number of 1D sliced random projections to sum over</span>
<span class="sd">    p : int</span>
<span class="sd">        the order of the Wasserstein distance. 1 is equivalent to the Earth Mover&#39;s distance</span>
<span class="sd">    mode : &#39;max&#39; or any other string</span>
<span class="sd">        if mode=&#39;max&#39; compute the maximum sliced wasserstein distance see ``ot.max_sliced_wasserstein_distance`` in the Python Optimal Transport library  </span>
<span class="sd">    seed : int </span>
<span class="sd">        if specified, fix the random seed for reproducibility runs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sliced_W_dist : scalar</span>
<span class="sd">        the mean sliced wasserstein distance between the two meshes over `n_seeds` iterations</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    https://pythonot.github.io/ for sliced wassersten distance computation </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>
    <span class="kn">import</span> <span class="nn">ot</span> <span class="c1"># uses the Python POT library for optimal transport. </span>

    <span class="k">if</span> <span class="n">uv_to_trimesh</span><span class="p">:</span>
        <span class="n">uv_vertex_indices_all</span><span class="p">,</span> <span class="n">uv_triangles</span> <span class="o">=</span> <span class="n">get_uv_grid_tri_connectivity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">uv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">uv_pos_3D_v</span> <span class="o">=</span> <span class="n">uv2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)[</span><span class="n">uv_vertex_indices_all</span><span class="p">]</span>
        <span class="n">trimesh2</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">uv_pos_3D_v</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">uv_triangles</span><span class="p">,</span> 
                                    <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">sliced_wasserstein_distance_trimesh_trimesh</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span><span class="n">trimesh2</span><span class="p">,</span>
                                                                    <span class="n">n_seeds</span><span class="o">=</span><span class="n">n_seeds</span><span class="p">,</span>
                                                                    <span class="n">n_projections</span><span class="o">=</span><span class="n">n_projections</span><span class="p">,</span>
                                                                    <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                                                    <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>

        <span class="n">area1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">area1</span> <span class="o">=</span> <span class="n">area1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area1</span><span class="p">)</span>
        <span class="n">pts1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

        <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">uzip</span><span class="o">.</span><span class="n">gradient_uv</span><span class="p">(</span><span class="n">uv2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span> <span class="c1"># might be more accurate to convert ...</span>
        <span class="c1"># area of the original surface.</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dS_du</span><span class="p">,</span> 
                                        <span class="n">dS_dv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># # use the cross product</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area2</span><span class="p">)</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">uv2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">uv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># just make this a point cloud.</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">area2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># print(pts1.shape, pts2.shape)</span>
        <span class="c1"># print(area1.shape, area2.shape)</span>
        <span class="n">sliced_W_dist_iters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iter_ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_seeds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="p">:</span>
                <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">max_sliced_wasserstein_distance</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> 
                                                           <span class="n">pts2</span><span class="p">,</span> 
                                                           <span class="n">a</span><span class="o">=</span><span class="n">area1</span><span class="p">,</span> 
                                                           <span class="n">b</span><span class="o">=</span><span class="n">area2</span><span class="p">,</span> 
                                                           <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                                           <span class="n">n_projections</span><span class="o">=</span><span class="n">n_projections</span><span class="p">,</span> 
                                                           <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span> <span class="c1"># hm...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">sliced_wasserstein_distance</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> 
                                                               <span class="n">pts2</span><span class="p">,</span> 
                                                               <span class="n">a</span><span class="o">=</span><span class="n">area1</span><span class="p">,</span> 
                                                               <span class="n">b</span><span class="o">=</span><span class="n">area2</span><span class="p">,</span> 
                                                               <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                                               <span class="n">n_projections</span><span class="o">=</span><span class="n">n_projections</span><span class="p">,</span> 
                                                               <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span> <span class="c1"># hm...</span>
            <span class="n">sliced_W_dist_iters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced_W_dist</span><span class="p">)</span>
        <span class="n">sliced_W_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">sliced_W_dist_iters</span><span class="p">)</span> 

    <span class="k">return</span> <span class="n">sliced_W_dist</span></div>


<div class="viewcode-block" id="diff_area_trimesh_trimesh"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.diff_area_trimesh_trimesh">[docs]</a><span class="k">def</span> <span class="nf">diff_area_trimesh_trimesh</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span> <span class="n">trimesh2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Difference in total surface area between two triangle meshes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trimesh1 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    trimesh2 : trimesh.Trimesh </span>
<span class="sd">        a 3D triangle mesh</span>

<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    diff_area : scalar</span>
<span class="sd">        the signed difference in the total surface area between mesh 1 and mesh 2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">area1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh2</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

    <span class="n">diff_area</span> <span class="o">=</span> <span class="n">area1</span><span class="o">-</span><span class="n">area2</span>

    <span class="k">return</span> <span class="n">diff_area</span></div>

<div class="viewcode-block" id="diff_area_trimesh_uv"><a class="viewcode-back" href="../../../unwrap3D.Mesh.html#unwrap3D.Mesh.meshtools.diff_area_trimesh_uv">[docs]</a><span class="k">def</span> <span class="nf">diff_area_trimesh_uv</span><span class="p">(</span><span class="n">trimesh1</span><span class="p">,</span> <span class="n">uv2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">uv_to_trimesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Difference in total surface area between a triangle mesh and a (u,v) image parameterized 3D mesh </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trimesh1 : trimesh.Trimesh</span>
<span class="sd">        a 3D triangle mesh</span>
<span class="sd">    uv2 : (U,V,3) array</span>
<span class="sd">        a (u,v) image parameterized 3D surface</span>
<span class="sd">    eps : scalar</span>
<span class="sd">        a small constant for numerical stability </span>
<span class="sd">    pad : bool</span>
<span class="sd">        if True, uses edge padding to compute the finite differences for evaluating the differential areas of ``uv2``</span>
<span class="sd">    uv_to_trimesh : bool</span>
<span class="sd">        if True, convert the (u,v) image parameterized 3D triangle mesh into a 3D triangle mesh before evaluating the difference. </span>
<span class="sd">        </span>
<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    diff_area : scalar</span>
<span class="sd">        the signed difference in the total surface area between the triangle mesh and the (u,v) parameterized mesh </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">igl</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">trimesh</span>

    <span class="n">area1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh1</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh1</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">uv_to_trimesh</span><span class="p">:</span>
        <span class="n">uv_vertex_indices_all</span><span class="p">,</span> <span class="n">uv_triangles</span> <span class="o">=</span> <span class="n">get_uv_grid_tri_connectivity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">uv2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span> <span class="c1"># oh... this is only valid uv unwrap not topography!. -&gt; double check the ushape3D error analyses!. </span>
        <span class="n">uv_pos_3D_v</span> <span class="o">=</span> <span class="n">uv2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)[</span><span class="n">uv_vertex_indices_all</span><span class="p">]</span>
        <span class="n">trimesh2</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">uv_pos_3D_v</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="n">uv_triangles</span><span class="p">,</span> 
                                    <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">trimesh2</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">trimesh2</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dS_du</span><span class="p">,</span> <span class="n">dS_dv</span> <span class="o">=</span> <span class="n">uzip</span><span class="o">.</span><span class="n">gradient_uv</span><span class="p">(</span><span class="n">uv2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span> <span class="c1"># might be more accurate to convert ...</span>
        <span class="c1"># area of the original surface.</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dS_du</span><span class="p">,</span> 
                                        <span class="n">dS_dv</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="c1"># # use the cross product</span>
        <span class="n">area2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">area2</span><span class="p">)</span>

    <span class="c1"># difference in area. </span>
    <span class="n">diff_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">area1</span><span class="o">-</span><span class="n">area2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">diff_area</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Y. Zhou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>