<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>unwrap3D.Analysis_Functions.topography &mdash; u-Unwrap3D 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> u-Unwrap3D
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">u-Unwrap3D</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>unwrap3D.Analysis_Functions.topography</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for unwrap3D.Analysis_Functions.topography</h1><div class="highlight"><pre>
<span></span>
<span class="kn">from</span> <span class="nn">..Mesh</span> <span class="kn">import</span> <span class="n">meshtools</span> <span class="k">as</span> <span class="n">meshtools</span>
<span class="kn">from</span> <span class="nn">..Segmentation</span> <span class="kn">import</span> <span class="n">segmentation</span> <span class="k">as</span> <span class="n">segmentation</span>
<span class="kn">from</span> <span class="nn">..Unzipping</span> <span class="kn">import</span> <span class="n">unzip</span> <span class="k">as</span> <span class="n">uzip</span> 
<span class="kn">from</span> <span class="nn">..Image_Functions</span> <span class="kn">import</span> <span class="n">image</span> <span class="k">as</span> <span class="n">image_fn</span>


<div class="viewcode-block" id="uv_depth_pts3D_to_xyz_pts3D"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.uv_depth_pts3D_to_xyz_pts3D">[docs]</a><span class="k">def</span> <span class="nf">uv_depth_pts3D_to_xyz_pts3D</span><span class="p">(</span> <span class="n">uv_pts3D</span><span class="p">,</span> <span class="n">uv_depth_params</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Linear Interpolation of the corresponding (x,y,z) coordinates given query (d,u,v) topography coordinates where the injective map (d,u,v) -&gt; (x,y,z) is given by uv_depth_params.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uv_pts3D : (Nx3) array</span>
<span class="sd">        the topography, (d,u,v) coordinate at N positions for which original (x,y,z) coordinates is desired </span>
<span class="sd">    uv_depth_params : (D,U,V,3) array</span>
<span class="sd">        the lookup table mapping the uniform (D,U,V) grid to (x,y,z) in original shape space </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xyz_pts3D : (Nx3) array</span>
<span class="sd">        The corresponding (x,y,z) coordinates into the space indexed by uv_depth_params.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 

    <span class="n">uv_pts3D_</span> <span class="o">=</span> <span class="n">uv_pts3D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">uv_pts3D_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">uv_pts3D</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uv_depth_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uv_pts3D_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">uv_pts3D</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uv_depth_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">uv_pts3D_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">uv_pts3D</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uv_depth_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">xyz_pts3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">image_fn</span><span class="o">.</span><span class="n">map_intensity_interp3</span><span class="p">(</span><span class="n">uv_pts3D_</span><span class="p">,</span> 
                                                    <span class="n">grid_shape</span><span class="o">=</span><span class="n">uv_depth_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                                    <span class="n">I_ref</span><span class="o">=</span><span class="n">uv_depth_params</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ch</span><span class="p">])</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">uv_depth_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
    <span class="n">xyz_pts3D</span> <span class="o">=</span> <span class="n">xyz_pts3D</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">xyz_pts3D</span></div>

<div class="viewcode-block" id="estimate_base_topography_uv_img"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.estimate_base_topography_uv_img">[docs]</a><span class="k">def</span> <span class="nf">estimate_base_topography_uv_img</span><span class="p">(</span><span class="n">depth_binary</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a binary in topography space, this function attempts to derive a 1-to-1 height map of the basal surface by projecting straight lines in d at every (u,v) pixel position to find contiguous stretches of intracellular space. The basal surface is given by the highest d in the longest stretch of each (u,v) position </span>
<span class="sd">    The resulting height map is intended to be used for downstream processing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    depth_binary : (DxUxV) array</span>
<span class="sd">        a binary volume in topography space where 1 indicates intracellular space and 0 is background ( extracellular ) </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    heigh_func : (UxV) array</span>
<span class="sd">        a grayscale image with intensity = to the height coordinate in d i.e. we express height as a function of (u,v) position, height = f(u,v) </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">depth_binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">heigh_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">YY</span><span class="p">,</span><span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">)[:]:</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)[:]:</span>
            <span class="c1"># iterate over this and parse the column the longest contig. </span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">depth_binary</span><span class="p">[:,</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))[</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># convert to index. </span>
            
            <span class="c1"># break into contigs</span>
            <span class="n">contigs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># contigs_nearest_mesh_distance = []</span>
            <span class="n">contig</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">jjj</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">)):</span> <span class="c1"># iterate over the sequence. </span>
                <span class="k">if</span> <span class="n">jjj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">contig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">jjj</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="n">valid</span><span class="p">[</span><span class="n">jjj</span><span class="p">]</span> <span class="o">-</span> <span class="n">contig</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">contig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">jjj</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># we should wrap this up. in a function now. </span>
                            <span class="c1"># finish a contig. </span>
                            <span class="c1"># print(contig)</span>
                            <span class="n">contigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>
                            <span class="c1"># query_contig_pt = np.hstack([contig[-1], ii, jj])</span>
                            <span class="c1"># print(query_contig_pt)</span>
                            <span class="c1"># query_contig_pt_distance = np.min(np.linalg.norm(topography_mesh_pts-query_contig_pt[None,:], axis=-1))</span>
                            <span class="c1"># contigs_nearest_mesh_distance.append(query_contig_pt_distance)</span>
                            <span class="n">contig</span><span class="o">=</span><span class="p">[</span><span class="n">valid</span><span class="p">[</span><span class="n">jjj</span><span class="p">]]</span> <span class="c1"># start a new one. </span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">contig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">jjj</span><span class="p">])</span> <span class="c1"># extend cuyrrent. </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">contigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span>
                <span class="c1"># query_contig_pt = np.hstack([contig[-1], ii, jj])</span>
                <span class="c1"># query_contig_pt_distance = np.min(np.linalg.norm(topography_mesh_pts-query_contig_pt[None,:], axis=-1))</span>
                <span class="c1"># contigs_nearest_mesh_distance.append(query_contig_pt_distance)</span>
                <span class="n">contig</span> <span class="o">=</span> <span class="p">[]</span>
    

            <span class="c1"># filter by distance then take the maximum!. </span>
            <span class="c1"># contigs = [contigs[kkk] for kkk in np.arange(len(contigs)) if contigs_nearest_mesh_distance[kkk]&lt;10.] # within a minimum threshold. </span>
            <span class="n">max_contig</span> <span class="o">=</span> <span class="n">contigs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">contigs</span><span class="p">])]</span> <span class="c1"># we assume we take the longest contig. </span>
            <span class="n">heigh_func</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_contig</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">heigh_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">heigh_func</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">XX</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">heigh_func</span></div>
    

<div class="viewcode-block" id="penalized_smooth_topography_uv_img"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.penalized_smooth_topography_uv_img">[docs]</a><span class="k">def</span> <span class="nf">penalized_smooth_topography_uv_img</span><span class="p">(</span><span class="n">height_func</span><span class="p">,</span> 
                                        <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
                                        <span class="n">padding_multiplier</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ALS&#39;</span><span class="p">,</span> 
                                        <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">p</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> 
                                        <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                        <span class="n">uv_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Applies extended 2D asymmetric least squares regression to smooth a topography surface given as a height image, that is where the surface has been parameetrized 1-to-1 with (u,v), :math:`d=f(u,v)` </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    height_func : (UxV) array</span>
<span class="sd">        an input topography surface given as a height image such that d=f(u,v)</span>
<span class="sd">    ds : int</span>
<span class="sd">        isotropic downsampling factor of the original image, used for imposing additional smoothness + computational efficiency  </span>
<span class="sd">    padding_multiplier : scalar</span>
<span class="sd">        this specifies the padding size as a scalar multiple, 1/padding_multiplier of the downsampled image. It is used to soft enforce spherical bounds. </span>
<span class="sd">    method : str</span>
<span class="sd">        one of </span>

<span class="sd">        &#39;ALS&#39; : str</span>
<span class="sd">            Basic asymmetric least squares algorithm, see :func:`unwrap3D.Analysis_Functions.topography.baseline_als_Laplacian`   </span>
<span class="sd">        &#39;airPLS&#39; : str</span>
<span class="sd">            adaptive iteratively reweighted Penalized Least Squares algorithm, see :func:`unwrap3D.Analysis_Functions.topography.baseline_airPLS2D` </span>
<span class="sd">    lam : scalar</span>
<span class="sd">        Controls the degree of smoothness in the baseline</span>
<span class="sd">    p : scalar</span>
<span class="sd">        Controls the degree of asymmetry in the weighting. p=0.5 is the same as smoothness regularized least mean squares.</span>
<span class="sd">    niter : int</span>
<span class="sd">        The number of iterations to run the algorithm. Only a few iterations is required generally. </span>
<span class="sd">    uv_params : (DxUxV,3) array</span>
<span class="sd">        the lookup table mapping the uniform (D,U,V) grid to (x,y,z) in original shape space. If provided the smoothness regularization will take into account the metric distortion. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (UxV) array</span>
<span class="sd">        a smoothened output topography surface given as a height image such that d=f(u,v)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">skimage.transform</span> <span class="k">as</span> <span class="nn">sktform</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">sklearn.feature_extraction.image</span> <span class="kn">import</span> <span class="n">grid_to_graph</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>

    <span class="n">output_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">height_func</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">height_binary_ds</span> <span class="o">=</span> <span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">height_func</span><span class="p">,</span> 
                                      <span class="n">output_shape</span><span class="o">=</span><span class="p">(</span><span class="n">output_shape</span><span class="o">//</span><span class="n">ds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> 
                                      <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> 
    <span class="c1"># this will be used to rescale. </span>
    <span class="n">height_binary_ds_max</span> <span class="o">=</span> <span class="n">height_binary_ds</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">height_binary_ds</span> <span class="o">=</span> <span class="n">height_binary_ds</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">height_binary_ds_max</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">uv_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">uv_params_ds</span> <span class="o">=</span> <span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">uv_params</span><span class="p">,</span> 
                                      <span class="n">output_shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([(</span><span class="n">output_shape</span><span class="o">//</span><span class="n">ds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">uv_params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span> 
                                      <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span> 
    
    <span class="c1"># use padding to help regularize. </span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">height_binary_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="n">padding_multiplier</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># this is just to make it odd!. </span>

    <span class="c1"># circular padding!. </span>
    <span class="n">height_binary_ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">height_binary_ds</span><span class="p">[:,</span><span class="o">-</span><span class="n">padding</span><span class="p">:],</span> 
                                  <span class="n">height_binary_ds</span><span class="p">,</span>
                                  <span class="n">height_binary_ds</span><span class="p">[:,:</span><span class="n">padding</span><span class="p">]])</span>
    <span class="n">height_binary_ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">padding</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span>
                                  <span class="n">height_binary_ds</span><span class="p">,</span> 
                                  <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">padding</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)])</span>
    
    <span class="k">if</span> <span class="n">uv_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">uv_params_ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">uv_params_ds</span><span class="p">[:,</span><span class="o">-</span><span class="n">padding</span><span class="p">:],</span> 
                                  <span class="n">uv_params_ds</span><span class="p">,</span>
                                  <span class="n">uv_params_ds</span><span class="p">[:,:</span><span class="n">padding</span><span class="p">]])</span>
        <span class="n">uv_params_ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">uv_params_ds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">padding</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span>
                                      <span class="n">uv_params_ds</span><span class="p">,</span> 
                                      <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">uv_params_ds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">padding</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)])</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    build a graph to use the laplacian - this assumes equal weights. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">uv_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># build the equal weight Laplacian matrix. </span>
        <span class="n">img_graph</span> <span class="o">=</span> <span class="n">grid_to_graph</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">height_binary_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">img_graph</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">img_graph</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_graph</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="o">-</span> <span class="n">img_graph</span> <span class="c1"># degree - adjacency matrix. </span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># build the weighted Laplacian matrix using the inverse edge length weights. </span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">get_inverse_distance_weight_grid_laplacian</span><span class="p">(</span><span class="n">uv_params_ds</span><span class="p">,</span> <span class="n">grid_pts</span><span class="o">=</span><span class="n">uv_params_ds</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ALS&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">baseline_als_Laplacian</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">L</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span> <span class="c1"># because there was an issue  # seems like the best thing would be to do some smooth estimated fitting through...!</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">padding</span><span class="p">:</span><span class="o">-</span><span class="n">padding</span><span class="p">,</span><span class="n">padding</span><span class="p">:</span><span class="o">-</span><span class="n">padding</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">height_func</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">height_binary_ds_max</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;airPLS&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">baseline_airPLS2D</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">L</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">height_binary_ds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">padding</span><span class="p">:</span><span class="o">-</span><span class="n">padding</span><span class="p">,</span><span class="n">padding</span><span class="p">:</span><span class="o">-</span><span class="n">padding</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">sktform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">height_func</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">height_binary_ds_max</span>

    <span class="k">return</span> <span class="n">out</span> </div>


<div class="viewcode-block" id="baseline_als_Laplacian"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.baseline_als_Laplacian">[docs]</a><span class="k">def</span> <span class="nf">baseline_als_Laplacian</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Estimates a 1D baseline signal :math:`z=g(x_1,x_2,...,x_n)` to a 1D input signal :math:`y=f(x_1,x_2,...,x_n)` parametrized by :math:`n` dimensions  using asymmetric least squares. It can also be used for generic applications where a multidimensional image requires smoothing.</span>
<span class="sd">    Specifically the baseline signal, :math:`z` is the solution to the following optimization problem </span>

<span class="sd">    .. math::</span>
<span class="sd">        z = arg\,min_z \{w(y-z)^2 + \lambda\sum(\Delta z)^2\}</span>

<span class="sd">    where :math:`y` is the input signal, :math:`\Delta z` is the 2nd derivative or Laplacian operator, :math:`\lambda` is the smoothing regularizer and :math:`w` is an asymmetric weighting</span>

<span class="sd">    .. math::</span>
<span class="sd">        w_i = </span>
<span class="sd">        \Biggl \lbrace </span>
<span class="sd">        { </span>
<span class="sd">        p ,\text{ if } </span>
<span class="sd">          {y_i&gt;z_i}</span>
<span class="sd">        \atop </span>
<span class="sd">        1-p, \text{ otherwise } </span>
<span class="sd">        }</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : 1D signal </span>
<span class="sd">        The 1D signal to estimate a baseline signal. </span>
<span class="sd">    D :  (NxN) sparse Laplacian matrix </span>
<span class="sd">        the Laplacian matrix for the signal which captures the multidimensional structure of the signal e.g. the grid graph for a 2D or 3D image or the cotangent laplacian for a mesh. </span>
<span class="sd">    lam : scalar</span>
<span class="sd">        Controls the degree of smoothness in the baseline</span>
<span class="sd">    p :  scalar</span>
<span class="sd">        Controls the degree of asymmetry in the weighting. p=0.5 is the same as smoothness regularized least mean squares.</span>
<span class="sd">    niter: int</span>
<span class="sd">        The number of iterations to run the algorithm. Only a few iterations is required generally. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : 1D numpy array</span>
<span class="sd">        the estimated 1D baseline signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="c1"># D = sparse.csc_matrix(np.diff(np.eye(L), 2))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="baseline_airPLS2D"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.baseline_airPLS2D">[docs]</a><span class="k">def</span> <span class="nf">baseline_airPLS2D</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Estimates a 1D baseline signal :math:`z=g(x_1,x_2,...,x_n)` to a 1D input signal :math:`y=f(x_1,x_2,...,x_n)` parametrized by :math:`n` dimensions  using Adaptive iteratively reweighted penalized least squares for baseline fitting. It can also be used for generic applications where a multidimensional image requires smoothing.</span>
<span class="sd">    Specifically the baseline signal, :math:`z` is the solution to the following optimization problem </span>

<span class="sd">    .. math::</span>
<span class="sd">        z = arg\,min_z \{w(y-z)^2 + \lambda\sum(\Delta z)^2\}</span>

<span class="sd">    where :math:`y` is the input signal, :math:`\Delta z` is the 2nd derivative or Laplacian operator, :math:`\lambda` is the smoothing regularizer and :math:`w` is an asymmetric weighting</span>

<span class="sd">    .. math::</span>
<span class="sd">        w_i = </span>
<span class="sd">        \Biggl \lbrace </span>
<span class="sd">        { </span>
<span class="sd">        0 ,\text{ if } </span>
<span class="sd">          {y_i\ge z_i}</span>
<span class="sd">        \atop </span>
<span class="sd">        e^{t(y_i-z_i)/|\textbf{d}|}, \text{ otherwise } </span>
<span class="sd">        }</span>

<span class="sd">    where the vector :math:`\textbf{d}` consists of negative elements of the subtraction, :math:`y - z` and :math:`t` is the iteration number. </span>
<span class="sd">    </span>
<span class="sd">    Instead of constant weights in airPLS, the weight :math:`w` is adaptively weighted for faster convergence. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : 1D signal </span>
<span class="sd">        The 1D signal to estimate a baseline signal. </span>
<span class="sd">    D :  (NxN) sparse Laplacian matrix </span>
<span class="sd">        the Laplacian matrix for the signal which captures the multidimensional structure of the signal e.g. the grid graph for a 2D or 3D image or the cotangent laplacian for a mesh. </span>
<span class="sd">    lam : scalar</span>
<span class="sd">        Controls the degree of smoothness in the baseline</span>
<span class="sd">    p :  scalar</span>
<span class="sd">        Controls the degree of asymmetry in the weighting. p=0.5 is the same as smoothness regularized least mean squares.</span>
<span class="sd">    niter: int</span>
<span class="sd">        The number of iterations to run the algorithm. Only a few iterations is required generally. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : 1D numpy array</span>
<span class="sd">        the estimated 1D baseline signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">spsparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">diags</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="c1"># equal weights initially </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">niter</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">spsparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="n">d</span><span class="o">=</span><span class="n">y</span><span class="o">-</span><span class="n">z</span> <span class="c1"># difference between original and the estimated baseline</span>
        <span class="c1"># w = p * (y &gt; z) + (1-p) * (y &lt; z) update in the original </span>
        <span class="n">dssn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dssn</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="ow">or</span> <span class="n">i</span><span class="o">==</span><span class="n">niter</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">niter</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARING max iteration reached!&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">w</span><span class="p">[</span><span class="n">d</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># d&gt;0 means that this point is part of a peak, so its weight is set to 0 in order to ignore it</span>
        <span class="n">w</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">dssn</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="n">dssn</span><span class="p">)</span> 
        <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="segment_topography_vol_curvature_surface"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.segment_topography_vol_curvature_surface">[docs]</a><span class="k">def</span> <span class="nf">segment_topography_vol_curvature_surface</span><span class="p">(</span><span class="n">vol_curvature</span><span class="p">,</span> 
                                             <span class="n">vol_binary_mask</span><span class="p">,</span>
                                             <span class="n">depth_ksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="n">smooth_curvature_sigma</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                             <span class="n">seg_method</span><span class="o">=</span><span class="s1">&#39;kmeans&#39;</span><span class="p">,</span>
                                             <span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                                             <span class="n">n_classes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                             <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                             <span class="n">scale_feats</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Segment protrusions on the unwrapped topography using multiscale mean curvature features. </span>

<span class="sd">    The multiscale comes from extracting the `mean curvature &lt;https://en.wikipedia.org/wiki/Mean_curvature&gt;`_, :math:`H` computed as the divergence of the normalised gradient vectors of the signed distance function, :math:`\Phi`</span>

<span class="sd">    .. math::</span>
<span class="sd">        H = -\frac{1}{2}\nabla\cdot\left( \frac{\nabla \Phi}{|\nabla \Phi|}\right)</span>
<span class="sd">    </span>
<span class="sd">    and creating a multi-feature vector concatenating the smoothed :math:`H` after Gaussian smoothing with different :math:`\sigma` as specified by smooth_curvature_sigma  </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vol_curvature : (MxNxL) numpy array</span>
<span class="sd">        the curvature computed using the definition above using the normalised gradient vector of the signed distance transform of the binary volume </span>
<span class="sd">    vol_binary_mask : (MxNxL) numpy array</span>
<span class="sd">        the topography binary volume from which the vol_curvature was determined form </span>
<span class="sd">    depth_ksize :  scalar</span>
<span class="sd">        the width of a ball morphological operator for extracting a binary mask of a thin shell of thickness 2 x depth_ksize capturing the topographic volume surface to be segmented. </span>
<span class="sd">    smooth_curvature_sigma: list of scalars</span>
<span class="sd">        The list of N :math:`\sigma`&#39;s which the vol_curvature is smoothed with to generate a N-vector :math:`[H_{\sigma_1},H_{\sigma_2}\cdots H_{\sigma_N}]` to describe the local surface topography of a voxel  </span>
<span class="sd">    seg_method : str</span>
<span class="sd">        one of two clustering methods</span>

<span class="sd">        kmeans : </span>
<span class="sd">            `K-Means &lt;https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html&gt;`_ clustering algorithm</span>
<span class="sd">        gmm : </span>
<span class="sd">            `Gaussian mixture model &lt;https://scikit-learn.org/stable/modules/generated/sklearn.mixture.GaussianMixture.html#sklearn.mixture.GaussianMixture&gt;`_ algorithm with full covariances </span>
<span class="sd">    n_samples : int</span>
<span class="sd">        the number of random sampled point to fit clustering on for computational efficiency</span>
<span class="sd">    n_classes :int </span>
<span class="sd">        the number of clusters desired</span>
<span class="sd">    random_state : int</span>
<span class="sd">        a number to fix the random seed for reproducible clustering. </span>
<span class="sd">    scale_feats : bool</span>
<span class="sd">        if set, the features are standard scaled prior to clustering. For mean curvature feats we find setting this seemed to make the clustering worse. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    depth_binary_mask, H_binary_depth_clusters : (MxNxL), (MxNxL) numpy array</span>

<span class="sd">        depth_binary_mask : (MxNxL) numpy array</span>
<span class="sd">            Binary mask of a shell of the topographic surface </span>
<span class="sd">        H_binary_depth_clusters : (MxNxL) numpy array</span>
<span class="sd">            Integer array where background is 0 and, integers refer to the different clusters and arranged such that they reflect increasing mean curvature. </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    
    <span class="c1"># curvature only makes sense relative to a binary surface. </span>
    <span class="n">depth_binary_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">skmorph</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">vol_binary_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">depth_ksize</span><span class="p">)),</span> 
                                       <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">skmorph</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">vol_binary_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">depth_ksize</span><span class="p">))))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">smooth_curvature_sigma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vol_curvature_smooth</span> <span class="o">=</span> <span class="n">depth_binary_mask</span><span class="o">*</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">vol_curvature</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth_curvature_sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">vol_height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vol_curvature_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">vol_curvature_smooth</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> 
                                                   <span class="n">vol_height</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vol_curvature_smooth</span> <span class="o">=</span> <span class="n">vol_curvature_smooth</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="c1"># augment. </span>
        <span class="c1"># if seg_method == &#39;kmeans&#39;:</span>
        <span class="c1">#     H_binary_depth_all_clusters = segmentation.multi_level_kmeans_thresh((vol_curvature_smooth[depth_binary_mask&gt;0])[None,None,:,None],</span>
        <span class="c1">#                                                                        n_classes=n_classes, n_samples=n_samples, random_state=random_state, scale=scale_feats)</span>
        <span class="c1"># if seg_method == &#39;gmm&#39;:</span>
        <span class="c1">#     H_binary_depth_all_clusters = segmentation.multi_level_gaussian_thresh((vol_curvature_smooth[depth_binary_mask&gt;0])[None,None,:,None],</span>
        <span class="c1">#                                                                        n_classes=n_classes, n_samples=n_samples, random_state=random_state, scale=scale_feats)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vol_curvature_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">depth_binary_mask</span><span class="o">*</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">vol_curvature</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">smooth_curvature_sigma</span><span class="p">])</span>
        <span class="n">vol_curvature_smooth</span> <span class="o">=</span> <span class="n">vol_curvature_smooth</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># put this in the last dimension!. </span>
    
        <span class="k">if</span> <span class="n">vol_height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vol_curvature_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">vol_curvature_smooth</span><span class="p">,</span> <span class="n">vol_height</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">seg_method</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
        <span class="n">H_binary_depth_all_clusters</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">multi_level_kmeans_thresh</span><span class="p">((</span><span class="n">vol_curvature_smooth</span><span class="p">[</span><span class="n">depth_binary_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:,:],</span>
                                                                           <span class="n">n_classes</span><span class="o">=</span><span class="n">n_classes</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale_feats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">seg_method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
        <span class="n">H_binary_depth_all_clusters</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">multi_level_gaussian_thresh</span><span class="p">((</span><span class="n">vol_curvature_smooth</span><span class="p">[</span><span class="n">depth_binary_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:,:],</span>
                                                                           <span class="n">n_classes</span><span class="o">=</span><span class="n">n_classes</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale_feats</span><span class="p">)</span>
    <span class="c1"># put these back into the volume!</span>
    <span class="n">H_binary_depth_all_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">H_binary_depth_all_clusters</span><span class="p">)</span>

    <span class="c1"># relabel the cluster labels in increasing curvature. </span>
    <span class="n">mean_curvature_cls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">((</span><span class="n">vol_curvature_smooth</span><span class="p">[</span><span class="n">depth_binary_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])[</span><span class="n">H_binary_depth_all_clusters</span><span class="o">==</span><span class="n">lab</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">H_binary_depth_all_clusters</span><span class="p">)])</span>
    <span class="c1"># conduct relabelling in the order of mean_curvature_cls.</span>
    <span class="n">new_cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">mean_curvature_cls</span><span class="p">)</span> 

    <span class="n">H_binary_depth_all_clusters_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">H_binary_depth_all_clusters</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">new_lab</span><span class="p">,</span> <span class="n">old_lab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_cluster_labels</span><span class="p">):</span>
        <span class="n">H_binary_depth_all_clusters_</span><span class="p">[</span><span class="n">H_binary_depth_all_clusters</span><span class="o">==</span><span class="n">old_lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lab</span>
    <span class="n">H_binary_depth_all_clusters</span> <span class="o">=</span> <span class="n">H_binary_depth_all_clusters_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">H_binary_depth_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vol_curvature</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="c1"># use int!. </span>
    <span class="n">H_binary_depth_clusters</span><span class="p">[</span><span class="n">depth_binary_mask</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_binary_depth_all_clusters</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># add 1 as these curvature clusters are not background!. </span>
    
    <span class="k">return</span> <span class="n">depth_binary_mask</span><span class="p">,</span> <span class="n">H_binary_depth_clusters</span></div>
    
    
<div class="viewcode-block" id="remove_topography_segment_objects_binary"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.remove_topography_segment_objects_binary">[docs]</a><span class="k">def</span> <span class="nf">remove_topography_segment_objects_binary</span><span class="p">(</span> <span class="n">vol_clusters</span><span class="p">,</span> <span class="n">minsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">uv_params_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Removes small connected components in the binary image input either by the number of voxels or if provided the mapping to the original space, on the apparent number of voxels after geometric correction.    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vol_clusters : (D,U,V) array</span>
<span class="sd">        a binary volume</span>
<span class="sd">    minsize : scalar</span>
<span class="sd">        the minimum size, any connected components less than this is removed</span>
<span class="sd">    uv_params_depth :  (D,U,V,3) array</span>
<span class="sd">        the lookup table mapping the uniform (D,U,V) grid to (x,y,z) in original shape space, if provided the minsize is computed for (x,y,z) space not the current (d,u,v) space </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vol_clusters_new : (D,U,V) array</span>
<span class="sd">        a binary volume where size of connected components with &gt; minsize removed. </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="k">as</span> <span class="nn">skmeasure</span>
    
    <span class="n">vol_clusters_new</span> <span class="o">=</span> <span class="n">vol_clusters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vol_clusters_label</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">vol_clusters</span><span class="p">)</span> <span class="c1"># run connected component analysis </span>
    
    <span class="c1"># measure the properties </span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">skmeasure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">vol_clusters_label</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">uv_params_depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">props_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">re</span> <span class="ow">in</span> <span class="n">props</span><span class="p">])</span> <span class="c1"># min_size = 100</span>
        <span class="n">remove_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">vol_clusters_label</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="n">props_size</span><span class="o">&lt;</span><span class="n">minsize</span><span class="p">]</span> <span class="c1"># should this be applied in 3D ? or just in the image? </span>
        
        <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">remove_labels</span><span class="p">:</span>
            <span class="n">vol_clusters_new</span><span class="p">[</span><span class="n">vol_clusters_label</span><span class="o">==</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># set to 0 / bg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vol_clusters_label</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                                     
            <span class="c1"># we are going to compute the actual volume using differential calculus. </span>
            <span class="n">dV_dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">uv_params_depth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dV_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">uv_params_depth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dV_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">uv_params_depth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="n">dVol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">dV_dx</span><span class="p">,</span> <span class="n">dV_dy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV_dd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">dVol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
            <span class="n">remove_labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">:</span>
                <span class="n">vol_mask</span> <span class="o">=</span> <span class="n">vol_clusters_label</span><span class="o">==</span><span class="n">lab</span>
                <span class="n">vol_mask_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">dVol</span><span class="p">[</span><span class="n">vol_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">vol_mask_area</span> <span class="o">&lt;</span> <span class="n">minsize</span><span class="p">:</span>
                    <span class="n">remove_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
        
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">remove_labels</span><span class="p">:</span>
                <span class="n">vol_clusters_new</span><span class="p">[</span><span class="n">vol_clusters_label</span><span class="o">==</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># set to 0 / bg</span>
                
    <span class="k">return</span> <span class="n">vol_clusters_new</span></div>
    
    
<div class="viewcode-block" id="prop_labels_watershed_depth_slices"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.prop_labels_watershed_depth_slices">[docs]</a><span class="k">def</span> <span class="nf">prop_labels_watershed_depth_slices</span><span class="p">(</span><span class="n">topo_depth_clusters</span><span class="p">,</span> <span class="n">depth_binary</span><span class="p">,</span> <span class="n">rev_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">expand_labels_2d</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Propagate semantic labels volumetrically from surface labels in topography space using marker-seeded watershed slice-by-slice with markers seeded from surface and from top to bottom (or bottom to top).</span>

<span class="sd">    This function is used to propagate surface labels into the volume so as to obtain realistic volumizations of protrusion instance segmentations when mapped back to (x.y.z) space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topo_depth_clusters : (MxNxL) numpy array</span>
<span class="sd">        integer labelled volume where background voxels = 0 and unique integers &gt; 0 represent unique connected objects.  </span>
<span class="sd">    depth_binary : (MxNxL) numpy array</span>
<span class="sd">        the topography binary volume defining the voxels that needs semantic labeling</span>
<span class="sd">    rev_order :  bool</span>
<span class="sd">        if True, reverses the scan direction to go from top to bottom instead of bottom to top (default) </span>
<span class="sd">    expand_labels_2d: int</span>
<span class="sd">        a preprocessing expansion of input topo_depth_clusters, to better guide the in-plane watershed propagation.            </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topo_depth_clusters_ : (MxNxL) numpy array</span>
<span class="sd">        new integer labelled volume where background voxels = 0 and unique integers &gt; 0 represent unique connected objects. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span> 
    <span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sksegmentation</span>

    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">topo_depth_clusters</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rev_order</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">topo_depth_clusters_</span> <span class="o">=</span> <span class="n">topo_depth_clusters</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">depth_binary_</span> <span class="o">=</span> <span class="n">depth_binary</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># might want to keep as 0 labels? # how to prevent flow? # we can use piecewise cuts? to approx? </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">topo_depth_clusters_</span> <span class="o">=</span> <span class="n">topo_depth_clusters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">depth_binary_</span> <span class="o">=</span> <span class="n">depth_binary</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># might want to keep as 0 labels? # how to prevent flow? # we can use piecewise cuts? to approx? </span>
    
    <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
        <span class="n">dtform_2D</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">depth_binary_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">label_dd</span> <span class="o">=</span> <span class="n">topo_depth_clusters_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">label_dd_watershed</span> <span class="o">=</span> <span class="n">sksegmentation</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">dtform_2D</span><span class="p">,</span> 
                                                          <span class="n">markers</span><span class="o">=</span><span class="n">sksegmentation</span><span class="o">.</span><span class="n">expand_labels</span><span class="p">(</span><span class="n">label_dd</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">expand_labels_2d</span><span class="p">),</span> 
                                                          <span class="n">mask</span><span class="o">=</span><span class="n">depth_binary_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># labels = watershed(-distance, markers, mask=image)</span>
            <span class="n">topo_depth_clusters_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_dd_watershed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># if dd&gt;0:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label_dd</span> <span class="o">=</span> <span class="n">topo_depth_clusters_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">joint_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">depth_binary_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth_binary_</span><span class="p">[</span><span class="n">dd</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># get the join</span>
            <span class="c1"># same time there has to be a value.</span>
            <span class="n">joint_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">joint_mask</span><span class="p">,</span> <span class="n">topo_depth_clusters_</span><span class="p">[</span><span class="n">dd</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">joint_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">label_dd</span><span class="p">[</span><span class="n">joint_mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">topo_depth_clusters_</span><span class="p">[</span><span class="n">dd</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">joint_mask</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># then copy the vals. </span>
            
            <span class="n">label_dd_watershed</span> <span class="o">=</span> <span class="n">sksegmentation</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">dtform_2D</span><span class="p">,</span> 
                                                          <span class="n">markers</span><span class="o">=</span><span class="n">sksegmentation</span><span class="o">.</span><span class="n">expand_labels</span><span class="p">(</span><span class="n">label_dd</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">expand_labels_2d</span><span class="p">),</span> 
                                                          <span class="n">mask</span><span class="o">=</span><span class="n">depth_binary_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># labels = watershed(-distance, markers, mask=image)</span>
            <span class="n">topo_depth_clusters_</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_dd_watershed</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">rev_order</span><span class="p">:</span>
        <span class="n">topo_depth_clusters_</span> <span class="o">=</span> <span class="n">topo_depth_clusters_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">topo_depth_clusters_</span></div>
    

<div class="viewcode-block" id="inpaint_topographical_height_image"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.inpaint_topographical_height_image">[docs]</a><span class="k">def</span> <span class="nf">inpaint_topographical_height_image</span><span class="p">(</span><span class="n">vol_labels_binary</span><span class="p">,</span> 
                                       <span class="n">pre_smooth_ksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="n">post_smooth_ksize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                       <span class="n">background_height_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">inpaint_method</span><span class="o">=</span><span class="s1">&#39;Telea&#39;</span><span class="p">,</span>
                                       <span class="n">inpaint_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="n">spherical_pad</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a topographical binary where 1 at (d,u,v) denotes the cell describe the cell surface as a height map where :math:`d=f(u,v)` and &#39;holes&#39; are represented with :math:`d\le h_{thresh}`, where :math:`h_{thresh}` is a minimal height threshold, use image inpainting to &#39;infill&#39; the holes to obtain a complete surface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vol_labels_binary : (MxNxL) numpy array</span>
<span class="sd">        unwrapped topographic binary volume  </span>
<span class="sd">    pre_smooth_ksize : (MxNxL) numpy array</span>
<span class="sd">        gaussian :math:`\sigma` for presmoothing the height image </span>
<span class="sd">    post_smooth_ksize :  scalar</span>
<span class="sd">        gaussian :math:`\sigma` for postsmoothing the inpainted height image </span>
<span class="sd">    background_height_thresh: scalar</span>
<span class="sd">        all (u,v) pixels with height less than the specified threshold (:math:`d\le h_{thresh}`) is marked as &#39;holes&#39; for inpainting </span>
<span class="sd">    inpaint_method : str</span>
<span class="sd">        one of two classical inpainting methods implemented in `OpenCV &lt;https://docs.opencv.org/3.4/df/d3d/tutorial_py_inpainting.html&gt;`_. </span>

<span class="sd">        &#39;Telea&#39; : </span>
<span class="sd">            Uses Fast Marching method of `Telea et al. &lt;https://docs.opencv.org/3.4/d7/d8b/group__photo__inpaint.html#gga8c5f15883bd34d2537cb56526df2b5d6a892824c38e258feb5e72f308a358d52e&gt;`_.</span>
<span class="sd">        &#39;NS&#39; : </span>
<span class="sd">            Uses Navier-Stokes method of `Bertalmio et al. &lt;https://docs.opencv.org/3.4/d7/d8b/group__photo__inpaint.html#gga8c5f15883bd34d2537cb56526df2b5d6a892824c38e258feb5e72f308a358d52e&gt;`_. </span>
<span class="sd">    spherical_pad : int</span>
<span class="sd">        the number of pixels to spherically pad, to soft-mimic the closed spherical boundary conditions in original (x,y,z) space </span>
<span class="sd">   </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    infill_height : (UxV) numpy array</span>
<span class="sd">        Inpainted height image representing the hole-completed topographic surface</span>

<span class="sd">    (background_height, infill_mask) : </span>

<span class="sd">        background_height : (UxV) numpy array</span>
<span class="sd">            Height image of the input surface </span>
<span class="sd">        infill_mask : (UxV) numpy array</span>
<span class="sd">            Binary image where 1 denotes the region to be infilled</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span> 
    <span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span>
    
    <span class="n">background_height_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">vol_labels_binary</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">background_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vol_labels_binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="c1"># build the image. </span>
    <span class="n">background_height</span><span class="p">[</span><span class="n">background_height_coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> 
                      <span class="n">background_height_coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">background_height_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># assuming the 1st = height. </span>
    
    <span class="c1"># mark the infill mask. </span>
    <span class="k">if</span> <span class="n">pre_smooth_ksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">background_height_thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infill_mask</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">background_height</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="n">pre_smooth_ksize</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infill_mask</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">background_height</span><span class="o">&lt;</span><span class="n">background_height_thresh</span><span class="p">,</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="n">pre_smooth_ksize</span><span class="p">))</span>
    
    <span class="c1"># for rescaling purposes. </span>
    <span class="n">background_height_max</span> <span class="o">=</span> <span class="n">background_height</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">inpaint_method</span> <span class="o">==</span> <span class="s1">&#39;Telea&#39;</span><span class="p">:</span>
        <span class="n">infill_height</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inpaint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">background_height</span><span class="o">/</span><span class="n">background_height_max</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">infill_mask</span><span class="p">),</span> <span class="n">inpaint_radius</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INPAINT_TELEA</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inpaint_method</span> <span class="o">==</span> <span class="s1">&#39;NS&#39;</span><span class="p">:</span>
        <span class="n">infill_height</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inpaint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">background_height</span><span class="o">/</span><span class="n">background_height_max</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">infill_mask</span><span class="p">),</span> <span class="n">inpaint_radius</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INPAINT_NS</span><span class="p">)</span>
    
    <span class="n">infill_height</span> <span class="o">=</span> <span class="n">infill_height</span><span class="o">/</span><span class="mf">255.</span> <span class="o">*</span> <span class="n">background_height_max</span>

    <span class="k">if</span> <span class="n">spherical_pad</span><span class="p">:</span>
        <span class="c1"># we need to ensure that things connect linearly # a quick fix is to set left equal to right and the top and bottom to the mean with minimal changes.  </span>
        <span class="n">infill_height_</span> <span class="o">=</span> <span class="n">infill_height</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">infill_height_</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">infill_height</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
        <span class="n">infill_height_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">infill_height</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span>
        <span class="n">infill_height_</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">infill_height_</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">infill_height</span> <span class="o">=</span> <span class="n">infill_height_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">post_smooth_ksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">infill_height</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">infill_height</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">post_smooth_ksize</span><span class="p">)</span> <span class="c1"># maybe a regulariser is a better smoother... </span>

    <span class="k">return</span> <span class="n">infill_height</span><span class="p">,</span> <span class="p">(</span><span class="n">background_height</span><span class="p">,</span> <span class="n">infill_mask</span><span class="p">)</span> </div>


<div class="viewcode-block" id="mask_volume_dense_propped_labels_with_height_image"><a class="viewcode-back" href="../../../unwrap3D.Analysis_Functions.html#unwrap3D.Analysis_Functions.topography.mask_volume_dense_propped_labels_with_height_image">[docs]</a><span class="k">def</span> <span class="nf">mask_volume_dense_propped_labels_with_height_image</span><span class="p">(</span><span class="n">vol_labels</span><span class="p">,</span> <span class="n">height_map</span><span class="p">,</span> 
                                                        <span class="n">ksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                                        <span class="n">min_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> 
                                                        <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                        <span class="n">keep_largest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This function uses a hole-completed basal surface such as that from :func:`unwrap3D.Analysis_Functions.topography.inpaint_topographical_height_image` to isolate only the protrusions from a volume-dense volumization such as the output from :func:`unwrap3D.Analysis_Functions.topography.prop_labels_watershed_depth_slices`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vol_labels : (MxNxL) numpy array</span>
<span class="sd">        integer labelled volume where background voxels = 0 and unique integers &gt; 0 represent unique connected objects. </span>
<span class="sd">    height_map : (MxN) numpy array</span>
<span class="sd">        height image at every (u,v) pixel position specifying the basal surface :math:`d=f(u,v)` such that all voxels in vol_labels with coordinates :math:`d_{uv}\le d` will be set to a background label of 0</span>
<span class="sd">    ksize :  int</span>
<span class="sd">        Optional morphological dilation of the binary surface specified by height map with a ball kernel of radius ksize. Can be used to control the extent of exclusion of the basal surface. </span>
<span class="sd">        Set this parameter to None to not do morphological processing.</span>
<span class="sd">    min_size: scalar</span>
<span class="sd">        The minimum size of connected components to keep after masking</span>
<span class="sd">    connectivity : int</span>
<span class="sd">        specifies the connectivity of voxel neighbors. If 1, the 6-connected neighborhood, if 2, the full 26-connected neighborhood including the diagonals </span>
<span class="sd">    keep_largest : bool</span>
<span class="sd">        if True, for labels that end up disconnected after the masking, retain only the largest connected region. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vol_labels_new : (MxNxL) numpy array</span>
<span class="sd">        the non excluded integer labelled volume where background voxels = 0 and unique integers &gt; 0 represent unique connected objects. </span>
<span class="sd">    infill_height_mask : (MxN) numpy array</span>
<span class="sd">        the exclusion volume specified by height_map after optional ksize morphological dilation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span> 

    <span class="c1"># use the height to mask out all invalid volumes... </span>
    <span class="c1"># depth_height = depth_mesh.vertices[:,0].reshape(H_binary_.shape[1:])</span>
    <span class="n">ZZ</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">vol_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">infill_height_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">skmorph</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ZZ</span> <span class="o">&gt;=</span> <span class="n">height_map</span><span class="p">),</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="n">ksize</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">infill_height_mask</span> <span class="o">=</span> <span class="n">ZZ</span> <span class="o">&gt;=</span> <span class="n">height_map</span>
    
    <span class="c1"># apply mask. </span>
    <span class="n">vol_labels_new</span> <span class="o">=</span> <span class="n">vol_labels</span><span class="o">*</span><span class="n">infill_height_mask</span>
    <span class="c1"># postprocess - keep only the largest component in each cluster label!   </span>
    <span class="n">keep_mask</span> <span class="o">=</span> <span class="n">skmorph</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">vol_labels_new</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    <span class="n">vol_labels_new</span> <span class="o">=</span> <span class="n">vol_labels_new</span><span class="o">*</span><span class="n">keep_mask</span> <span class="c1"># apply the mask. </span>

    <span class="k">if</span> <span class="n">keep_largest</span><span class="p">:</span>
        <span class="c1"># suppressing this should be faster. </span>
        <span class="c1"># for each label we should only have 1 connected component! </span>
        <span class="n">vol_labels_new</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">largest_component_vol_labels</span><span class="p">(</span><span class="n">vol_labels_new</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vol_labels_new</span><span class="p">,</span> <span class="n">infill_height_mask</span></div>
    

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Y. Zhou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>