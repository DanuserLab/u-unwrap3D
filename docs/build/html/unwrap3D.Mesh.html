<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>unwrap3D.Mesh package &mdash; u-Unwrap3D 0.1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> u-Unwrap3D
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">unwrap3D.Mesh package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-unwrap3D.Mesh.meshtools">unwrap3D.Mesh.meshtools module</a></li>
<li><a class="reference internal" href="#module-unwrap3D.Mesh">Module contents</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">u-Unwrap3D</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>unwrap3D.Mesh package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/unwrap3D.Mesh.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="unwrap3d-mesh-package">
<h1>unwrap3D.Mesh package<a class="headerlink" href="#unwrap3d-mesh-package" title="Permalink to this headline"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
</section>
<section id="module-unwrap3D.Mesh.meshtools">
<span id="unwrap3d-mesh-meshtools-module"></span><h2>unwrap3D.Mesh.meshtools module<a class="headerlink" href="#module-unwrap3D.Mesh.meshtools" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.MIPS_cost">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">MIPS_cost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts1_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts2_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area_mips_theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#MIPS_cost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.MIPS_cost" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Most isometric parametrization (MIPs) and the Area-preserving MIPs cost defined in <a class="reference internal" href="#r524b79e887af-1" id="id1">[1]</a> and <a class="reference internal" href="#r524b79e887af-2" id="id2">[2]</a> respectively</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts1_3D</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertices of mesh 1</p>
</dd>
<dt><strong>pts2_3D</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertices of mesh 2</p>
</dd>
<dt><strong>triangles</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the triangulation of pts1_3D and pts2_3D in terms of the vertex indices</p>
</dd>
<dt><strong>area_mips_theta</strong><span class="classifier">scalar</span></dt><dd><p>the exponent of the area-preserving MIPs cost in <a class="reference internal" href="#r524b79e887af-2" id="id3">[2]</a>. If area_mips_theta=1, the area-preserving MIPs measures the area uniformity of stretch distortion of the surface</p>
</dd>
<dt><strong>norm_pts</strong><span class="classifier">True</span></dt><dd><p>normalize vertex points by the respective surface areas of the mesh before computing the cost</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(MIPS, area_MIPS, MIPS_plus)</strong><span class="classifier">((n_faces,), (n_faces,), (n_faces,)) list of array</span></dt><dd><p>the MIPs, area preserving MIPs and the direct sum of stretch + area distortion</p>
</dd>
<dt><strong>(mean_MIPS, mean_area_MIPS, mean_MIPS_plus)</strong><span class="classifier">(3,) tuple</span></dt><dd><p>tuple of the mean MIPs, area preserving MIPs and the sum of stretch + area distortion</p>
</dd>
<dt><strong>(sigma1,sigma2)</strong><span class="classifier">((n_faces,), (n_faces,)) tuple</span></dt><dd><p>the square root of the maximum singular and square root of the minimum singular value of the square form of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</p>
</dd>
<dt><strong>(stretch_eigenvalues, stretch_eigenvectors)</strong><span class="classifier">((n_faces,), (n_faces,)) tuple</span></dt><dd><p>the singular value eigenvalue matrix and corresponding eigenvector matrix of the square form of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r524b79e887af-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Hormann, K. &amp; Greiner, G. MIPS: An efficient global parametrization method. (Erlangen-Nuernberg Univ (Germany) Computer Graphics Group, 2000)</p>
</dd>
<dt class="label" id="r524b79e887af-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>Degener, P., Meseth, J. &amp; Klein, R. An Adaptable Surface Parameterization Method. IMR 3, 201-213 (2003).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.PCA_rotate_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">PCA_rotate_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_contour_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#PCA_rotate_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.PCA_rotate_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Compute principal components of a given binary through extracting the surface mesh or a used specified surface mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>binary</strong><span class="classifier">array</span></dt><dd><p>input binary image</p>
</dd>
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a user-specified surface mesh</p>
</dd>
<dt><strong>mesh_contour_level</strong><span class="classifier">scalar</span></dt><dd><p>if only a binary is provided Marching cubes is used to extract a surface mesh at the isolevel given by <code class="docutils literal notranslate"><span class="pre">mesh_contour_level</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pca_model</strong><span class="classifier">scikit-learn PCA model instance</span></dt><dd><p>a fitted princial components model for the mesh. see sklearn.decomposition.PCA for attributes</p>
</dd>
<dt><strong>mean_pts</strong><span class="classifier">(3,) array</span></dt><dd><p>the centroid of the surface mesh with which points were demeaned prior to PCA</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.adjacency_edge_cost_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">adjacency_edge_cost_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#adjacency_edge_cost_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.adjacency_edge_cost_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Build the Laplacian matrix for a line given the vertices and the undirected edge-edge connections</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">(n_points,d) array</span></dt><dd><p>the vertices of the d-dimensional line</p>
</dd>
<dt><strong>E</strong><span class="classifier">(n_edges,2) array</span></dt><dd><p>the edge connections as integer vertex indices specifying how the vertices are joined together</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>if specified, the size of the Laplacian matrix, if not the same as the number of points in V. the returned Laplacian matrix will be of dimension ((n,n))</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">(n,n) sparse array</span></dt><dd><p>the n x n symmetric vertex laplacian matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.adjacency_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#adjacency_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.adjacency_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Build the Laplacian matrix for a line given the undirected edge-edge connections without taking into account distances between vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>E</strong><span class="classifier">(n_edges,2) array</span></dt><dd><p>the edge connections as integer vertex indices specifying how the vertices are joined together</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>if specified, the size of the Laplacian matrix, if not the same as the number of points in V. the returned Laplacian matrix will be of dimension ((n,n))</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>C</strong><span class="classifier">(n,n) sparse array</span></dt><dd><p>the n x n symmetric vertex laplacian matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.angle_distortion">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">angle_distortion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#angle_distortion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.angle_distortion" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the angle difference of triangles between two meshes of the same face connectivity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of triangle mesh 1</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>triangulations of both meshes given in terms of the vertex indices</p>
</dd>
<dt><strong>param</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of triangle mesh 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distortion</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>array of angle differences in degrees at each triangle face</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.area_distortion_flow_relax_disk">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">area_distortion_flow_relax_disk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_delaunay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mollify_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debugviz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debugviz_tri</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#area_distortion_flow_relax_disk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.area_distortion_flow_relax_disk" title="Permalink to this definition"></a></dt>
<dd><p>This function relaxes the area distortion of a mesh with disk topology i.e. a disk, square or rectangle mesh by advecting inner vertex coordinates to minimise area distortion.</p>
<p>The explicit Euler scheme of <a class="reference internal" href="#rd0d448ba3556-1" id="id6">[1]</a> is used. Due to the numerical instability of such a scheme, the density of mesh vertices and the stepsize constrains the full extent of relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input disk, square or rectangle mesh to relax. The first coordinate of all the vertices, i.e. mesh.vertices[:,0] should be uniformly set to a constant e.g. 0 to specify a 2D mesh</p>
</dd>
<dt><strong>mesh_orig</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input original geometric mesh whose vertices correspond 1 to 1 with vertices of the input mesh. This is used to compute the area distortion per iteration</p>
</dd>
<dt><strong>delta_h_bound</strong><span class="classifier">scalar</span></dt><dd><p>the maximum value of the absolute area difference between original and the relaxing mesh. This constrains the maximum gradient difference, avoiding updating local areas too fast which will then destroy local topology.</p>
</dd>
<dt><strong>stepsize</strong><span class="classifier">scalar</span></dt><dd><p>the stepsize in the direction of steepest descent of area distortion. smaller steps can improve stability and precision but with much slower convergence</p>
</dd>
<dt><strong>flip_delaunay</strong><span class="classifier">bool</span></dt><dd><p>if True, flip triangles during advection. We find this is important with the explicit Euler scheme adopted here to ensure correct topology and ensure fast relaxation.</p>
</dd>
<dt><strong>robust_L</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the robust Laplacian construction of Sharpe et al. <a class="reference internal" href="#rd0d448ba3556-2" id="id7">[2]</a>. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</p>
</dd>
<dt><strong>mollify_factor</strong><span class="classifier">scalar</span></dt><dd><p>the mollification factor used in the robust Laplacian. see <a class="reference external" href="https://github.com/nmwsharp/robust-laplacians-py">https://github.com/nmwsharp/robust-laplacians-py</a></p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>small constant for numerical stability</p>
</dd>
<dt><strong>debugviz</strong><span class="classifier">bool</span></dt><dd><p>if True, a histogram of the area distortion is plotted per iteration to check if the flow is working properly. The area distortion is plotted as log(distortion) and so should move towards a peak of 0</p>
</dd>
<dt><strong>debugvis_tri</strong><span class="classifier">bool</span></dt><dd><p>if True, plots the triangle mesh per iteration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>v_steps</strong><span class="classifier">list of (n_vertices, 3) array</span></dt><dd><p>the vertex position at every iteration. The first coordinate of the vertices is set to 0.</p>
</dd>
<dt><strong>f_steps</strong><span class="classifier">list of (n_faces, 3) array</span></dt><dd><p>the face connectivity at every iteration. This will be the same for all timepoints unless flip_delaunay=True</p>
</dd>
<dt><strong>area_distortion_iter</strong><span class="classifier">list</span></dt><dd><p>the area distortion factor per face computed as area_original/area_sphere for every timepoint.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd0d448ba3556-1"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p>Zou, Guangyu, et al. “Authalic parameterization of general surfaces using Lie advection.” IEEE Transactions on Visualization and Computer Graphics 17.12 (2011): 2005-2014.</p>
</dd>
<dt class="label" id="rd0d448ba3556-2"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>Sharp, Nicholas, and Keenan Crane. “A laplacian for nonmanifold triangle meshes.” Computer Graphics Forum. Vol. 39. No. 5. 2020.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.area_distortion_flow_relax_sphere">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">area_distortion_flow_relax_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_delaunay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mollify_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debugviz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#area_distortion_flow_relax_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.area_distortion_flow_relax_sphere" title="Permalink to this definition"></a></dt>
<dd><p>This function relaxes the area distortion of a spherical mesh by advecting vertex coordinates whilst maintaining the spherical geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input unit spherical mesh to relax</p>
</dd>
<dt><strong>mesh_orig</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input original geometric mesh whose vertices correspond 1 to 1 with vertices of the spherical mesh. This is used to compute the area distortion per iteration</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>the number of iterations relaxation will occur. The function may exit early if the mesh becomes unable to support further relaxation. A collapsed mesh will return vertices that are all np.nan</p>
</dd>
<dt><strong>smooth_iters</strong><span class="classifier">int</span></dt><dd><p>if &gt; 0, the number of Laplacian smoothing to smooth the per vertex area distortion</p>
</dd>
<dt><strong>delta</strong><span class="classifier">scalar</span></dt><dd><p>a stiffness constant of the mesh. it used to ensure maintenance of relative topology during advection</p>
</dd>
<dt><strong>stepsize</strong><span class="classifier">scalar</span></dt><dd><p>the stepsize in the direction of steepest descent of area distortion. smaller steps can improve stability and precision but with much slower convergence</p>
</dd>
<dt><strong>conformalize</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the initial Laplacian without recomputing the Laplacian. This is a very severe penalty and stops area relaxation flow without reducing <code class="docutils literal notranslate"><span class="pre">delta</span></code>. In general set this as False since relaxing area is in opposition to minimizing conformal error.</p>
</dd>
<dt><strong>flip_delaunay</strong><span class="classifier">bool</span></dt><dd><p>if True, flip triangles during advection. On the sphere we find this slows flow, affects barycentric interpolation and is generated not required. This option requires the <code class="docutils literal notranslate"><span class="pre">meshplex</span></code> library</p>
</dd>
<dt><strong>robust_L</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the robust Laplacian construction of Sharpe et al. <a class="reference internal" href="#r48cca9422f28-1" id="id10">[1]</a>. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</p>
</dd>
<dt><strong>mollify_factor</strong><span class="classifier">scalar</span></dt><dd><p>the mollification factor used in the robust Laplacian. see <a class="reference external" href="https://github.com/nmwsharp/robust-laplacians-py">https://github.com/nmwsharp/robust-laplacians-py</a></p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>small constant for numerical stability</p>
</dd>
<dt><strong>debugviz</strong><span class="classifier">bool</span></dt><dd><p>if True, a histogram of the area distortion is plotted per iteration to check if the flow is working properly. The area distortion is plotted as log(distortion) and so should move towards a peak of 0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>v_steps</strong><span class="classifier">list of (n_vertices, 3) array</span></dt><dd><p>the vertex position at every iteration</p>
</dd>
<dt><strong>f_steps</strong><span class="classifier">list of (n_faces, 3) array</span></dt><dd><p>the face connectivity at every iteration. This will be the same for all timepoints unless flip_delaunay=True</p>
</dd>
<dt><strong>area_distortion_iter</strong><span class="classifier">list</span></dt><dd><p>the area distortion factor per face computed as area_original/area_sphere for every timepoint.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r48cca9422f28-1"><span class="brackets"><a class="fn-backref" href="#id10">1</a></span></dt>
<dd><p>Sharp, Nicholas, and Keenan Crane. “A laplacian for nonmanifold triangle meshes.” Computer Graphics Forum. Vol. 39. No. 5. 2020.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.area_distortion_measure">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">area_distortion_measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#area_distortion_measure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.area_distortion_measure" title="Permalink to this definition"></a></dt>
<dd><p>Compute the normalised area scaling factor as measure of area distortion between two triangle meshes</p>
<div class="math notranslate nohighlight">
\[\lambda = \frac{A_1}{A_2}\]</div>
<p>where <span class="math notranslate nohighlight">\(A_1, A_2\)</span> are the areas of the mesh after rescaling the meshes by the square root of the respective total surface areas, <span class="math notranslate nohighlight">\(S_1,S_2\)</span> respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v1</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of a triangle mesh 1</p>
</dd>
<dt><strong>v2</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of a triangle mesh 2</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>the triangulation of both the first and second mesh, given in terms of the vertex indices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ratio</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>the area distortion factor per face between meshes <code class="docutils literal notranslate"><span class="pre">v1</span></code> and <code class="docutils literal notranslate"><span class="pre">v2</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.area_normalize_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">area_normalize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'area'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#area_normalize_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.area_normalize_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Normalize the mesh vertices by subtracting the centroid and dividing by the square root of the total surface area.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>map_color</strong><span class="classifier">bool</span></dt><dd><p>if True, copy across the vertex and face colors to the new normalised mesh</p>
</dd>
<dt><strong>centroid</strong><span class="classifier">str</span></dt><dd><p>specifies the method for computing the centroid of the mesh. If ‘area’ the face area weighted centroid is computed from triangle barycenter. If ‘points’ the centroid is computed from triangle barycenters with no weighting</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_out</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output normalized mesh</p>
</dd>
<dt><strong>(v_mean, v_out_scale)</strong><span class="classifier">((3,) array, scalar)</span></dt><dd><p>the computed centroid and scalar normalisation</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.average_onto_barycenter">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">average_onto_barycenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_barycenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#average_onto_barycenter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.average_onto_barycenter" title="Permalink to this definition"></a></dt>
<dd><p>Convert vertex values to face values by barycentric averaging of multi-dimensional vertex-associated values. This function does not work for segmentation labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">array</span></dt><dd><p>the vertices of the 3D mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">array</span></dt><dd><p>the faces of the 3D mesh specified by vertex indices</p>
</dd>
<dt><strong>vals</strong><span class="classifier">(n_vertex, d) array</span></dt><dd><p>the multi-dimensional values associated with each vertex to convert to face values</p>
</dd>
<dt><strong>return_barycenter</strong><span class="classifier">bool</span></dt><dd><p>if True, return the barycenter coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>barycenter_vals_f</strong><span class="classifier">(n_faces,d) array</span></dt><dd><p>the face-associated resampling of the input vertex-associated <code class="docutils literal notranslate"><span class="pre">vals</span></code></p>
</dd>
<dt><strong>barycenter</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the barycenter coordinates of the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.beltrami_coefficient">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">beltrami_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#beltrami_coefficient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.beltrami_coefficient" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Beltrami coefficient of a mapping between two triangle meshes. The lower the Beltrami coefficient the lower the metric distortion between the meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of triangle mesh 1</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>triangulations of both meshes given in terms of the vertex indices</p>
</dd>
<dt><strong>map_</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of triangle mesh 2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">(n_faces, ) complex array</span></dt><dd><p>array of the beltrami coefficient for each triangle face</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc6306e6c53b4-1"><span class="brackets">1</span></dt>
<dd><ol class="upperalpha simple" start="20">
<li><ol class="upperalpha simple" start="23">
<li><p>Meng, G. P.-T. Choi and L. M. Lui, “TEMPO: Feature-Endowed Teichmüller Extremal Mappings of Point Clouds.” SIAM Journal on Imaging Sciences, 9(4), pp. 1922-1962, 2016.</p></li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.build_img_2d_edges">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">build_img_2d_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#build_img_2d_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.build_img_2d_edges" title="Permalink to this definition"></a></dt>
<dd><p>Extract the 4-neighbor edge connectivity for a (M,N) 2D image, returning an array of the list of edge connections</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>grid</strong><span class="classifier">(M,N) image</span></dt><dd><p>input image of the width and height to get the edge connectivity between pixels</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>e</strong><span class="classifier">(n_edges,2) array</span></dt><dd><p>the list of unique edges specified in terms of the flattened indices in the grid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.chamfer_distance_point_cloud">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">chamfer_distance_point_cloud</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#chamfer_distance_point_cloud"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.chamfer_distance_point_cloud" title="Permalink to this definition"></a></dt>
<dd><p>Compute the standard L2 chamfer distance (CD) between two points clouds. For each point in each cloud, CD finds the nearest point in the other point set, and finds the mean L2 distance.</p>
<p>Given two point clouds, <span class="math notranslate nohighlight">\(S_1, S_2\)</span>, the chamfer distance is defined as</p>
<div class="math notranslate nohighlight">
\[\text{CD}(S_1,S_2)=\frac{1}{|S_1|}\sum_{x\in S_1} {\min_{y\in S_2} ||x-y||_2} + \frac{1}{|S_2|}\sum_{x\in S_2} {\min_{y\in S_1} ||x-y||_2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts1</strong><span class="classifier">(n_vertices_1,3) array</span></dt><dd><p>the vertices of point cloud 1. The number of vertices can be different to that of <code class="docutils literal notranslate"><span class="pre">pts2</span></code></p>
</dd>
<dt><strong>pts2</strong><span class="classifier">(n_vertices_2,3) array</span></dt><dd><p>the vertices of point cloud 2. The number of vertices can be different to that of <code class="docutils literal notranslate"><span class="pre">pts1</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chamfer_dist</strong><span class="classifier">scalar</span></dt><dd><p>the chamfer distance between the two point clouds</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.compute_geodesic_sources_distance_on_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">compute_geodesic_sources_distance_on_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_vertex_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_diffuse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'heat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#compute_geodesic_sources_distance_on_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.compute_geodesic_sources_distance_on_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Compute the geodesic distance of all vertex points on a mesh to given sources using the fast approximate vector heat method of Crane et al. <a class="reference internal" href="#r422569cf05ba-1" id="id13">[1]</a>, <a class="reference internal" href="#r422569cf05ba-2" id="id14">[2]</a> or using exact Djikstras shortest path algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>source_vertex_indices</strong><span class="classifier">list of arrays</span></dt><dd><p>List of individual ‘sources’ specifying multiple sources to compute distance from. Sources are vertex points where the geodesic distance are 0. The vector heat method, method=’heat’ allows arrays to describe individual sources as non-point like. if method=’exact’, multipoint sources are reduced to a central single-point source</p>
</dd>
<dt><strong>t_diffuse</strong><span class="classifier">scalar</span></dt><dd><p>set the time used for short-time heat flow in method=’heat’. Larger values may make the solution more stable at the cost of over-smoothing</p>
</dd>
<dt><strong>return_solver</strong><span class="classifier">bool</span></dt><dd><p>if True, return the solver used in the vector heat method, see <a class="reference external" href="https://github.com/nmwsharp/potpourri3d">https://github.com/nmwsharp/potpourri3d</a></p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>specifies the geodesic distance computation method. either of ‘heat’ for vector heat or ‘exact’ for Djikstra</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>if method == ‘heat’ :</dt><dd><dl class="simple">
<dt>geodesic_distances_components<span class="classifier">(n_sources, n_vertex) array</span></dt><dd><p>the geodesic distance of each vertex point of the mesh to each of the sources specified in <code class="docutils literal notranslate"><span class="pre">source_vertex_indices</span></code></p>
</dd>
<dt>solver<span class="classifier">potpourri3d MeshHeatMethodDistanceSolver instance </span></dt><dd><p>if return_solver=True, return the vector heat solver used for geodesic distance computation</p>
</dd>
</dl>
</dd>
<dt>if method == ‘exact’ :</dt><dd><dl class="simple">
<dt>distances<span class="classifier">(n_vertex,) array</span></dt><dd><p>an array of the shortest geodesic distance to any source for each vertex</p>
</dd>
<dt>best_source<span class="classifier">(n_vertex,) array</span></dt><dd><p>the id of the closest source for each vertex</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r422569cf05ba-1"><span class="brackets"><a class="fn-backref" href="#id13">1</a></span></dt>
<dd><p>Crane, Keenan, Clarisse Weischedel, and Max Wardetzky. “The heat method for distance computation.” Communications of the ACM 60.11 (2017): 90-99.</p>
</dd>
<dt class="label" id="r422569cf05ba-2"><span class="brackets"><a class="fn-backref" href="#id14">2</a></span></dt>
<dd><p>Sharp, Nicholas, Yousuf Soliman, and Keenan Crane. “The vector heat method.” ACM Transactions on Graphics (TOG) 38.3 (2019): 1-19.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">conformalized_mean_curvature_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-13</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mollify_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#conformalized_mean_curvature_flow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow" title="Permalink to this definition"></a></dt>
<dd><p>Conformalized mean curvature flow of a mesh of Kazhdan et al. <a class="reference internal" href="#rc94566599e68-1" id="id17">[1]</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input 3D mesh</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>the number of iterations</p>
</dd>
<dt><strong>delta</strong><span class="classifier">scalar</span></dt><dd><p>controls the stepsize of the evolution per iteration. Smaller values gives less deformation</p>
</dd>
<dt><strong>rescale_output</strong><span class="classifier">bool</span></dt><dd><p>if False will return a surface area normalised mesh instead. if True return the mean curvature flow surfaces at the same scale as the input mesh</p>
</dd>
<dt><strong>min_diff :</strong></dt><dd><p>not used for now</p>
</dd>
<dt><strong>conformalize :</strong></dt><dd><p>if True, the Laplacian matrix is not recomputed at every iteration.</p>
</dd>
<dt><strong>robust_L</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the robust Laplacian construction of Sharpe et al. <a class="reference internal" href="#rc94566599e68-2" id="id18">[2]</a>. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</p>
</dd>
<dt><strong>mollify_factor</strong><span class="classifier">scalar</span></dt><dd><p>the mollification factor used in the robust Laplacian. see <a class="reference external" href="https://github.com/nmwsharp/robust-laplacians-py">https://github.com/nmwsharp/robust-laplacians-py</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>Usteps</strong><span class="classifier">(n_points,3,niters+1) array</span></dt><dd><p>an array of the vertex coordinates of the mesh at each iteration</p>
</dd>
<dt><strong>F</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the face connectivity of the mesh</p>
</dd>
<dt><strong>flow_metrics_dict</strong><span class="classifier">dict</span></dt><dd><p>a dict of various statistical measures of the flow</p>
<dl class="simple">
<dt>‘mean_curvature_iter’<span class="classifier">array</span></dt><dd><p>mean of absolute values of mean curvature per face per iteration</p>
</dd>
<dt>‘max_curvature_iter’<span class="classifier">array</span></dt><dd><p>maximum of absolute values of mean curvature per face per iteration</p>
</dd>
<dt>‘gauss_curvature_iter’<span class="classifier">array</span></dt><dd><p>mean of absolute values of Gaussian curvature per face per iteration</p>
</dd>
<dt>‘canonical_c_all’<span class="classifier">array</span></dt><dd><p>array of the computed face area weighted centroid per iteration with respect to an area normalised mesh</p>
</dd>
<dt>‘canonical_area_all’<span class="classifier">array </span></dt><dd><p>array of the total surface area used for area normalising per iteration</p>
</dd>
<dt>‘flow_d_all’<span class="classifier">array</span></dt><dd><p>matrix norm difference between current and previous vertex coordinate positions</p>
</dd>
<dt>‘V0_max’<span class="classifier">scalar</span></dt><dd><p>the maximum scalar value over all coordinate values used to initially scale the mesh vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc94566599e68-1"><span class="brackets"><a class="fn-backref" href="#id17">1</a></span></dt>
<dd><p>Kazhdan, Michael, Jake Solomon, and Mirela Ben‐Chen. “Can mean‐curvature flow be modified to be non‐singular?.” Computer Graphics Forum. Vol. 31. No. 5. Oxford, UK: Blackwell Publishing Ltd, 2012.</p>
</dd>
<dt class="label" id="rc94566599e68-2"><span class="brackets"><a class="fn-backref" href="#id18">2</a></span></dt>
<dd><p>Sharp, Nicholas, and Keenan Crane. “A laplacian for nonmanifold triangle meshes.” Computer Graphics Forum. Vol. 39. No. 5. 2020.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">conformalized_mean_curvature_flow_topography</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-13</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mollify_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#conformalized_mean_curvature_flow_topography"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography" title="Permalink to this definition"></a></dt>
<dd><p>Adapted conformalized mean curvature flow of a mesh of Kazhdan et al. <a class="reference internal" href="#r1131d31a23bf-1" id="id21">[1]</a> to allow for topographic meshes such that iterative applications flattens the topography to the plane.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input topography mesh</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>the number of iterations</p>
</dd>
<dt><strong>delta</strong><span class="classifier">scalar</span></dt><dd><p>controls the stepsize of the evolution per iteration. Smaller values gives less deformation</p>
</dd>
<dt><strong>min_diff :</strong></dt><dd><p>not used for now</p>
</dd>
<dt><strong>conformalize :</strong></dt><dd><p>if True, the Laplacian matrix is not recomputed at every iteration.</p>
</dd>
<dt><strong>robust_L</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the robust Laplacian construction of Sharpe et al. <a class="reference internal" href="#r1131d31a23bf-2" id="id22">[2]</a>. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</p>
</dd>
<dt><strong>mollify_factor</strong><span class="classifier">scalar</span></dt><dd><p>the mollification factor used in the robust Laplacian. see <a class="reference external" href="https://github.com/nmwsharp/robust-laplacians-py">https://github.com/nmwsharp/robust-laplacians-py</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>Usteps</strong><span class="classifier">(n_points,3,niters+1) array</span></dt><dd><p>an array of the vertex coordinates of the mesh at each iteration</p>
</dd>
<dt><strong>F</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the face connectivity of the mesh</p>
</dd>
<dt><strong>flow_metrics_dict</strong><span class="classifier">dict</span></dt><dd><p>a dict of various statistical measures of the flow</p>
<dl class="simple">
<dt>‘mean_curvature_iter’<span class="classifier">array</span></dt><dd><p>mean of absolute values of mean curvature per face per iteration</p>
</dd>
<dt>‘max_curvature_iter’<span class="classifier">array</span></dt><dd><p>maximum of absolute values of mean curvature per face per iteration</p>
</dd>
<dt>‘gauss_curvature_iter’<span class="classifier">array</span></dt><dd><p>mean of absolute values of Gaussian curvature per face per iteration</p>
</dd>
<dt>‘canonical_c_all’<span class="classifier">array</span></dt><dd><p>array of the computed face area weighted centroid per iteration with respect to an area normalised mesh</p>
</dd>
<dt>‘canonical_area_all’<span class="classifier">array </span></dt><dd><p>array of the total surface area used for area normalising per iteration</p>
</dd>
<dt>‘flow_d_all’<span class="classifier">array</span></dt><dd><p>matrix norm difference between current and previous vertex coordinate positions</p>
</dd>
<dt>‘V0_max’<span class="classifier">scalar</span></dt><dd><p>the maximum scalar value over all coordinate values used to initially scale the mesh vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1131d31a23bf-1"><span class="brackets"><a class="fn-backref" href="#id21">1</a></span></dt>
<dd><p>Kazhdan, Michael, Jake Solomon, and Mirela Ben‐Chen. “Can mean‐curvature flow be modified to be non‐singular?.” Computer Graphics Forum. Vol. 31. No. 5. Oxford, UK: Blackwell Publishing Ltd, 2012.</p>
</dd>
<dt class="label" id="r1131d31a23bf-2"><span class="brackets"><a class="fn-backref" href="#id22">2</a></span></dt>
<dd><p>Sharp, Nicholas, and Keenan Crane. “A laplacian for nonmanifold triangle meshes.” Computer Graphics Forum. Vol. 39. No. 5. 2020.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.conformalized_mean_line_flow">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">conformalized_mean_line_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contour_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">close_contour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topography_edge_fix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#conformalized_mean_line_flow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.conformalized_mean_line_flow" title="Permalink to this definition"></a></dt>
<dd><p>Conformalized mean curvature flow of a curve, also known as the isoperimetric flow.</p>
<p>This function is adapted from the Matlab GPToolbox</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>contour_pts</strong><span class="classifier">(n_points,d) array</span></dt><dd><p>the list of coordinates of the line</p>
</dd>
<dt><strong>E</strong><span class="classifier">(n_edges,2) array</span></dt><dd><p>the edge connectivity of points on the line</p>
</dd>
<dt><strong>close_contour</strong><span class="classifier">bool</span></dt><dd><p>if True and E is None, construct the edge connectivity assuming the order of the given contour_pts and connecting the last point to the 1st point. If False and E is None, the order of the given contour_pts is still assumed but the last point to the 1st point is not connected by an edge</p>
</dd>
<dt><strong>fixed_boundary</strong><span class="classifier">bool</span></dt><dd><p>if True, the ends of the contour_pts is not involved but is pinned to its original position. Only the interior points are updated</p>
</dd>
<dt><strong>lambda_flow</strong><span class="classifier">scalar</span></dt><dd><p>controls the stepsize of the evolution per iteration. Smaller values given less movement</p>
</dd>
<dt><strong>niters</strong><span class="classifier">int</span></dt><dd><p>the number of iterations to run</p>
</dd>
<dt><strong>topography_edge_fix</strong><span class="classifier">bool</span></dt><dd><p>this is only relevant for <a class="reference internal" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography" title="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow_topography()</span></code></a> or lines coming from topographic boundaries where we wish to remove all flow in other directions except that in the depth axis at the boundary.</p>
</dd>
<dt><strong>conformalize</strong><span class="classifier">bool</span></dt><dd><p>if True, the Laplacian matrix is not recomputed at every iteration.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>contour_pts_flow</strong><span class="classifier">(n_points,d,niters+1)</span></dt><dd><p>the list of coordinates of the line at each iteration including the initial position. The edge connectivity is the same as input</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.connected_components_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">connected_components_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_face_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#connected_components_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.connected_components_mesh" title="Permalink to this definition"></a></dt>
<dd><p>find the connected face components given a mesh or submesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh,</p>
</dd>
<dt><strong>original_face_indices</strong><span class="classifier">(N,) array</span></dt><dd><p>if provided these should be the original face indices that mesh.faces come from. The final connected components will be re-indexed with the provided original_face_indices.</p>
</dd>
<dt><strong>engine</strong><span class="classifier">str</span></dt><dd><p>Which graph engine to use (‘scipy’, ‘networkx’)</p>
</dd>
<dt><strong>min_len</strong><span class="classifier">int</span></dt><dd><p>the minimum number of faces in a connected component. Those with a number of faces that these will be dropped</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>components</strong><span class="classifier">list of arrays</span></dt><dd><p>list of an array of face indices forming a connected component</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.create_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">create_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">face_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#create_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.create_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper around trimesh.Trimesh to create a mesh given the vertices, faces and optionally vertex colors or face colors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>the vertices of the mesh geometry</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the 0-indexed integer indices indicating how vertices are joined together to form a triangle element</p>
</dd>
<dt><strong>vertex_colors</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>if provided, an array of the RGB color values per vertex</p>
</dd>
<dt><strong>face_colors</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>if provided, an array of the RGB color values per face</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh or trimesh.Scene</span></dt><dd><p>created mesh geometry with colors saved in mesh.visual.vertex_colors or mesh.visual.face_colors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.decimate_resample_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">decimate_resample_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remesh_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predecimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#decimate_resample_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.decimate_resample_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Downsample (decimate) and optionally resample the mesh to equilateral triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>remesh_samples</strong><span class="classifier">0-1</span></dt><dd><p>fraction of the number of vertex points to target in size of the output mesh</p>
</dd>
<dt><strong>predecimate</strong><span class="classifier">bool</span></dt><dd><p>if True, small edges are first collapsed using igl.decimate in the <code class="docutils literal notranslate"><span class="pre">igl</span></code> library</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.diff_area_trimesh_trimesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">diff_area_trimesh_trimesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trimesh1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trimesh2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#diff_area_trimesh_trimesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.diff_area_trimesh_trimesh" title="Permalink to this definition"></a></dt>
<dd><p>Difference in total surface area between two triangle meshes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trimesh1</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>trimesh2</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>diff_area</strong><span class="classifier">scalar</span></dt><dd><p>the signed difference in the total surface area between mesh 1 and mesh 2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.diff_area_trimesh_uv">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">diff_area_trimesh_uv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trimesh1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv_to_trimesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#diff_area_trimesh_uv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.diff_area_trimesh_uv" title="Permalink to this definition"></a></dt>
<dd><p>Difference in total surface area between a triangle mesh and a (u,v) image parameterized 3D mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trimesh1</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>uv2</strong><span class="classifier">(U,V,3) array</span></dt><dd><p>a (u,v) image parameterized 3D surface</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>a small constant for numerical stability</p>
</dd>
<dt><strong>pad</strong><span class="classifier">bool</span></dt><dd><p>if True, uses edge padding to compute the finite differences for evaluating the differential areas of <code class="docutils literal notranslate"><span class="pre">uv2</span></code></p>
</dd>
<dt><strong>uv_to_trimesh</strong><span class="classifier">bool</span></dt><dd><p>if True, convert the (u,v) image parameterized 3D triangle mesh into a 3D triangle mesh before evaluating the difference.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>diff_area</strong><span class="classifier">scalar</span></dt><dd><p>the signed difference in the total surface area between the triangle mesh and the (u,v) parameterized mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.direct_spherical_conformal_map">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">direct_spherical_conformal_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#direct_spherical_conformal_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.direct_spherical_conformal_map" title="Permalink to this definition"></a></dt>
<dd><p>A linear method for computing spherical conformal map of a genus-0 closed surface using quasiconformal mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of a genus-0 triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>triangulations of a genus-0 triangle mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>param</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of the spherical conformal parameterization which maps the input mesh to the unit sphere.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r739c2fc06e0c-1"><span class="brackets">1</span></dt>
<dd><ol class="upperalpha simple" start="16">
<li><ol class="upperalpha simple" start="20">
<li><p>Choi, K. C. Lam, and L. M. Lui, “FLASH: Fast Landmark Aligned Spherical Harmonic Parameterization for Genus-0 Closed Brain Surfaces.” SIAM Journal on Imaging Sciences, vol. 8, no. 1, pp. 67-94, 2015.</p></li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.disk_conformal_map">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">disk_conformal_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">north</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">south</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#disk_conformal_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.disk_conformal_map" title="Permalink to this definition"></a></dt>
<dd><p>Compute the disk conformal mapping using the method in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertex coordinates of a simply-connected open triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>triangulations of a simply-connected open triangle mesh</p>
</dd>
<dt><strong>corner</strong><span class="classifier">(4,) array</span></dt><dd><p>optional input for specifying the exact 4 vertex indices for rearranging the boundary index, with anti-clockwise orientation</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int</span></dt><dd><p>if corner is None, this is a random seed that randomly picks the 4 corners for rearranging the boundary index.</p>
</dd>
<dt><strong>north</strong><span class="classifier">int</span></dt><dd><p>scalar for fixing the north pole iterations</p>
</dd>
<dt><strong>south :</strong></dt><dd><p>scalar for fixing the south pole iterations</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">scalar</span></dt><dd><p>convergence threshold between the old and new energy cost per iteration in the Beltrami coefficient optimization.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>the maximum number of Beltrami coefficient optimization</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>disk_new</strong><span class="classifier">(n_vertices,2) array</span></dt><dd><p>vertex coordinates of the updated disk conformal parameterization starting from an initial harmonic disk parametrization</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Please make sure that the input mesh does not contain any unreferenced vertices/non-manifold vertices/non-manifold edges.</p></li>
<li><p>Please remove all valence 1 boundary vertices (i.e. vertices with only 1 face attached to them) before running the program.</p></li>
</ol>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r411b4d70e6ff-1"><span class="brackets">1</span></dt>
<dd><ol class="upperalpha simple" start="16">
<li><ol class="upperalpha simple" start="20">
<li><p>Choi and L. M. Lui, “Fast Disk Conformal Parameterization of Simply-Connected Open Surfaces.” Journal of Scientific Computing, 65(3), pp. 1065-1090, 2015.</p></li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.distance_to_heat_affinity_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">distance_to_heat_affinity_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Dmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#distance_to_heat_affinity_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.distance_to_heat_affinity_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Convert any distance matrix to an affinity matrix by applying a heat kernel.</p>
<div class="math notranslate nohighlight">
\[A = \exp^{\left(\frac{-D^2}{2\sigma^2}\right)}\]</div>
<p>where <span class="math notranslate nohighlight">\(sigma\)</span> is set as the mean distance of <span class="math notranslate nohighlight">\(D\)</span> or <span class="math notranslate nohighlight">\(\gamma\)</span> if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Dmatrix</strong><span class="classifier">(N,N) sparse array</span></dt><dd><p>a scipy.sparse input distance matrix</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar</span></dt><dd><p>the normalisation scale factor of distances</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(N,N) sparse array</span></dt><dd><p>a scipy.sparse output affinity distance matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.f2v">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">f2v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#f2v"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.f2v" title="Permalink to this definition"></a></dt>
<dd><p>Compute the face to vertex interpolation matrix taking into account unequal lengths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertex coordinates of a triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>triangulations of a triangle mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">(n_vertices, n_faces) sparse array</span></dt><dd><p>the face to vertex matrix such that S.dot(face_values), gives the interpolated vertex values equivalent</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.find_and_loc_corner_rect_open_surface">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">find_and_loc_corner_rect_open_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vol_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curvature_flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#find_and_loc_corner_rect_open_surface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.find_and_loc_corner_rect_open_surface" title="Permalink to this definition"></a></dt>
<dd><p>Find and locate the 4 corners of a rectangular topography mesh. Curvature flow of the boundary is used to identify the corners fast and accurately</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a simply-connected open triangle topography mesh</p>
</dd>
<dt><strong>vol_shape</strong><span class="classifier">(D,U,V) tuple</span></dt><dd><p>the shape of the topography volume space the topography mesh comes from</p>
</dd>
<dt><strong>ref_depth</strong><span class="classifier">int</span></dt><dd><p>if curvature_flow=False, this is the depth coordinate of the topography mesh used to locate corners (implicitly assuming all corners are of equal depth)</p>
</dd>
<dt><strong>order</strong><span class="classifier">‘cc’ or ‘acc’</span></dt><dd><p>specifies whether the input mesh has faces oriented ‘cc’-clockwise or ‘acc’-anticlockwise</p>
</dd>
<dt><strong>curvature_flow</strong><span class="classifier">bool</span></dt><dd><p>if True, uses curvature flow of the boundary to help locate the corners of the topography mesh. This is most accurate. If False, the corners will attempt to be found by idealistic matching to 4 corners constructed by ref_depth and the 4 corners of the image grid spanned by vertices of the input mesh</p>
</dd>
<dt><strong>delta_flow</strong><span class="classifier">scalar</span></dt><dd><p>specifies the speed of flow if curvature_flow=True. Higher flow gives faster convergence.</p>
</dd>
<dt><strong>flow_iters</strong><span class="classifier">int</span></dt><dd><p>specifies the number of iterations of curvature flow. Higher will give more flow</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bnd</strong><span class="classifier">(n,) array</span></dt><dd><p>the vertex indices of the boundary of the topography mesh</p>
</dd>
<dt><strong>corner_bnd_ind</strong><span class="classifier">(4,) array</span></dt><dd><p>the indices of <code class="docutils literal notranslate"><span class="pre">bnd</span></code> specifying the 4 corners in anti-clockwise order</p>
</dd>
<dt><strong>corner_v_ind</strong><span class="classifier">(4,) array</span></dt><dd><p>the vertex indices of the input mesh specifying the 4 corners in anti-clockwise order</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.find_central_ind">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">find_central_ind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_components_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#find_central_ind"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.find_central_ind" title="Permalink to this definition"></a></dt>
<dd><p>Given a list of mesh patches in the form of vertex indices of the mesh, find the index on the mesh surface for each patch that is closest to the patch centroid. This assumes that each patch is local such that the patch centroid is covered by the convex hull.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertex,3)</span></dt><dd><p>vertices of the full 3D mesh</p>
</dd>
<dt><strong>vertex_components_indices</strong><span class="classifier">list of arrays</span></dt><dd><p>list of patches, where each patch is given as vertex indices into <code class="docutils literal notranslate"><span class="pre">v</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>central_inds</strong><span class="classifier">(n_components,)</span></dt><dd><p>an array the same number as the given vertex patches/components given the index into <code class="docutils literal notranslate"><span class="pre">v</span></code> closest to the geometrical centroid of the vertex component</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.find_curvature_cutoff_index">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">find_curvature_cutoff_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#find_curvature_cutoff_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.find_curvature_cutoff_index" title="Permalink to this definition"></a></dt>
<dd><p>For a given array of values, find the first index where the difference or absolute difference between two values falls below a threshold value. This function can be used to find the stopping iteration number for conformalized mean curvature smoothing based on the dcrease in absolute Gaussian curvature. If no such index can be found then np.nan is returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">(N,) array</span></dt><dd><p>1d array of values</p>
</dd>
<dt><strong>thresh</strong><span class="classifier">scalar</span></dt><dd><p>the cutoff value threshold where we return the index where values &lt;= thresh. If None, the median of np.diff(values) is used.</p>
</dd>
<dt><strong>absval</strong><span class="classifier">bool</span></dt><dd><p>determine whether the cut-off is on the absolute differences in value or differences in value</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int</span></dt><dd><p>if an index is found return an int otherwise return np.nan</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">find_principal_axes_surface_heterogeneity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_to_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ascending'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#find_principal_axes_surface_heterogeneity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity" title="Permalink to this definition"></a></dt>
<dd><p>Find the principal axes of a point cloud given individual weights for each point. If weights are not given, every point is weighted equally</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts</strong><span class="classifier">array</span></dt><dd><p>the coordinates of a point cloud</p>
</dd>
<dt><strong>pts_weights</strong><span class="classifier">array</span></dt><dd><p>the positive weights specifying the importance of each point in the principal axes computation</p>
</dd>
<dt><strong>map_to_sphere</strong><span class="classifier">bool</span></dt><dd><p>if True, the unit sphere coordinate by projecting each point by distance normalization to compute principal axes. This enables geometry-independent computation useful for e.g. getting directional alignment based only on surface intensity</p>
</dd>
<dt><strong>sort</strong><span class="classifier">‘ascending’ or ‘descending’</span></dt><dd><p>the sorting order of the eigenvectors in terms of the absolute value of the respective eigenvalues</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">(d,) array</span></dt><dd><p>the sorted eigenvalues of the principal eigenvectors of the d-dimensional point cloud</p>
</dd>
<dt><strong>v</strong><span class="classifier">(d,d) array</span></dt><dd><p>the sorted eigenvectors of the corresponding eigenvalues</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface" title="unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface()</span></code></a></dt><dd><p>Equivalent for finding the principal eigenvectors when give a uv parametrized surface of xyz coordinates.</p>
</dd>
<dt><a class="reference internal" href="#unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh" title="unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh()</span></code></a></dt><dd><p>Equivalent for finding the principal eigenvectors when give a 3D triangle mesh.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">find_principal_axes_surface_heterogeneity_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_to_sphere</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ascending'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#find_principal_axes_surface_heterogeneity_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Find the principal axes of a mesh given individual weights for each vertex. If weights are not given, every vertex is weighted equally</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">array</span></dt><dd><p>the vertex cordinates of the 3D mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">array</span></dt><dd><p>the faces of the 3D mesh specified by vertex indices</p>
</dd>
<dt><strong>v_weights</strong><span class="classifier">array</span></dt><dd><p>the positive weights specifying the importance of each vertex in the principal axes computation</p>
</dd>
<dt><strong>map_to_sphere</strong><span class="classifier">bool</span></dt><dd><p>if True, the unit sphere coordinate by projecting each vertex by distance normalization to compute principal axes. This enables geometry-independent computation useful for e.g. getting directional alignment based only on surface intensity</p>
</dd>
<dt><strong>sort</strong><span class="classifier">‘ascending’ or ‘descending’</span></dt><dd><p>the sorting order of the eigenvectors in terms of the absolute value of the respective eigenvalues</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">(d,) array</span></dt><dd><p>the sorted eigenvalues of the principal eigenvectors of the d-dimensional point cloud</p>
</dd>
<dt><strong>v</strong><span class="classifier">(d,d) array</span></dt><dd><p>the sorted eigenvectors of the corresponding eigenvalues</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface" title="unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Unzipping.unzip.find_principal_axes_uv_surface()</span></code></a></dt><dd><p>Equivalent for finding the principal eigenvectors when give a uv parametrized surface of xyz coordinates.</p>
</dd>
<dt><a class="reference internal" href="#unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh" title="unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.find_principal_axes_surface_heterogeneity_mesh()</span></code></a></dt><dd><p>Equivalent for finding the principal eigenvectors when give a 3D triangle mesh.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.flat_open_surface">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">flat_open_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vol_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map2square</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">square_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'elliptical'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curvature_flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#flat_open_surface"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.flat_open_surface" title="Permalink to this definition"></a></dt>
<dd><p>Main wrapping function to unwrap an open 3D mesh, primarily a topography into 2D disk, or 2D rectangle (continuing from the 2D disk)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a simply-connected open triangle topography mesh</p>
</dd>
<dt><strong>vol_shape</strong><span class="classifier">(M,N,L) tuple</span></dt><dd><p>the shape of the volume space the topography mesh comes from</p>
</dd>
<dt><strong>map2square</strong><span class="classifier">bool</span></dt><dd><p>If True, continue to map the disk to the square or conformal rectangle with options specified by <code class="docutils literal notranslate"><span class="pre">square_method</span></code>. If False or if square_method=None, the intermediate disk parameterization is returned</p>
</dd>
<dt><strong>square_method</strong><span class="classifier">str</span></dt><dd><p>One of ‘Teichmuller’ for conformal rectangular mapping, ‘squicircle’ for squicircle squaring of disk to square, ‘elliptical’ for elliptical mapping of Nowell of disk to square. ‘Teichmuller’ is slow but conformal minimizing.</p>
</dd>
<dt><strong>ref_depth</strong><span class="classifier">int</span></dt><dd><p>if curvature_flow=False, this is the depth coordinate of the topography mesh used to locate corners (implicitly assuming all corners are of equal depth)</p>
</dd>
<dt><strong>order</strong><span class="classifier">‘cc’ or ‘acc’</span></dt><dd><p>specifies whether the input mesh has faces oriented ‘cc’-clockwise or ‘acc’-anticlockwise</p>
</dd>
<dt><strong>optimize</strong><span class="classifier">bool</span></dt><dd><p>if True, applies Beltrami coefficient optimization to compute the rectangular aspect ratio to minimize distortion given the square_method=’squicircle’ and square_method=’elliptical’ options. Teichmuller by default will have this option enabled.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>square</strong><span class="classifier">(n_vertices, 2)</span></dt><dd><p>the disk or square parametrization of the input mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.get_inverse_distance_weight_grid_laplacian">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">get_inverse_distance_weight_grid_laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#get_inverse_distance_weight_grid_laplacian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.get_inverse_distance_weight_grid_laplacian" title="Permalink to this definition"></a></dt>
<dd><p>Compute a sparse grid Laplacian matrix for 2D image based on inverse weighting of edge lengths. This allows to take into account the length distortion of grid points constructed from 2D unwrapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>grid</strong><span class="classifier">(M,N) image</span></dt><dd><p>input image of the width and height to get the edge connectivity between pixels</p>
</dd>
<dt><strong>grid_pts</strong><span class="classifier">(M,N,d) image</span></dt><dd><p>input image with which to compute edge lengths based on the Euclidean distance of the d-features. e.g. this could be the bijective (u,v) &lt;-&gt; (x,y,z) unwrapping parameters where d=3.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">scalar</span></dt><dd><p>a shape factor that controls the inverse distance weights. In short, this is a small pseudo-distance added to measured distances to avoid division by zero or infs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>L</strong><span class="classifier">(MxN,MxN) array</span></dt><dd><p>the sparse grid Laplacian where edge connections factor into account the distance between <code class="docutils literal notranslate"><span class="pre">grid_pts</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.get_k_neighbor_ring">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">get_k_neighbor_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateful</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#get_k_neighbor_ring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.get_k_neighbor_ring" title="Permalink to this definition"></a></dt>
<dd><p>Find all vertex indices within a K-ring neighborhood of individual vertices of a mesh. For a vertex its K-Neighbors are all those of maximum length K edges away. The result is return as an adjacency list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh,</p>
</dd>
<dt><strong>K</strong><span class="classifier">int</span></dt><dd><p>the maximum distance of a topological neighbor defined by the number of edge-hops away.</p>
</dd>
<dt><strong>stateful</strong><span class="classifier">bool</span></dt><dd><p>if True, returns list of adjacency lists for all neighborhoods k=1..to..K. if False, only the asked for K neighborhood is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>k_rings</strong><span class="classifier">(n_vertex long adjacency list) or (list of n_vertex long adjacency list)</span></dt><dd><p>if stateful=False, one adjacency list for the specified K of length n_vertex is returned else all list of adjacency lists for all neighborhoods k=1..to..K is provided</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.get_uv_grid_quad_connectivity">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">get_uv_grid_quad_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_triangles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'spherical'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#get_uv_grid_quad_connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.get_uv_grid_quad_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Compute the quad and the triangle connectivity between pixels in a 2d grid with either spherical or no boundary conditions</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>grid</strong><span class="classifier">(M,N,d) image</span></dt><dd><p>input image of the width and height to get the pixel connectivity, N must be odd if bounds=’spherical’ due to the necessary rewrapping.</p>
</dd>
<dt><strong>return_triangles</strong><span class="classifier">bool</span></dt><dd><p>if True, return in addition the triangle connectivity based on triangulation of the quad grid connectivity</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">str</span></dt><dd><p>string specifying the boundary conditions of the grid, either of ‘spherical’ or ‘none’</p>
<dl class="simple">
<dt>‘spherical’<span class="classifier">str</span></dt><dd><p>this wraps the left to right side, pinches together the top and pinches together the bottom of the grid</p>
</dd>
<dt>‘none’<span class="classifier">str</span></dt><dd><p>this does no unwrapping and returns the grid connectivity of the image. This is the same as sklearn.feature_extraction.image.grid_to_graph</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>all_squares</strong><span class="classifier">(N_squares,4) array</span></dt><dd><p>the 4-neighbor quad connectivity of flattened image indices</p>
</dd>
<dt><strong>all_squares_to_triangles</strong><span class="classifier">(2*N_squares,3) array</span></dt><dd><p>the triangle connectivity of the flattened image indices. Each square splits into 2 triangles.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.get_uv_grid_tri_connectivity">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">get_uv_grid_tri_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#get_uv_grid_tri_connectivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.get_uv_grid_tri_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Construct the vertex and faces indices to convert a (M,N,d) d-dimensional grid coordinates with spherical geometry to a triangle mesh where vertices=grid.ravel()[vertex_indices], faces=face_indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>grid</strong><span class="classifier">(M,N) or (M,N,d) array</span></dt><dd><p>input (u,v) image used to construct vertex and face indices for</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertex_indices_all</strong><span class="classifier">(N_all,3) array</span></dt><dd><p>specifies the flattened indices in the grid to form the vertices of the triangle mesh</p>
</dd>
<dt>triangles_all :</dt><dd><p>specifies the flattened indices in the grid to form the faces of the triangle mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.grid2D_surface_pulldown_mesh_surface_coords">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">grid2D_surface_pulldown_mesh_surface_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rect_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Varray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_mesh_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cross'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_interp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#grid2D_surface_pulldown_mesh_surface_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.grid2D_surface_pulldown_mesh_surface_coords" title="Permalink to this definition"></a></dt>
<dd><p>Main function to map a 2D rectangular mesh and list of 3D triangle meshes given by their vertices bijective to the 3D surface it describes to an image of a given grid_shape through proximity-based matching</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rect_mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>A 2D triangle mesh specified as a 3D triangle mesh where the last 2 coordinate axes are taken to be the x-,y- coordinates of the output image.</p>
</dd>
<dt><strong>Varray</strong><span class="classifier">list of (n_vertices,3)</span></dt><dd><p>a list of 3D meshes given only by their vertices whom are bijective to <code class="docutils literal notranslate"><span class="pre">rect_mesh</span></code> such that they share the same number of vertices and the same face connectivity. We assume the order of the vertices in <code class="docutils literal notranslate"><span class="pre">rect_mesh</span></code> and the meshes in <code class="docutils literal notranslate"><span class="pre">Varray</span></code> are aligned.</p>
</dd>
<dt><strong>grid</strong><span class="classifier">(M,N) or (M,N,d) single- or multi- channel image</span></dt><dd><p>input image to get the (M,N) shape</p>
</dd>
<dt><strong>grid_shape</strong><span class="classifier">(M,N) tuple</span></dt><dd><p>the shape of the grid, only used if grid is not specified. Only one of grid or grid_shape needs to be passed</p>
</dd>
<dt><strong>rescale_mesh_pts</strong><span class="classifier">bool</span></dt><dd><p>if True, the rect_mesh vertices are first rescaled in order to maximally cover the size of the intended image</p>
</dd>
<dt><strong>match_method</strong><span class="classifier">str</span></dt><dd><p>one of ‘cross’ implementing <a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a> or ‘cramer’ implementing <a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a> for computing the barycentric coordinate after matching each image pixel to the rect_mesh</p>
</dd>
<dt><strong>return_interp</strong><span class="classifier">bool</span></dt><dd><p>if True, also return the matching parameters between the final image coordinates and <code class="docutils literal notranslate"><span class="pre">rect_mesh</span></code> for reuse</p>
</dd>
<dt><strong>interp_method</strong><span class="classifier">str</span></dt><dd><p>One of ‘linear’ for <code class="docutils literal notranslate"><span class="pre">matplotlib.tri.LinearTriInterpolator</span></code> interpolation, 
‘cubic_geom’ for <code class="docutils literal notranslate"><span class="pre">matplotlib.tri.CubicTriInterpolator</span></code> with kind=’geom’ and ‘cubic_min_E’ for mtri.CubicTriInterpolator with kind=’min_E’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pulldown_Varray_coords</strong><span class="classifier">(len(Varray),N,3) array</span></dt><dd><p>The remapped coordinates of 3D surface meshes bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> as vertex measurements on <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code></p>
</dd>
<dt><strong>triang</strong><span class="classifier">matplotlib.tri.Triangulation instance</span></dt><dd><p>Optional return if <code class="docutils literal notranslate"><span class="pre">return_interp=True</span></code>. The Matlplotlib triangulation of the rescaled <code class="docutils literal notranslate"><span class="pre">rect_mesh</span></code> used for interpolation with <code class="docutils literal notranslate"><span class="pre">matplotlib.tri.LinearTriInterpolator</span></code> internally</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.hausdorff_distance_point_cloud">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">hausdorff_distance_point_cloud</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'two-sided'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#hausdorff_distance_point_cloud"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.hausdorff_distance_point_cloud" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Hausdorff distance (H) between two points clouds. The Hausdorff distance is the it is the greatest of all the distances from a point in one point cloud to the closest point in the other point cloud.</p>
<p>The ‘two-sided’ Hausdorff distance takes the maximum of comparing the 1st point cloud to the 2nd point cloud and the 2nd point cloud to the 1st point cloud</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts1</strong><span class="classifier">(n_vertices_1, 3) array</span></dt><dd><p>the vertices of point cloud 1. The number of vertices can be different to that of <code class="docutils literal notranslate"><span class="pre">pts2</span></code></p>
</dd>
<dt><strong>pts2</strong><span class="classifier">(n_vertices_2, 3) array</span></dt><dd><p>the vertices of point cloud 2. The number of vertices can be different to that of <code class="docutils literal notranslate"><span class="pre">pts1</span></code></p>
</dd>
<dt><strong>mode</strong><span class="classifier">‘one-sided’ or ‘two-sided’</span></dt><dd><p>compute either the one sided with the specified order of pts1 to pts2 or the ‘two-sided’ which compares both orders and returns the maximum</p>
</dd>
<dt><strong>return_index</strong><span class="classifier">bool</span></dt><dd><p>if True, return two additional optional outputs that specify the index of a point cloud and the index of its closest neighbor in the other point cloud</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hausdorff_dist</strong><span class="classifier">scalar</span></dt><dd><p>the chamfer distance between the two point clouds</p>
</dd>
<dt><strong>id_a</strong><span class="classifier">(N,) array</span></dt><dd><p>the vertex id of the points in pts1 matched with maximum shortest distance to vertex ids <code class="docutils literal notranslate"><span class="pre">id_b</span></code> in pts2</p>
</dd>
<dt><strong>id_b</strong><span class="classifier">(N,)</span></dt><dd><p>the vertex id of the points in pts2 matched with maximum shortest distance to vertex ids <code class="docutils literal notranslate"><span class="pre">id_b</span></code> in pts1</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.labelspreading_fill_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">labelspreading_fill_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_prop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#labelspreading_fill_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.labelspreading_fill_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Applies Constrained Label propagation of <a class="reference internal" href="#r8e9f8b842a73-1" id="id27">[1]</a> with the uniform Laplacian matrix to diffuse vertex-based multi-labels on a 3D triangular mesh to infill small non-labelled background areas within the boundary of individual labelled regions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>vertices of the triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>faces of the triangle mesh</p>
</dd>
<dt><strong>vertex_labels</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>the integer vertex-based multi labels</p>
</dd>
<dt><strong>niters</strong><span class="classifier">int</span></dt><dd><p>the number of iterations of infilling</p>
</dd>
<dt><strong>alpha_prop</strong><span class="classifier">0-1 scalar</span></dt><dd><p>clamping factor. A value in (0, 1) that specifies the relative amount that a vertex should adopt the information from its neighbors as opposed to its initial label. alpha=0 means keeping the initial label information; alpha=1 means replacing all initial information.</p>
</dd>
<dt><strong>minsize</strong><span class="classifier">int</span></dt><dd><p>the minimum size of a labelled region to infill. Small labelled regions are not infilled as they themselves are assumed to be unstable</p>
</dd>
<dt><strong>bg_label</strong><span class="classifier">int</span></dt><dd><p>the integer label denoting the background regions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertex_labels_final</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>The updated vertex multi label array</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8e9f8b842a73-1"><span class="brackets"><a class="fn-backref" href="#id27">1</a></span></dt>
<dd><p>Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston, Bernhard Schoelkopf. Learning with local and global consistency (2004)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.labelspreading_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">labelspreading_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_prop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_proba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#labelspreading_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.labelspreading_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Applies Label propagation of <a class="reference internal" href="#r5163de9a7b91-1" id="id29">[1]</a> with a default or specified affinity matrix, W to competitively diffuse vertex-based multi-labels on a 3D triangular mesh. Background labels are assumed to be 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>vertices of the triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>faces of the triangle mesh</p>
</dd>
<dt><strong>x</strong><span class="classifier">(N,) array</span></dt><dd><p>the vertex indices that have been assigned integer labels &gt; 0</p>
</dd>
<dt><strong>y</strong><span class="classifier">(N,) array</span></dt><dd><p>the matching assumed sequential integer labels from 1 to n_labels of the specified vertex indices in <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt><strong>W</strong><span class="classifier">(n_vertex, n_vertex) sparse array</span></dt><dd><p>if specified, the Laplacian-like affinity matrix used to diffuse binary labels. Defaults to the cotan Laplacian matrix</p>
</dd>
<dt><strong>niters</strong><span class="classifier">int</span></dt><dd><p>the number of iterations</p>
</dd>
<dt><strong>alpha_prop</strong><span class="classifier">0-1 scalar</span></dt><dd><p>clamping factor. A value in (0, 1) that specifies the relative amount that a vertex should adopt the information from its neighbors as opposed to its initial label. alpha=0 means keeping the initial label information; alpha=1 means replacing all initial information.</p>
</dd>
<dt><strong>return_proba</strong><span class="classifier">(n_vertices,)</span></dt><dd><p>if True, return the diffused probability matrix</p>
</dd>
<dt><strong>renorm</strong><span class="classifier">bool</span></dt><dd><p>if True, at each iteration assign each vertex to the most probable label with probability = 1.</p>
</dd>
<dt><strong>convergence_iter</strong><span class="classifier">int</span></dt><dd><p>the number of iterations for which the diffused labels do not change for. After this number of iterations the function will early stop before <code class="docutils literal notranslate"><span class="pre">n_iters</span></code>, otherwise the propagation occurs for at least <code class="docutils literal notranslate"><span class="pre">n_iters</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>z_label</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>The updated vertex multi label array</p>
</dd>
<dt><strong>z</strong><span class="classifier">(n_vertices, n_labels+1)</span></dt><dd><p>The probabilistic vertex multi label assignment where rowsums = 1</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5163de9a7b91-1"><span class="brackets"><a class="fn-backref" href="#id29">1</a></span></dt>
<dd><p>Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston, Bernhard Schoelkopf. Learning with local and global consistency (2004)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.labelspreading_mesh_binary">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">labelspreading_mesh_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_proba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#labelspreading_mesh_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.labelspreading_mesh_binary" title="Permalink to this definition"></a></dt>
<dd><p>Applies Laplacian ‘local weighted’ smoothing with a default or specified affinity matrix to diffuse vertex-based binary labels on a 3D triangular mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>vertices of the triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>faces of the triangle mesh</p>
</dd>
<dt><strong>y</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>the initial binary labels to diffuse</p>
</dd>
<dt><strong>W</strong><span class="classifier">(n_vertex, n_vertex) sparse array</span></dt><dd><p>if specified, the Laplacian-like affinity matrix used to diffuse binary labels. Defaults to the cotan Laplacian matrix</p>
</dd>
<dt><strong>niters</strong><span class="classifier">int</span></dt><dd><p>the number of iterations</p>
</dd>
<dt><strong>return_proba</strong><span class="classifier">(n_vertices,)</span></dt><dd><p>if True, return the diffused probability matrix</p>
</dd>
<dt><strong>thresh</strong><span class="classifier">0-1 scalar</span></dt><dd><p>if less than 1, the probability matrix per iteration is binarised by thresholding &gt; thresh. This allows faster diffusion of positive labels, equivalent of an inflation factor</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels_clean</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>The updated vertex binary label array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.linear_beltrami_solver">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">linear_beltrami_solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">landmark</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#linear_beltrami_solver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.linear_beltrami_solver" title="Permalink to this definition"></a></dt>
<dd><p>Linear Beltrami solver to find the minimal quasiconformal distortion mapping for unwrapping an open 3D mesh to a 2D rectangular map</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of triangle mesh 1</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>triangulations of both meshes given in terms of the vertex indices</p>
</dd>
<dt><strong>mu</strong><span class="classifier">(n_faces,) complex array</span></dt><dd><p>the beltrami coefficient at each triangular face</p>
</dd>
<dt><strong>landmark</strong><span class="classifier">(n,) array</span></dt><dd><p>the vertex indices in the triangle mesh to enforce mapping to <code class="docutils literal notranslate"><span class="pre">target</span></code></p>
</dd>
<dt><strong>target</strong><span class="classifier">(n,) complex array</span></dt><dd><p>the coordinates of <code class="docutils literal notranslate"><span class="pre">landmark</span></code> vertices in the 2D unwrapping</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>param</strong><span class="classifier">(n_vertices, 2) array</span></dt><dd><p>the 2D coordinates of the now 2D parametrized vertex coordinates of the input mesh</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4ca6f92bfcb0-1"><span class="brackets">1</span></dt>
<dd><ol class="upperalpha simple" start="16">
<li><ol class="upperalpha simple" start="20">
<li><p>Choi, K. C. Lam, and L. M. Lui, “FLASH: Fast Landmark Aligned Spherical Harmonic Parameterization for Genus-0 Closed Brain Surfaces.” SIAM Journal on Imaging Sciences, vol. 8, no. 1, pp. 67-94, 2015.</p></li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.map_3D_to_2D_triangles">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">map_3D_to_2D_triangles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#map_3D_to_2D_triangles"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.map_3D_to_2D_triangles" title="Permalink to this definition"></a></dt>
<dd><p>Isometric projection of 3D triangles to 2D coordinates This function implements the solution of <a class="reference internal" href="#re5594ee6faa8-1" id="id32">[1]</a>. This function is similar to igl.project_isometrically_to_plane</p>
<p>Given the vertices <span class="math notranslate nohighlight">\(v_1, v_2, v_3\)</span> of a triangle in 3D, a 2D isometric projection can be constructed that preserves length and area with new vertex coordinate defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}v^{2D}_1 &amp;= (0, 0) \\
v^{2D}_2 &amp;= (|A|, 0) \\
v^{2D}_3 &amp;= (A.B/ |A|, |A \times B|/|A|)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(A=v_2-v_1\)</span>, <span class="math notranslate nohighlight">\(B=v_3-v_1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts3D</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>the 3D vertices of the mesh</p>
</dd>
<dt><strong>triangles</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the triangulation of pts3D given by vertex indices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pts_2D</strong><span class="classifier">(n_faces,2) array</span></dt><dd><p>the vertices of the triangle in 2D</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re5594ee6faa8-1"><span class="brackets"><a class="fn-backref" href="#id32">1</a></span></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/8051220/flattening-a-3d-triangle">https://stackoverflow.com/questions/8051220/flattening-a-3d-triangle</a></p>
</dd>
<dt class="label" id="re5594ee6faa8-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://scicomp.stackexchange.com/questions/25327/finding-shape-functions-for-a-triangle-in-3d-coordinate-space">https://scicomp.stackexchange.com/questions/25327/finding-shape-functions-for-a-triangle-in-3d-coordinate-space</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.marching_cubes_mesh_binary">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">marching_cubes_mesh_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">presmooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contourlevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remesh_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pyacvd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remesh_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remesh_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predecimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_mesh_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_largest_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_comp_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upsamplemethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inplane'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#marching_cubes_mesh_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.marching_cubes_mesh_binary" title="Permalink to this definition"></a></dt>
<dd><p>Mesh an input binary volume using Marching Cubes algorithm with optional remeshing to improve mesh quality</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>vol</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>presmooth</strong><span class="classifier">scalar</span></dt><dd><p>pre Gaussian smoothing with the specified sigma to get a better marching cubes mesh.</p>
</dd>
<dt><strong>contourlevel :</strong></dt><dd><p>isolevel to extract the Marching cubes mesh</p>
</dd>
<dt><strong>remesh_method</strong><span class="classifier">str</span></dt><dd><p>one of ‘pyacvd’ or ‘optimesh’.</p>
<dl class="simple">
<dt>‘pyacvd’<span class="classifier">str</span></dt><dd><p>pyacvd uses voronoidal clustering i.e. kmeans clustering to produce a uniformly remeshing, see <a class="reference external" href="https://github.com/pyvista/pyacvd">https://github.com/pyvista/pyacvd</a></p>
</dd>
<dt>‘optimesh’<span class="classifier">str</span></dt><dd><p>if selected, this method aims to relax the mesh vertices to a more uniform state, see <a class="reference external" href="https://github.com/meshpro/optimesh">https://github.com/meshpro/optimesh</a>. This doesn’t change the number of vertices and so effect of this is limited and there is some changing of the input shape</p>
</dd>
</dl>
</dd>
<dt><strong>remesh_samples</strong><span class="classifier">0-1</span></dt><dd><p>fraction of the number of vertex points to target in size of the output mesh</p>
</dd>
<dt><strong>remesh_params</strong><span class="classifier">dict</span></dt><dd><p>only for remesh_method=’optimesh’. See <a class="reference internal" href="unwrap3D.Parameters.html#unwrap3D.Parameters.params.optimesh_relaxation_config" title="unwrap3D.Parameters.params.optimesh_relaxation_config"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Parameters.params.optimesh_relaxation_config()</span></code></a> for template of parameter settings</p>
</dd>
<dt><strong>predecimate</strong><span class="classifier">bool</span></dt><dd><p>if True, collapse the small edges in the Marching Cubes output before remeshing</p>
</dd>
<dt><strong>min_mesh_size</strong><span class="classifier">int</span></dt><dd><p>minimum number of vertices in the output mesh</p>
</dd>
<dt><strong>keep_largest_only</strong><span class="classifier">bool</span></dt><dd><p>if True, check and keep only the largest mesh component</p>
</dd>
<dt><strong>min_comp_size</strong><span class="classifier">int</span></dt><dd><p>if keep_largest_only=False, remesh=True and split_mesh=True, individual connected components of the mesh is checked and only those &gt; min_comp_size are kept. This is crucial if the mesh is to be remeshed. The remeshing fraction is applied to all components equally.  Without this check, there will be errors as some mesh components become zero.</p>
</dd>
<dt><strong>split_mesh</strong><span class="classifier">bool</span></dt><dd><p>if True, runs connected component to filter out Marching cubes components that are too small (keep_largest_only=False) or keep only the largest (keep_largest_only=True) prior to remeshing</p>
</dd>
<dt><strong>upsamplemethod</strong><span class="classifier">str</span></dt><dd><p>one of ‘inplane’ or ‘loop’ allowed in igl.upsample. This is called to meet the minimum number of vertices in the final mesh as specified in <code class="docutils literal notranslate"><span class="pre">min_mesh_size</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.mass_matrix2D">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">mass_matrix2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#mass_matrix2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.mass_matrix2D" title="Permalink to this definition"></a></dt>
<dd><p>Build the Mass matrix for a given adjacency or Laplacian matrix. The mass matrix is a diagonal matrix of the row sums of the input matrix, A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(N,N) array or sparse array</span></dt><dd><p>the Adjacency or symmetric Laplacian matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>M</strong><span class="classifier">(N,N) sparse array</span></dt><dd><p>a diagonal matrix whose entries are the row sums of the symmetric input matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.match_and_interpolate_img_surface_to_rect_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">match_and_interpolate_img_surface_to_rect_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rect_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_mesh_pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cross'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#match_and_interpolate_img_surface_to_rect_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.match_and_interpolate_img_surface_to_rect_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Match the grid of an image to the faces of a reference rectangular-like triangle mesh where the last 2 coordinate axes is the 2D xy coordinates to allow mapping of mesh measurements to an image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rect_mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input 2D mesh where the first 2 coordinate axes is the 2D xy coordinates</p>
</dd>
<dt><strong>grid</strong><span class="classifier">(M,N) or (M,N,d) single- or multi- channel image</span></dt><dd><p>input image to get the (M,N) shape</p>
</dd>
<dt><strong>grid_shape</strong><span class="classifier">(M,N) tuple</span></dt><dd><p>the shape of the grid, only used if grid is not specified. Only one of grid or grid_shape needs to be passed</p>
</dd>
<dt><strong>rescale_mesh_pts</strong><span class="classifier">bool</span></dt><dd><p>if True, the rect_mesh vertices are first rescaled in order to maximally cover the size of the intended image</p>
</dd>
<dt><strong>match_method</strong><span class="classifier">str</span></dt><dd><p>one of ‘cross’ implementing <a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a> or ‘cramer’ implementing <a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a> for computing the barycentric coordinate after matching each image pixel to the rect_mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tri_id</strong><span class="classifier">(MxN,)</span></dt><dd><p>1d array giving the face index each image pixel maps to in the rect_mesh</p>
</dd>
<dt><strong>mesh_ref_closest_pt_barycentric</strong><span class="classifier">(MxN,3)</span></dt><dd><p>the barycentric weights giving the position inside the matched triangle face, each image pixel maps to</p>
</dd>
<dt><strong>grid_shape</strong><span class="classifier">(M,N) tuple</span></dt><dd><p>the shape of the image grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.match_and_interpolate_uv_surface_to_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">match_and_interpolate_uv_surface_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cross'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#match_and_interpolate_uv_surface_to_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.match_and_interpolate_uv_surface_to_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Match the grid of an image given by the shape of the uv unwrapped surface to a reference 3D triangle mesh based on nearest distance for reinterpolation of mesh measurements to unwrapped surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unwrap_params</strong><span class="classifier">(UxVx3) array</span></dt><dd><p>the input 2D image specifying the uv unwrapped (x,y,z) surface</p>
</dd>
<dt><strong>mesh_ref</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input 3D mesh we wish to match the coordinates of unwrap_params to, to allow barycentric interpolation</p>
</dd>
<dt><strong>match_method</strong><span class="classifier">str</span></dt><dd><p>one of ‘cross’ implementing <a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a> or ‘cramer’ implementing <a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a> for computing the barycentric coordinate after matching each image pixel to the rect_mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tri_id</strong><span class="classifier">(UxV,)</span></dt><dd><p>1d array giving the face index each (u,v) image pixel maps to in <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code></p>
</dd>
<dt><strong>mesh_ref_closest_pt_barycentric</strong><span class="classifier">(UxV,3)</span></dt><dd><p>the barycentric weights giving the position inside the matched triangle face, each (u,v) image pixel maps to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.measure_props_trimesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">measure_props_trimesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">main_component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#measure_props_trimesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.measure_props_trimesh" title="Permalink to this definition"></a></dt>
<dd><p>Compute basic statistics and properties of a given mesh</p>
<ul class="simple">
<li><p>is Convex : Yes/No</p></li>
<li><p>is Volume : Yes/No - is it closed such that a volume can be computed</p></li>
<li><p>is Watertight : Yes/No - is it closed such that a volume can be computed</p></li>
<li><p>orientability : Yes/No - can all faces be oriented the same way. Mobius strips and Klein bottles are non-orientable</p></li>
<li><p>Euler number : or Euler characteristic, <span class="math notranslate nohighlight">\(\chi\)</span> #vertices - #edges + #faces</p></li>
<li><p>Genus : <span class="math notranslate nohighlight">\((2-2\chi)/2\)</span> if orientable or <span class="math notranslate nohighlight">\(2-\chi\)</span> if nonorientable</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>main_component</strong><span class="classifier">bool</span></dt><dd><p>if True, get the largest mesh component and compute statistics on this</p>
</dd>
<dt><strong>clean</strong><span class="classifier">bool</span></dt><dd><p>if True, removes NaN and infs and degenerate and duplicate faces which may affect the computation of some of these statistics</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>props</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the metrics</p>
<p>‘convex’ : bool</p>
<p>‘volume’ : bool</p>
<p>‘watertight’ : bool</p>
<p>‘orientability’ : bool</p>
<p>‘euler_number’ : scalar</p>
<p>‘genus’ : scalar</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.measure_triangle_props">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">measure_triangle_props</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#measure_triangle_props"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.measure_triangle_props" title="Permalink to this definition"></a></dt>
<dd><p>Compute statistics regarding the quality of the triangle faces</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh_</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>clean</strong><span class="classifier">bool</span></dt><dd><p>if True, removes NaN and infs and degenerate and duplicate faces which may affect the computation of some of these statistics</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>props</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the metrics</p>
<dl class="simple">
<dt>‘min_angle’<span class="classifier">scalar</span></dt><dd><p>minimum internal triangle angle of faces in degrees</p>
</dd>
<dt>‘avg_angle’<span class="classifier">scalar</span></dt><dd><p>mean internal triangle angle of faces in degrees</p>
</dd>
<dt>‘max_angle’<span class="classifier"></span></dt><dd><p>maximum internal triangle angle of faces in degrees</p>
</dd>
<dt>‘std_dev angle’<span class="classifier"></span></dt><dd><p>standard devation of internal triangle angle of faces in degrees</p>
</dd>
<dt>‘min_quality’<span class="classifier"></span></dt><dd><p>minimum triangle quality. triangle quality is measured as 2*inradius/circumradius</p>
</dd>
<dt>‘avg_quality’<span class="classifier"></span></dt><dd><p>mean triangle quality. triangle quality is measured as 2*inradius/circumradius</p>
</dd>
<dt>‘max_quality’<span class="classifier"></span></dt><dd><p>maximum triangle quality. triangle quality is measured as 2*inradius/circumradius</p>
</dd>
<dt>‘quality’</dt><dd><p>per face quality. triangle quality is measured as 2*inradius/circumradius</p>
</dd>
<dt>‘angles’<span class="classifier"></span></dt><dd><p>all internal face angles</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.mesh_vertex_interpolate_scalar">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">mesh_vertex_interpolate_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_tri_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_tri_barycentric</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_vals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#mesh_vertex_interpolate_scalar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.mesh_vertex_interpolate_scalar" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate vertex associated values associated with the vertices of a reference mesh onto a different geometry specified implicitly by the face id and barycentric coordinates the new geometry maps to in the reference mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh_ref</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input 3D mesh we wish to match the coordinates of unwrap_params to, to allow barycentric interpolation</p>
</dd>
<dt><strong>mesh_tri_id</strong><span class="classifier">(N,)</span></dt><dd><p>1d array of the triangle face index in <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> we want to interpolate <code class="docutils literal notranslate"><span class="pre">scalar_vals</span></code> on</p>
</dd>
<dt><strong>mesh_tri_barycentric</strong><span class="classifier">(N,3)</span></dt><dd><p>the barycentric weights specifying the linear weighting of the vertex scalar_vals associated with the vertices of <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> to compute the new scalar values</p>
</dd>
<dt><strong>scalar_vals</strong><span class="classifier">(n_vertices,d)</span></dt><dd><p>the vertex associated measurements on the mesh_ref which is used to compute the new scalar values at the coordinate locations on the mesh specified by <code class="docutils literal notranslate"><span class="pre">mesh_tri_id</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh_tri_barycentric</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scalar_vals_interp</strong><span class="classifier">(N,d)</span></dt><dd><p>the reinterpolated <code class="docutils literal notranslate"><span class="pre">scalar_vals</span></code> at the coordinate locations on the mesh specified by <code class="docutils literal notranslate"><span class="pre">mesh_tri_id</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh_tri_barycentric</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.mesh_watershed_segmentation_faces">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">mesh_watershed_segmentation_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">face_components</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_diffuse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_face_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'heat'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#mesh_watershed_segmentation_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.mesh_watershed_segmentation_faces" title="Permalink to this definition"></a></dt>
<dd><p>Do marker seeded watershed segmentation on the mesh by assigning individual faces to the user provided ‘seeds’ or sources by geodesic distance. Output is an integer label for each mesh face with -1 denoting a user masked out face.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>face_components</strong><span class="classifier">list of arrays</span></dt><dd><p>the seeds or ‘sources’ given as a list of face index components</p>
</dd>
<dt><strong>t_diffuse</strong><span class="classifier">scalar</span></dt><dd><p>set the time used for short-time heat flow in method=’heat’. Larger values may make the solution more stable at the cost of over-smoothing</p>
</dd>
<dt><strong>mesh_face_mask</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>a binary array 0 or 1 specifying which faces should not be included in the final labels. Masked out faces are assigned a label of -1, whereas all valid labels are integer 0 or above.</p>
</dd>
<dt><strong>return_solver</strong><span class="classifier">bool</span></dt><dd><p>if True, return the solver used in the vector heat method, see <a class="reference external" href="https://github.com/nmwsharp/potpourri3d">https://github.com/nmwsharp/potpourri3d</a></p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>specifies the geodesic distance computation method. either of ‘heat’ for vector heat or ‘exact’ for Djikstra</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>geodesic_distances_components</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>for each face, the geodesic distance to the assigned source</p>
</dd>
<dt><strong>geodesic_distances_label</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>for each faces, the id of the source assigned</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.mobius_area_correction_disk">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">mobius_area_correction_disk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#mobius_area_correction_disk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.mobius_area_correction_disk" title="Permalink to this definition"></a></dt>
<dd><p>Find an optimal Mobius transformation for reducing the area distortion of a disk conformal parameterization using the method in <a class="reference internal" href="#r5685a116e2a3-1" id="id35">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertex coordinates of a simply-connected open triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>triangulations of a simply-connected open triangle mesh</p>
</dd>
<dt><strong>param</strong><span class="classifier">(n_vertices,2) array</span></dt><dd><p>vertex coordinates of the disk conformal parameterization of the mesh given by <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>map_mobius_disk</strong><span class="classifier">(n_vertices,2) array</span></dt><dd><p>vertex coordinates of the updated disk conformal parameterization</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5685a116e2a3-1"><span class="brackets"><a class="fn-backref" href="#id35">1</a></span></dt>
<dd><ol class="upperalpha simple" start="7">
<li><ol class="upperalpha simple" start="16">
<li><ol class="upperalpha simple" start="20">
<li><p>Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, “Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.” SIAM Journal on Imaging Sciences, 2020.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.mobius_area_correction_spherical">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">mobius_area_correction_spherical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#mobius_area_correction_spherical"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.mobius_area_correction_spherical" title="Permalink to this definition"></a></dt>
<dd><p>Find an optimal Mobius transformation for reducing the area distortion of a spherical conformal parameterization using the method in <a class="reference internal" href="#r69896d433229-1" id="id37">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertex coordinates of a genus-0 closed triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>triangulations of the genus-0 closed triangle mesh</p>
</dd>
<dt><strong>param</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertex coordinates of the spherical conformal parameterization of the mesh given by <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>map_mobius</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertex coordinates of the updated spherical conformal parameterization</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r69896d433229-1"><span class="brackets"><a class="fn-backref" href="#id37">1</a></span></dt>
<dd><ol class="upperalpha simple" start="7">
<li><ol class="upperalpha simple" start="16">
<li><ol class="upperalpha simple" start="20">
<li><p>Choi, Y. Leung-Liu, X. Gu, and L. M. Lui, “Parallelizable global conformal parameterization of simply-connected surfaces via partial welding.” SIAM Journal on Imaging Sciences, 2020.</p></li>
</ol>
</li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">parametric_mesh_constant_img_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_img_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltaL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'implicit'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mollify_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#parametric_mesh_constant_img_flow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow" title="Permalink to this definition"></a></dt>
<dd><p>This function performs implicit Euler propagation of a 3D mesh with steps of constant <code class="docutils literal notranslate"><span class="pre">step_size</span></code> in the direction of an external image gradient specified by <code class="docutils literal notranslate"><span class="pre">external_img_gradient</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>external_img_gradient</strong><span class="classifier">(MxNxLx3) array</span></dt><dd><p>the 3D volumetric displacement field with x,y,z coordinates the last axis.</p>
</dd>
<dt><strong>niters</strong><span class="classifier">int</span></dt><dd><p>the number of total steps</p>
</dd>
<dt><strong>deltaL</strong><span class="classifier">scalar</span></dt><dd><p>a stiffness regularization constant for the conformalized mean curvature flow propagation</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">scalar</span></dt><dd><p>the multiplicative factor the image gradient is multipled with per iteration</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>one of ‘implicit’ for implicit Euler or ‘explicit’ for explicit Euler. ‘implicit’ is slower but much more stable and results in mesh updates that minimize foldover and instabilities. ‘explicit’ is unstable but fast.</p>
</dd>
<dt><strong>robust_L</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the robust Laplacian construction of Sharpe et al. <a class="reference internal" href="#r50dca5c250cb-1" id="id39">[1]</a>. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</p>
</dd>
<dt><strong>mollify_factor</strong><span class="classifier">scalar</span></dt><dd><p>the mollification factor used in the robust Laplacian. see <a class="reference external" href="https://github.com/nmwsharp/robust-laplacians-py">https://github.com/nmwsharp/robust-laplacians-py</a></p>
</dd>
<dt><strong>conformalize</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the simplified conformalized mean curvature variant mesh propagation derived in the paper <a class="reference internal" href="#r50dca5c250cb-2" id="id40">[2]</a>. If False, uses the normal active contours update which uses <code class="docutils literal notranslate"><span class="pre">gamma</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code> parameters.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar</span></dt><dd><p>stability regularization parameter in the active contour</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">scalar</span></dt><dd><p>stiffness regularization parameters in the active contour</p>
</dd>
<dt><strong>beta</strong><span class="classifier">scalar</span></dt><dd><p>bending regularization parameters in the active contour</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>small constant for numerical stability</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Usteps</strong><span class="classifier">(n_vertices,3,n_iters+1) array</span></dt><dd><p>the vertex positions of the mesh at every interation. The face connectivity of the mesh does not change.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r50dca5c250cb-1"><span class="brackets"><a class="fn-backref" href="#id39">1</a></span></dt>
<dd><p>Sharp, Nicholas, and Keenan Crane. “A laplacian for nonmanifold triangle meshes.” Computer Graphics Forum. Vol. 39. No. 5. 2020.</p>
</dd>
<dt class="label" id="r50dca5c250cb-2"><span class="brackets"><a class="fn-backref" href="#id40">2</a></span></dt>
<dd><p>c.f. Unwrapping paper.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.parametric_uv_unwrap_mesh_constant_img_flow">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">parametric_uv_unwrap_mesh_constant_img_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uv_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_img_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deltaL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_pts_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'implicit'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mollify_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#parametric_uv_unwrap_mesh_constant_img_flow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.parametric_uv_unwrap_mesh_constant_img_flow" title="Permalink to this definition"></a></dt>
<dd><p>This convenience function performs implicit Euler propagation of an open uv-parametrized 3D mesh with steps of constant <code class="docutils literal notranslate"><span class="pre">step_size</span></code> in the direction of an external image gradient specified by <code class="docutils literal notranslate"><span class="pre">external_img_gradient</span></code></p>
<p>the uv-parametrization is closed before propagating in 3D (x,y,z) space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>uv_grid</strong><span class="classifier">(M,N,3) image</span></dt><dd><p>input mesh as an image with xyz on the last dimension.</p>
</dd>
<dt><strong>external_img_gradient</strong><span class="classifier">(MxNxLx3) array</span></dt><dd><p>the 3D volumetric displacement field with x,y,z coordinates the last axis.</p>
</dd>
<dt><strong>niters</strong><span class="classifier">int</span></dt><dd><p>the number of total steps</p>
</dd>
<dt><strong>deltaL</strong><span class="classifier">scalar</span></dt><dd><p>a stiffness regularization constant for the conformalized mean curvature flow propagation</p>
</dd>
<dt><strong>surf_pts_ref</strong><span class="classifier">(N,3) array</span></dt><dd><p>if provided, this is a reference surface with which to automatically determine the niters when propagating the surface outwards to ensure the full reference shape is sampled in topography space.</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">scalar</span></dt><dd><p>the multiplicative factor the image gradient is multipled with per iteration</p>
</dd>
<dt><strong>pad_dist</strong><span class="classifier">int</span></dt><dd><p>an additional fudge factor added to the automatically determined n_dist when surf_pts_ref is provided and n_dist is not user provided</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>one of ‘implicit’ for implicit Euler or ‘explicit’ for explicit Euler. ‘implicit’ is slower but much more stable and results in mesh updates that minimize foldover and instabilities. ‘explicit’ is unstable but fast.</p>
</dd>
<dt><strong>robust_L</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the robust Laplacian construction of Sharpe et al. <a class="reference internal" href="#rfc36482042fc-1" id="id43">[1]</a>. If False, the standard cotan Laplacian is used. The robust Laplacian enables proper handling of degenerate and nonmanifold vertices such as that if using the triangle mesh constructed from a uv image grid. The normal 3D mesh if remeshed does not necessarily need this</p>
</dd>
<dt><strong>mollify_factor</strong><span class="classifier">scalar</span></dt><dd><p>the mollification factor used in the robust Laplacian. see <a class="reference external" href="https://github.com/nmwsharp/robust-laplacians-py">https://github.com/nmwsharp/robust-laplacians-py</a></p>
</dd>
<dt><strong>conformalize</strong><span class="classifier">bool</span></dt><dd><p>if True, uses the simplified conformalized mean curvature variant mesh propagation derived in the paper <a class="reference internal" href="#rfc36482042fc-2" id="id44">[2]</a>. If False, uses the normal active contours update which uses <code class="docutils literal notranslate"><span class="pre">gamma</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code> parameters.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar</span></dt><dd><p>stability regularization parameter in the active contour</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">scalar</span></dt><dd><p>stiffness regularization parameters in the active contour</p>
</dd>
<dt><strong>beta</strong><span class="classifier">scalar</span></dt><dd><p>bending regularization parameters in the active contour</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>small constant for numerical stability</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Usteps_out_rec</strong><span class="classifier">(niters+1,M,N,3) array</span></dt><dd><p>the vertex positions of the mesh for every interation for every pixel position</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow" title="unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.parametric_mesh_constant_img_flow()</span></code></a></dt><dd><p>the propagation for a general 3D mesh</p>
</dd>
<dt><a class="reference internal" href="unwrap3D.Unzipping.html#unwrap3D.Unzipping.unzip.prop_ref_surface" title="unwrap3D.Unzipping.unzip.prop_ref_surface"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Unzipping.unzip.prop_ref_surface()</span></code></a></dt><dd><p>the equivalent for explicit Euler propagation using the uv-based image coordinates without closing the mesh</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfc36482042fc-1"><span class="brackets"><a class="fn-backref" href="#id43">1</a></span></dt>
<dd><p>Sharp, Nicholas, and Keenan Crane. “A laplacian for nonmanifold triangle meshes.” Computer Graphics Forum. Vol. 39. No. 5. 2020.</p>
</dd>
<dt class="label" id="rfc36482042fc-2"><span class="brackets"><a class="fn-backref" href="#id44">2</a></span></dt>
<dd><p>c.f. Unwrapping paper.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.quasi_conformal_error">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">quasi_conformal_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts1_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts2_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#quasi_conformal_error"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.quasi_conformal_error" title="Permalink to this definition"></a></dt>
<dd><p>Computes the quasi-conformal error between two 3D triangle meshes as defined in <a class="reference internal" href="#ree64494bb486-1" id="id47">[1]</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pts1_3D</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertices of mesh 1</p>
</dd>
<dt><strong>pts2_3D</strong><span class="classifier">(n_vertices,3) array</span></dt><dd><p>vertices of mesh 2</p>
</dd>
<dt><strong>triangles</strong><span class="classifier">(n_faces,3) array</span></dt><dd><p>the triangulation of pts1_3D and pts2_3D in terms of the vertex indices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Jac_eigvals</strong><span class="classifier">(n_faces,)</span></dt><dd><p>eigenvalues of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</p>
</dd>
<dt><strong>stretch_factor</strong><span class="classifier">(n_faces,)</span></dt><dd><p>the ratio of the square root of maximum singular value over square root of of the minimum singular value of the square form of the transformation matrix mapping the 2D isometric projections of pts1_3D to pts_2_3D</p>
</dd>
<dt><strong>mean_stretch_factor</strong><span class="classifier">scalar</span></dt><dd><p>the area weighted mean stretch factor or quasi-conformal error</p>
</dd>
<dt><strong>(areas3D, areas3D_2)</strong><span class="classifier">((n_faces,), (n_faces,)) list of arrays</span></dt><dd><p>the triangle areas of the first and second mesh respectively</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ree64494bb486-1"><span class="brackets"><a class="fn-backref" href="#id47">1</a></span></dt>
<dd><p>Hormann, K. &amp; Greiner, G. MIPS: An efficient global parametrization method. (Erlangen-Nuernberg Univ (Germany) Computer Graphics Group, 2000)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.read_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">read_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_largest_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#read_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.read_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper around trimesh.load_mesh such that the mesh is read exactly with the same vertices and face indexes by default. Additionally we introduce a convenient flag to keep just the largest mesh component</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshfile</strong><span class="classifier">filepath</span></dt><dd><p>input mesh of any common format, e.g. .obj, .ply, .dae, .stl, see <a class="reference external" href="https://trimsh.org/index.html">https://trimsh.org/index.html</a></p>
</dd>
<dt><strong>process</strong><span class="classifier">bool</span></dt><dd><p>If True, degenerate and duplicate faces will be removed immediately, and some functions will alter the mesh to ensure consistent results.</p>
</dd>
<dt><strong>validate</strong><span class="classifier">bool</span></dt><dd><p>if True, Nan and Inf values will be removed immediately and vertices will be merged</p>
</dd>
<dt><strong>keep_largest_only</strong><span class="classifier">bool</span></dt><dd><p>if True, keep only the largest connected component of the mesh, ignoring whether this is watertight or not</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh or trimesh.Scene</span></dt><dd><p>loaded mesh geometry</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.reconstruct_border_inds">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">reconstruct_border_inds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">all_border_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corner_inds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#reconstruct_border_inds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.reconstruct_border_inds" title="Permalink to this definition"></a></dt>
<dd><p>Given an ordered list of corner indices within an array of boundary indices specifying a closed loop, construct the continuous line segments linking the corner points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>all_border_inds</strong><span class="classifier">(N,) array</span></dt><dd><p>array of vertex indices specifying the boundary of a mesh</p>
</dd>
<dt><strong>corner_inds</strong><span class="classifier">(n_corners,) array</span></dt><dd><p>array specifying which indices of <code class="docutils literal notranslate"><span class="pre">all_border_inds</span></code> are ‘corners’. This should be ordered such that corner_inds[0]:corner_inds[1] constitute a continuous segment.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>segs</strong><span class="classifier">list of n_corners+1 arrays</span></dt><dd><p>a list of all the continuous boundary segments between consecutive corners</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.recover_img_coordinate_conformal_mean_flow">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">recover_img_coordinate_conformal_mean_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Usteps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#recover_img_coordinate_conformal_mean_flow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.recover_img_coordinate_conformal_mean_flow" title="Permalink to this definition"></a></dt>
<dd><p>This function reverses the iterative, centroid computation, subtraction and area normalisation in the conformalized mean curvature flow of a general 3D mesh, <a class="reference internal" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow" title="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow()</span></code></a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>Usteps</strong><span class="classifier">(n_vertices,3,niters) array</span></dt><dd><p>the area normalised vertex positions of a 3D mesh for every iteration of the conformalized mean curvature flow. 1st output of <a class="reference internal" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow" title="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow()</span></code></a> computed with rescale_output=False</p>
</dd>
<dt><strong>flow_dict :</strong></dt><dd><p>the statistical measures of a mesh deformed under conformalized mean curvature flow. 3rd output of <a class="reference internal" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow" title="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow()</span></code></a></p>
<dl class="simple">
<dt>‘mean_curvature_iter’<span class="classifier">array</span></dt><dd><p>mean of absolute values of mean curvature per face per iteration</p>
</dd>
<dt>‘max_curvature_iter’<span class="classifier">array</span></dt><dd><p>maximum of absolute values of mean curvature per face per iteration</p>
</dd>
<dt>‘gauss_curvature_iter’<span class="classifier">array</span></dt><dd><p>mean of absolute values of Gaussian curvature per face per iteration</p>
</dd>
<dt>‘canonical_c_all’<span class="classifier">array</span></dt><dd><p>array of the computed face area weighted centroid per iteration with respect to an area normalised mesh</p>
</dd>
<dt>‘canonical_area_all’<span class="classifier">array </span></dt><dd><p>array of the total surface area used for area normalising per iteration</p>
</dd>
<dt>‘flow_d_all’<span class="classifier">array</span></dt><dd><p>matrix norm difference between current and previous vertex coordinate positions</p>
</dd>
<dt>‘V0_max’<span class="classifier">scalar</span></dt><dd><p>the maximum scalar value over all coordinate values used to initially scale the mesh vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Usteps_</strong><span class="classifier">(n_vertices,3,niters) array</span></dt><dd><p>the reconstructed image vertex positions of a 3D mesh for every iteration of the conformalized mean curvature flow, identical to if <a class="reference internal" href="#unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow" title="unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.conformalized_mean_curvature_flow()</span></code></a> had been run with rescale_output=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.rectangular_conformal_map">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">rectangular_conformal_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map2square</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_bdy_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#rectangular_conformal_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.rectangular_conformal_map" title="Permalink to this definition"></a></dt>
<dd><p>Compute the rectangular conformal mapping using the fast method in <a class="reference internal" href="#r0efba6e0b7b1-1" id="id49">[1]</a>. This first maps the open mesh to a disk then from a disk to the rectangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices, 3) array</span></dt><dd><p>vertex coordinates of a simply-connected open triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces, 3) array</span></dt><dd><p>triangulations of a simply-connected open triangle mesh</p>
</dd>
<dt><strong>corner</strong><span class="classifier">(4,) array</span></dt><dd><p>optional input for specifying the exact 4 vertex indices for the four corners of the final rectangle, with anti-clockwise orientation</p>
</dd>
<dt><strong>map2square</strong><span class="classifier">bool</span></dt><dd><p>if True, do the rectangular conformal map, else if False, return the intermediate Harmonic disk parametrization which is much faster.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int</span></dt><dd><p>if corner is None, this is a random seed that randomly picks the 4 corners of the final rectangle from the input vertices.</p>
</dd>
<dt><strong>return_bdy_index</strong><span class="classifier">bool</span></dt><dd><p>if True, returns additionally the indices of the vertex that form the boundary of the input triangle mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>map_</strong><span class="classifier">(n_vertices,2) array</span></dt><dd><p>vertex coordinates of the rectangular conformal parameterization if map2square=True of the harmonic disk conformal parametrization if map2square=False.</p>
</dd>
<dt><strong>h_opt</strong><span class="classifier">scalar</span></dt><dd><p>if map2square=True, return the optimal y-coordinate scaling factor to have the lowest Beltrami coefficient in the rectangular conformal map</p>
</dd>
<dt>bdy_index :</dt><dd><p>if return_bdy_index=True, return as the last output the vertex indices that form the boundary of the input triangle mesh</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Please make sure that the input mesh does not contain any unreferenced vertices/non-manifold vertices/non-manifold edges.</p></li>
<li><p>Please remove all valence 1 boundary vertices (i.e. vertices with only 1 face attached to them) before running the program.</p></li>
<li><p>Please make sure that the input triangulations f are with anti-clockwise orientation.</p></li>
<li><p>The output rectangular domain will always have width = 1, while the height depends on the choice of the corners and may not be 1. (The Riemann mapping theorem guarantees that there exists a conformal map from any simple-connected open surface to the unit square, but if four vertices on the surface boundary are specified to be the four corners of the planar domain, the theorem is no longer applicable.)</p></li>
</ol>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0efba6e0b7b1-1"><span class="brackets"><a class="fn-backref" href="#id49">1</a></span></dt>
<dd><ol class="upperalpha simple" start="20">
<li><ol class="upperalpha simple" start="23">
<li><p>Meng, G. P.-T. Choi and L. M. Lui, “TEMPO: Feature-Endowed Teichmüller Extremal Mappings of Point Clouds.” SIAM Journal on Imaging Sciences, 9(4), pp. 1922-1962, 2016.</p></li>
</ol>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.relax_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">relax_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relax_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CVT</span> <span class="pre">(block-diagonal)'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#relax_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.relax_mesh" title="Permalink to this definition"></a></dt>
<dd><p>wraps the optimesh library to perform mesh relaxation with Delaunay edge flipping. This is done mainly to improve triangle quality to improve the convergence of linear algebra solvers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh_in</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh to relax</p>
</dd>
<dt><strong>relax_method</strong><span class="classifier">str</span></dt><dd><p>any of those compatible with optimesh.optimize()</p>
</dd>
<dt><strong>tol</strong><span class="classifier">scalar</span></dt><dd><p>sets the accepted tolerance for convergence</p>
</dd>
<dt><strong>n_iters</strong><span class="classifier">int</span></dt><dd><p>the maximum number of iterations</p>
</dd>
<dt><strong>omega</strong><span class="classifier">scalar</span></dt><dd><p>controls the stepping size, smaller values will have better accuracy but slower convergence.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output relaxed mesh with no change in the number of vertices but with changes to faces</p>
</dd>
<dt><strong>opt_result</strong><span class="classifier">optimization results</span></dt><dd><p>returns tuple of number of iterations and difference</p>
</dd>
<dt><strong>mean_mesh_quality</strong><span class="classifier">scalar</span></dt><dd><p>mean triangle quanlity, where trangle quality is 2*inradius/circumradius</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.remove_small_mesh_components_binary">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">remove_small_mesh_components_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels_bool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#remove_small_mesh_components_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.remove_small_mesh_components_binary" title="Permalink to this definition"></a></dt>
<dd><p>Remove small connected components of a binary labelled mesh. Connected components is run and regions with number of vertices/faces or covering an area less than the specified threshold is removed by returning a new binary label array where they have been set to 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>vertices of the triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>faces of the triangle mesh</p>
</dd>
<dt><strong>labels</strong><span class="classifier">(n_vertices,) or (n_faces,) array</span></dt><dd><p>the binary labels either specified for the vertex or face. Which is which is set by the parameter <code class="docutils literal notranslate"><span class="pre">vertex_labels_bool</span></code>.</p>
</dd>
<dt><strong>vertex_labels_bool</strong><span class="classifier">bool</span></dt><dd><p>if True, process the <code class="docutils literal notranslate"><span class="pre">labels</span></code> as associated with vertices or if False, process the <code class="docutils literal notranslate"><span class="pre">labels</span></code> as associated with faces.</p>
</dd>
<dt><strong>physical_size</strong><span class="classifier">bool</span></dt><dd><p>if True, interpret <code class="docutils literal notranslate"><span class="pre">minsize</span></code> as the minimum surface area of each connected component. If False, interpret <code class="docutils literal notranslate"><span class="pre">minsize</span></code> as the minimum number of vertex/face elements within the connected component</p>
</dd>
<dt><strong>minsize</strong><span class="classifier">scalar</span></dt><dd><p>if physical_size=True, the minimum surface area of a connected component or if physical_size=False, the minimum number of vertex/face elements within the connected component</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels_clean</strong><span class="classifier">(n_vertices,) or (n_faces,) array</span></dt><dd><p>The updated vertex (if vertex_labels_bool=True) or face (if vertex_labels_bool=False) binary label array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.remove_small_mesh_components_labels">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">remove_small_mesh_components_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels_bool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_largest_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#remove_small_mesh_components_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.remove_small_mesh_components_labels" title="Permalink to this definition"></a></dt>
<dd><p>Remove small connected components of a multi-labelled integer mesh. Connected components is run on each labelled region and disconnected regions with number of vertices/faces or covering an area less than the specified threshold is removed by returning a new multi label array where they have been set to the specified background label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>vertices of the triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>faces of the triangle mesh</p>
</dd>
<dt><strong>labels</strong><span class="classifier">(n_vertices,) or (n_faces,) array</span></dt><dd><p>the integer labels specified for the vertex or face as determined by the boolean parameter <code class="docutils literal notranslate"><span class="pre">vertex_labels_bool</span></code>.</p>
</dd>
<dt><strong>bg_label</strong><span class="classifier">int</span></dt><dd><p>the integer label of background regions</p>
</dd>
<dt><strong>vertex_labels_bool</strong><span class="classifier">bool</span></dt><dd><p>if True, process the <code class="docutils literal notranslate"><span class="pre">labels</span></code> as associated with vertices or if False, process the <code class="docutils literal notranslate"><span class="pre">labels</span></code> as associated with faces.</p>
</dd>
<dt><strong>physical_size</strong><span class="classifier">bool</span></dt><dd><p>if True, interpret <code class="docutils literal notranslate"><span class="pre">minsize</span></code> as the minimum surface area of each connected component. If False, interpret <code class="docutils literal notranslate"><span class="pre">minsize</span></code> as the minimum number of vertex/face elements within the connected component</p>
</dd>
<dt><strong>minsize</strong><span class="classifier">scalar</span></dt><dd><p>if physical_size=True, the minimum surface area of a connected component or if physical_size=False, the minimum number of vertex/face elements within the connected component</p>
</dd>
<dt><strong>keep_largest_only</strong><span class="classifier">bool</span></dt><dd><p>if True, keep only the largest connected region per label of size &gt; minsize. if False, all connected regions per label of size &gt; minsize is kept</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels_clean</strong><span class="classifier">(n_vertices,) or (n_faces,) array</span></dt><dd><p>The updated vertex (if vertex_labels_bool=True) or face (if vertex_labels_bool=False) multi label array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.remove_small_mesh_label_holes_binary">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">remove_small_mesh_label_holes_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_labels_bool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">physical_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#remove_small_mesh_label_holes_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.remove_small_mesh_label_holes_binary" title="Permalink to this definition"></a></dt>
<dd><p>Remove small binary holes i.e. small islands of zeros within a region of 1s in a binary-labelled mesh. Connected components is run on 0’s and regions with number of vertices/faces or covering an area less than the specified threshold is removed by returning a new binary label array where they have been set to 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">(n_vertices,) array</span></dt><dd><p>vertices of the triangle mesh</p>
</dd>
<dt><strong>f</strong><span class="classifier">(n_faces,) array</span></dt><dd><p>faces of the triangle mesh</p>
</dd>
<dt><strong>labels</strong><span class="classifier">(n_vertices,) or (n_faces,) array</span></dt><dd><p>the binary labels specified for the vertex or face as determined by the boolean parameter <code class="docutils literal notranslate"><span class="pre">vertex_labels_bool</span></code>.</p>
</dd>
<dt><strong>vertex_labels_bool</strong><span class="classifier">bool</span></dt><dd><p>if True, process the <code class="docutils literal notranslate"><span class="pre">labels</span></code> as associated with vertices or if False, process the <code class="docutils literal notranslate"><span class="pre">labels</span></code> as associated with faces.</p>
</dd>
<dt><strong>physical_size</strong><span class="classifier">bool</span></dt><dd><p>if True, interpret <code class="docutils literal notranslate"><span class="pre">minsize</span></code> as the minimum surface area of each connected component. If False, interpret <code class="docutils literal notranslate"><span class="pre">minsize</span></code> as the minimum number of vertex/face elements within the connected component</p>
</dd>
<dt><strong>minsize</strong><span class="classifier">scalar</span></dt><dd><p>if physical_size=True, the minimum surface area of a connected component or if physical_size=False, the minimum number of vertex/face elements within the connected component</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels_clean</strong><span class="classifier">(n_vertices,) or (n_faces,) array</span></dt><dd><p>The updated vertex (if vertex_labels_bool=True) or face (if vertex_labels_bool=False) binary array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.rescale_mesh_points_to_grid_size">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">rescale_mesh_points_to_grid_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rect_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#rescale_mesh_points_to_grid_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.rescale_mesh_points_to_grid_size" title="Permalink to this definition"></a></dt>
<dd><p>Give a rectangular-like mesh where the last 2 coordinate axes is the 2D xy coordinates such as that from a rectangular conformal map, resize points coordinates along x- and y- axes onto a given image grid so that we can for example interpolate mesh values onto an image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rect_mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input 2D mesh where the first 2 coordinate axes is the 2D xy coordinates</p>
</dd>
<dt><strong>grid</strong><span class="classifier">(M,N) or (M,N,d) single- or multi- channel image</span></dt><dd><p>input image to get the (M,N) shape</p>
</dd>
<dt><strong>grid_shape</strong><span class="classifier">(M,N) tuple</span></dt><dd><p>the shape of the grid, only used if grid is not specified. Only one of grid or grid_shape needs to be passed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_ref</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output 2D mesh with resized vertex coordinates where like input the last 2 coordinate axes is the 2D xy coordinates</p>
</dd>
<dt><strong>grid_shape</strong><span class="classifier">(M,N) tuple</span></dt><dd><p>the shape of the image grid, the output mesh indexes into</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.sliced_wasserstein_distance_trimesh_trimesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">sliced_wasserstein_distance_trimesh_trimesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trimesh1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trimesh2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#sliced_wasserstein_distance_trimesh_trimesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.sliced_wasserstein_distance_trimesh_trimesh" title="Permalink to this definition"></a></dt>
<dd><p>Compute the sliced Wasserstein distance approximation between two triangle meshes which gives a proxy of the Wasserstein distance using summed 1D random projections. 
This method is advantageous in terms of speed and computational resources for very large meshes.</p>
<p>The triangle meshes are converted into a weighted point cloud or measure using the normalised triangle area</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trimesh1</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>trimesh2</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>n_seeds</strong><span class="classifier">int</span></dt><dd><p>the number of trials to average the distance over. Larger numbers give greater stability</p>
</dd>
<dt><strong>n_projections</strong><span class="classifier">int</span></dt><dd><p>the number of 1D sliced random projections to sum over</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>the order of the Wasserstein distance. 1 is equivalent to the Earth Mover’s distance</p>
</dd>
<dt><strong>mode</strong><span class="classifier">‘max’ or any other string</span></dt><dd><p>if mode=’max’ compute the maximum sliced wasserstein distance see <code class="docutils literal notranslate"><span class="pre">ot.max_sliced_wasserstein_distance</span></code> in the Python Optimal Transport library</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>if specified, fix the random seed for reproducibility runs</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sliced_W_dist</strong><span class="classifier">scalar</span></dt><dd><p>the mean sliced wasserstein distance between the two meshes over <cite>n_seeds</cite> iterations</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><a class="reference external" href="https://pythonot.github.io/">https://pythonot.github.io/</a> for sliced wassersten distance computation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.sliced_wasserstein_distance_trimesh_uv">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">sliced_wasserstein_distance_trimesh_uv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trimesh1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv_to_trimesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_projections</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#sliced_wasserstein_distance_trimesh_uv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.sliced_wasserstein_distance_trimesh_uv" title="Permalink to this definition"></a></dt>
<dd><p>Compute the sliced Wasserstein distance approximation between a triangle mesh and a (u,v) image parameterized 3D mesh which gives a proxy of the Wasserstein distance using summed 1D random projections. 
This method is advantageous in terms of speed and computational resources for very large meshes.</p>
<p>The triangle meshes are converted into a weighted point cloud or measure using the normalised triangle area</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trimesh1</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>uv2</strong><span class="classifier">(U,V,3) array</span></dt><dd><p>a (u,v) image parameterized 3D surface</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>a small constant for numerical stability</p>
</dd>
<dt><strong>pad</strong><span class="classifier">bool</span></dt><dd><p>if True, uses edge padding to compute the finite differences for evaluating the differential areas of <code class="docutils literal notranslate"><span class="pre">uv2</span></code></p>
</dd>
<dt><strong>uv_to_trimesh</strong><span class="classifier">bool</span></dt><dd><p>if True, convert the (u,v) image parameterized 3D triangle mesh into a 3D triangle mesh before evaluating the difference.</p>
</dd>
<dt><strong>n_seeds</strong><span class="classifier">int</span></dt><dd><p>the number of trials to average the distance over. Larger numbers give greater stability</p>
</dd>
<dt><strong>n_projections</strong><span class="classifier">int</span></dt><dd><p>the number of 1D sliced random projections to sum over</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>the order of the Wasserstein distance. 1 is equivalent to the Earth Mover’s distance</p>
</dd>
<dt><strong>mode</strong><span class="classifier">‘max’ or any other string</span></dt><dd><p>if mode=’max’ compute the maximum sliced wasserstein distance see <code class="docutils literal notranslate"><span class="pre">ot.max_sliced_wasserstein_distance</span></code> in the Python Optimal Transport library</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>if specified, fix the random seed for reproducibility runs</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sliced_W_dist</strong><span class="classifier">scalar</span></dt><dd><p>the mean sliced wasserstein distance between the two meshes over <cite>n_seeds</cite> iterations</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><a class="reference external" href="https://pythonot.github.io/">https://pythonot.github.io/</a> for sliced wassersten distance computation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.smooth_scalar_function_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">smooth_scalar_function_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#smooth_scalar_function_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.smooth_scalar_function_mesh" title="Permalink to this definition"></a></dt>
<dd><p>wraps the optimesh library to perform mesh relaxation with Delaunay edge flipping. This is done mainly to improve triangle quality to improve the convergence of linear algebra solvers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>scalar_fn</strong><span class="classifier">(n_vertices,d) array</span></dt><dd><p>the d-dimensional scalar values to spatially smooth over the mesh</p>
</dd>
<dt><strong>exact</strong><span class="classifier">bool</span></dt><dd><p>if True, evaluates the normalised <span class="math notranslate nohighlight">\(M^-1 L\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the mass and <span class="math notranslate nohighlight">\(L\)</span> is the cotan Laplacian matrices respectively and uses this as the weights for spatial smoothing. The inversion is very slow. Setting to False, use the cotan Laplacian to smooth.</p>
</dd>
<dt><strong>n_iters</strong><span class="classifier">int</span></dt><dd><p>the maximum number of iterations</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(n_vertices,n_vertices) sparse array</span></dt><dd><p>user-specified vertex smoothing matrix. This overrides the options of <code class="docutils literal notranslate"><span class="pre">exact</span></code>.</p>
</dd>
<dt><strong>return_weights</strong><span class="classifier">bool</span></dt><dd><p>return additionally the weights matrix used as a second optional output</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">0-1 scalar</span></dt><dd><p>not used at present</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scalar0</strong><span class="classifier">(n_vertices,d) array</span></dt><dd><p>the spatially smoothed d-dimensional scalar values over the mesh</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(n_vertices,n_vertices) sparse array</span></dt><dd><p>if return_weights=True, the weights used is returned for convenience if the user wishes to reuse the weights e.g. to avoid recomputing.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.split_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">split_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_face_attributes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_watertight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#split_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.split_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Split a mesh into multiple meshes from face connectivity taken from the Trimesh library. If only_watertight is true it will only return watertight meshes and will attempt to repair
single triangle or quad holes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd></dd>
<dt><strong>only_watertight: bool</strong></dt><dd><p>Only return watertight components</p>
</dd>
<dt><strong>adjacency</strong><span class="classifier">(n, 2) int</span></dt><dd><p>Face adjacency to override full mesh</p>
</dd>
<dt><strong>engine</strong><span class="classifier">str or None</span></dt><dd><p>Which graph engine to use</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>meshes</strong><span class="classifier">(m,) trimesh.Trimesh</span></dt><dd><p>Results of splitting</p>
</dd>
<dt><strong>meshes_attributes</strong><span class="classifier">(m,d) attributes.</span></dt><dd><p>associated splitted attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.submesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">submesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces_sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_face_attributes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repair</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_watertight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_faces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">append</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#submesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.submesh" title="Permalink to this definition"></a></dt>
<dd><p>Return a subset of a mesh. Function taken from the Trimesh library.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh</span></dt><dd><p>Source mesh to take geometry from</p>
</dd>
<dt><strong>faces_sequence</strong><span class="classifier">sequence (p,) int</span></dt><dd><p>Indexes of mesh.faces</p>
</dd>
<dt><strong>only_watertight</strong><span class="classifier">bool</span></dt><dd><p>Only return submeshes which are watertight.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool</span></dt><dd><p>Return a single mesh which has the faces appended, if this flag is set, only_watertight is ignored</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>if append</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
<dt>else        list of Trimesh objects</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.unit_sphere_normalize_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">unit_sphere_normalize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centroid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'area'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#unit_sphere_normalize_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.unit_sphere_normalize_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Normalize the mesh vertices by direct projection onto the unit sphere by normalising the displacement vector relative to the centroid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>map_color</strong><span class="classifier">bool</span></dt><dd><p>if True, copy across the vertex and face colors to the new normalised mesh</p>
</dd>
<dt><strong>centroid</strong><span class="classifier">str</span></dt><dd><p>specifies the method for computing the centroid of the mesh. If ‘area’ the face area weighted centroid is computed from triangle barycenter. If ‘points’ the centroid is computed from triangle barycenters with no weighting</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_out</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output normalized mesh</p>
</dd>
<dt><strong>(v_mean, v_out_scale)</strong><span class="classifier">((3,) array, scalar)</span></dt><dd><p>the computed centroid and scalar normalisation</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.upsample_mesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">upsample_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inplane'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#upsample_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.upsample_mesh" title="Permalink to this definition"></a></dt>
<dd><p>Upsample a given mesh using simple barycentric splittng (‘inplane’) or using ‘loop’, which slightly smoothes the output</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>one of ‘inplane’ or ‘loop’ allowed in igl.upsample</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_out</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.upsample_mesh_and_vertex_vals">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">upsample_mesh_and_vertex_vals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inplane'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#upsample_mesh_and_vertex_vals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.upsample_mesh_and_vertex_vals" title="Permalink to this definition"></a></dt>
<dd><p>Upsample a given mesh using simple barycentric splittng (‘inplane’) or using ‘loop’, which slightly smoothes the output and also reinterpolate any associated vertex values for the new mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>vals</strong><span class="classifier">(n_vertices, n_features)</span></dt><dd><p>vertex based values to also upsample</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>one of ‘inplane’ or ‘loop’ allowed in igl.upsample</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_out</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>output mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.uv_surface_pulldown_mesh_surface_coords">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">uv_surface_pulldown_mesh_surface_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Varray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cross'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_interp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#uv_surface_pulldown_mesh_surface_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.uv_surface_pulldown_mesh_surface_coords" title="Permalink to this definition"></a></dt>
<dd><p>Main function to unwrap a list of 3D triangle meshes given by their vertices onto a 2D image grid based on matching the uv-unwrap of a joint 3D triangle mesh typically this is the uv-rectangle and the unit sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unwrap_params</strong><span class="classifier">(M,N,3)</span></dt><dd><p>(u,v) parameterization of the 3D triangle mesh given by <cite>mesh_ref</cite></p>
</dd>
<dt><strong>mesh_ref</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the 3D triangle mesh equivalent of the geometry specified <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> e.g. the unit sphere when <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> is the UV-map</p>
</dd>
<dt><strong>Varray</strong><span class="classifier">list of (n_vertices,3)</span></dt><dd><p>a list of 3D meshes given only by their vertices whom are bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> such that they share the same number of vertices and the same face connectivity</p>
</dd>
<dt><strong>match_method</strong><span class="classifier">str</span></dt><dd><p>one of ‘cross’ implementing <a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a> or ‘cramer’ implementing <a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a> for computing the barycentric coordinate after matching each image pixel to the rect_mesh</p>
</dd>
<dt><strong>return_interp</strong><span class="classifier">bool</span></dt><dd><p>if True, also return the matching parameters between <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> for reuse</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pulldown_Varray_coords</strong><span class="classifier">(len(Varray),M,N,3) array</span></dt><dd><p>The UV-unwrapping of all 3D surface meshes bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code></p>
</dd>
<dt><strong>(mesh_tri_id, mesh_ref_closest_pt_barycentric)</strong><span class="classifier">( (M*N,), (M*N,3) ) tuple of arrays</span></dt><dd><p>These are the matching parameters that establish correspondence between <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> in order to map all other 3D meshes given by <code class="docutils literal notranslate"><span class="pre">Varray</span></code> bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> into the 2D grid specified by <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">vertex_dihedral_angle_affinity_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#vertex_dihedral_angle_affinity_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute an affinity distance matrix of the vertex dihedral angles. This is done by computing the vertex dihedral angle distances and applying a heat kernel.</p>
<div class="math notranslate nohighlight">
\[A_{angle} = \exp^{\left(\frac{-D_{angle}^2}{2\sigma^2}\right)}\]</div>
<p>where <span class="math notranslate nohighlight">\(sigma\)</span> is set as the mean distance of <span class="math notranslate nohighlight">\(D\)</span> or <span class="math notranslate nohighlight">\(\gamma\)</span> if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input mesh</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar</span></dt><dd><p>a scalar normalisation of the distances in the distance matrix</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>a small constant for numerical stability</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(n_vertices, n_vertices) sparse array</span></dt><dd><p>a matrix capturing the euclidean dihedral angle cosine distance affinity between vertex_i to vertex_j of vertex neighbors. This is a normalised measure of distances with values mainly in the scale of [0,1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.vertex_dihedral_angle_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">vertex_dihedral_angle_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#vertex_dihedral_angle_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.vertex_dihedral_angle_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Build the Dihedral angle matrix for vertices given an input mesh. The dihedral angles, is the angle between the normals of pairs of vertices measures the local mesh convexity. the dihedral angle is captured as a cosime distance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input mesh</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>a small constant scalar for numerical stability</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angles_edges_matrix</strong><span class="classifier">(n_vertices, n_vertices) sparse array</span></dt><dd><p>a matrix capturing the dihedral angle between vertex_i to vertex_j between vertex neighbors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">vertex_edge_affinity_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#vertex_edge_affinity_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute an affinity distance matrix of the edge distances. This is done by computing the pairwise edge length distances between vertex neighbors and applying a heat kernel.</p>
<div class="math notranslate nohighlight">
\[A_{dist} = \exp^{\left(\frac{-D_{dist}^2}{2\sigma^2}\right)}\]</div>
<p>where <span class="math notranslate nohighlight">\(sigma\)</span> is set as the mean distance of <span class="math notranslate nohighlight">\(D\)</span> or <span class="math notranslate nohighlight">\(\gamma\)</span> if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input mesh</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar</span></dt><dd><p>a scalar normalisation of the distances in the distance matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A</strong><span class="classifier">(n_vertices, n_vertices) sparse array</span></dt><dd><p>a matrix capturing the euclidean edge affinity between vertex_i to vertex_j of vertex neighbors. This is a normalised measure of distances with values mainly in the scale of [0,1]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.vertex_edge_lengths_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">vertex_edge_lengths_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#vertex_edge_lengths_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.vertex_edge_lengths_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Build the edge distance matrix between local vertex neighbors of the input mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>D</strong><span class="classifier">(n_vertices, n_vertices) sparse array</span></dt><dd><p>a matrix capturing the euclidean edge distance between vertex_i to vertex_j of vertex neighbors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.vertex_geometric_affinity_matrix">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">vertex_geometric_affinity_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#vertex_geometric_affinity_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.vertex_geometric_affinity_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Compute an affinity matrix balancing geodesic distances and convexity by taking a weighted average of the edge distance affinity matrix and the vertex dihedral angle affinity matrix.</p>
<div class="math notranslate nohighlight">
\[A = \alpha A_{dist} + (1-\alpha) A_{dihedral}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the input mesh</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">scalar</span></dt><dd><p>a scalar normalisation of the distances in the distance matrix</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>a small constant for numerical stability of the dihedral angle distance matrix</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">0-1</span></dt><dd><p>the weight for averaging the two affinity matrices</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>if True, apply left normalization to the averaged affinity matrix given by <span class="math notranslate nohighlight">\(M^{-1}A\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the mass matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">(n_vertex, n_vertex) scipy sparse matrix</span></dt><dd><p>the combined average affinity matrix</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix" title="unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.vertex_edge_affinity_matrix()</span></code></a></dt><dd><p>function used to compute the vertex edge distance affinity matrix</p>
</dd>
<dt><a class="reference internal" href="#unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix" title="unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.vertex_dihedral_angle_affinity_matrix()</span></code></a></dt><dd><p>function used to compute the vertex dihedral angle distance affinity matrix</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.voxelize_image_mesh_pts">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">voxelize_image_mesh_pts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilate_ksize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">erode_ksize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vol_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upsample_iters_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#voxelize_image_mesh_pts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.voxelize_image_mesh_pts" title="Permalink to this definition"></a></dt>
<dd><p>Given a surface mesh, voxelises the mesh to create a closed binary volume to enable for exampled signed distance function comparison and for repairing small holes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>input mesh</p>
</dd>
<dt><strong>pad</strong><span class="classifier">int</span></dt><dd><p>integer isotropic pad to create a volume grid if vol_shape is not given</p>
</dd>
<dt><strong>dilate_ksize</strong><span class="classifier">int</span></dt><dd><p>optional dilation of the voxelized volume with a ball kernel of specified radius to fill holes so that scipy.ndimage.morphology.binary_fill_holes will allow a complete volume to be otained</p>
</dd>
<dt><strong>erode_ksize</strong><span class="classifier">int</span></dt><dd><p>optional erosion of the voxelized volume with a ball kernel of specified radius</p>
</dd>
<dt><strong>vol_shape</strong><span class="classifier">(m,n,l) tuple</span></dt><dd><p>the size of the volume image to voxelize onto</p>
</dd>
<dt><strong>upsample_iters_max</strong><span class="classifier">int</span></dt><dd><p>the maximum number of recursive mesh subdivisions to achieve the target pitch</p>
</dd>
<dt><strong>pitch</strong><span class="classifier">scalar</span></dt><dd><p>target side length of each voxel, the mesh will be recursively subdivided up to the maximum number of iterations specified by <code class="docutils literal notranslate"><span class="pre">upsample_iters_max</span></code> until this is met.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>smooth_img_binary</strong><span class="classifier">(MxNxL) array</span></dt><dd><p>binary volume image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.wasserstein_distance_trimesh_trimesh">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">wasserstein_distance_trimesh_trimesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trimesh1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trimesh2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#wasserstein_distance_trimesh_trimesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.wasserstein_distance_trimesh_trimesh" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Wasserstein distance between two triangle meshes using the Sinkhorn approximation and point cloud subsampling</p>
<p>The triangle meshes are converted into a weighted point cloud or measure using the normalised triangle area</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trimesh1</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>trimesh2</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>n_samples_1</strong><span class="classifier">int</span></dt><dd><p>the number of uniformly sampled random vertices from trimesh1</p>
</dd>
<dt><strong>n_samples_2</strong><span class="classifier">int</span></dt><dd><p>the number of uniformly sampled random vertices from trimesh2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sinkhorn_dist</strong><span class="classifier">scalar</span></dt><dd><p>the approximated wasserstein distance between the two meshes</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><a class="reference external" href="https://github.com/fwilliams/point-cloud-utils">https://github.com/fwilliams/point-cloud-utils</a> for sinkhorn computation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.wasserstein_distance_trimesh_uv">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">wasserstein_distance_trimesh_uv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trimesh1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uv_to_trimesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples_2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#wasserstein_distance_trimesh_uv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.wasserstein_distance_trimesh_uv" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Wasserstein distance between a triangle 3D mesh and a (u,v) image parameterized 3D mesh using the Sinkhorn approximation and point cloud subsampling</p>
<p>The meshes are converted into a weighted point cloud or measure using the normalised areas</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trimesh1</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>a 3D triangle mesh</p>
</dd>
<dt><strong>uv2</strong><span class="classifier">(U,V,3) array</span></dt><dd><p>a (u,v) image parameterized 3D surface</p>
</dd>
<dt><strong>eps</strong><span class="classifier">scalar</span></dt><dd><p>a small constant for numerical stability</p>
</dd>
<dt><strong>pad</strong><span class="classifier">bool</span></dt><dd><p>if True, uses edge padding to compute the finite differences for evaluating the differential areas of <code class="docutils literal notranslate"><span class="pre">uv2</span></code></p>
</dd>
<dt><strong>uv_to_trimesh</strong><span class="classifier">bool</span></dt><dd><p>if True, convert the (u,v) image parameterized 3D triangle mesh into a 3D triangle mesh before evaluating the difference.</p>
</dd>
<dt><strong>n_samples_1</strong><span class="classifier">int</span></dt><dd><p>the number of uniformly sampled random vertices from trimesh1</p>
</dd>
<dt><strong>n_samples_2</strong><span class="classifier">int</span></dt><dd><p>the number of uniformly sampled random vertices from trimesh2</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sinkhorn_dist</strong><span class="classifier">scalar</span></dt><dd><p>the approximated wasserstein distance between the two meshes</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><a class="reference external" href="https://github.com/fwilliams/point-cloud-utils">https://github.com/fwilliams/point-cloud-utils</a> for sinkhorn computation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="unwrap3D.Mesh.meshtools.xyz_surface_pulldown_mesh_surface_coords">
<span class="sig-prename descclassname"><span class="pre">unwrap3D.Mesh.meshtools.</span></span><span class="sig-name descname"><span class="pre">xyz_surface_pulldown_mesh_surface_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Varray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_tri_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_ref_closest_pt_barycentric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cross'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_interp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/unwrap3D/Mesh/meshtools.html#xyz_surface_pulldown_mesh_surface_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#unwrap3D.Mesh.meshtools.xyz_surface_pulldown_mesh_surface_coords" title="Permalink to this definition"></a></dt>
<dd><p>Main function to unwrap a list of 3D triangle meshes given by their vertices bijective to a common 3D mesh onto another 3D surface through proximity-based matching</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unwrap_params</strong><span class="classifier">(N,3)</span></dt><dd><p>3D triangle mesh to transfer coordinates to</p>
</dd>
<dt><strong>mesh_ref</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>the 3D triangle mesh equivalent or similar to the geometry of <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> bijective to geometrices given by <cite>Varray</cite></p>
</dd>
<dt><strong>Varray</strong><span class="classifier">list of (n_vertices,3)</span></dt><dd><p>a list of 3D meshes given only by their vertices whom are bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> such that they share the same number of vertices and the same face connectivity</p>
</dd>
<dt><strong>match_method</strong><span class="classifier">str</span></dt><dd><p>one of ‘cross’ implementing <a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a> or ‘cramer’ implementing <a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a> for computing the barycentric coordinate after matching each image pixel to the rect_mesh</p>
</dd>
<dt><strong>return_interp</strong><span class="classifier">bool</span></dt><dd><p>if True, also return the matching parameters between <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> for reuse</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pulldown_Varray_coords</strong><span class="classifier">(len(Varray),N,3) array</span></dt><dd><p>The remapped coordinates of 3D surface meshes bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> as vertex measurements on <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code></p>
</dd>
<dt><strong>(mesh_tri_id, mesh_ref_closest_pt_barycentric)</strong><span class="classifier">( (M*N,), (M*N,3) ) tuple of arrays</span></dt><dd><p>Returned if return_interp=True. These are the matching parameters that establish correspondence between <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> in order to map all other 3D meshes given by <code class="docutils literal notranslate"><span class="pre">Varray</span></code> bijective to <code class="docutils literal notranslate"><span class="pre">mesh_ref</span></code> into the 2D grid specified by <code class="docutils literal notranslate"><span class="pre">unwrap_params</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-unwrap3D.Mesh">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-unwrap3D.Mesh" title="Permalink to this headline"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Felix Y. Zhou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>